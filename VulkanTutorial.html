<!DOCTYPE html>
<html>
<head>
<title>VulkanTutorial.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="1---introduction">1 - Introduction</h1>
<h2 id="about">About</h2>
<p>This tutorial will teach you the basics of using the <a href="https://www.khronos.org/vulkan/">Vulkan</a>
graphics and compute API. Vulkan is a new API by the <a href="https://www.khronos.org/">Khronos group</a>
(known for OpenGL) that provides a much better abstraction of modern graphics
cards. This new interface allows you to better describe what your application
intends to do, which can lead to better performance and less surprising driver
behavior compared to existing APIs like <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a>
and <a href="https://en.wikipedia.org/wiki/Direct3D">Direct3D</a>. The ideas behind Vulkan
are similar to those of <a href="https://en.wikipedia.org/wiki/Direct3D#Direct3D_12">Direct3D 12</a>
and <a href="https://en.wikipedia.org/wiki/Metal_(API)">Metal</a>, but Vulkan has the
advantage of being fully cross-platform and allows you to develop for Windows,
Linux and Android at the same time.</p>
<p>However, the price you pay for these benefits is that you have to work with a
significantly more verbose API. Every detail related to the graphics API needs
to be set up from scratch by your application, including initial frame buffer
creation and memory management for objects like buffers and texture images. The
graphics driver will do a lot less hand holding, which means that you will have
to do more work in your application to ensure correct behavior.</p>
<p>The takeaway message here is that Vulkan is not for everyone. It is targeted at
programmers who are enthusiastic about high performance computer graphics, and
are willing to put some work in. If you are more interested in game development,
rather than computer graphics, then you may wish to stick to OpenGL or Direct3D,
which will not be deprecated in favor of Vulkan anytime soon. Another
alternative is to use an engine like <a href="https://en.wikipedia.org/wiki/Unreal_Engine#Unreal_Engine_4">Unreal Engine</a>
or <a href="https://en.wikipedia.org/wiki/Unity_(game_engine)">Unity</a>, which will be
able to use Vulkan while exposing a much higher level API to you.</p>
<p>With that out of the way, let's cover some prerequisites for following this
tutorial:</p>
<ul>
<li>A graphics card and driver compatible with Vulkan (<a href="https://developer.nvidia.com/vulkan-driver">NVIDIA</a>, <a href="http://www.amd.com/en-us/innovations/software-technologies/technologies-gaming/vulkan">AMD</a>, <a href="https://software.intel.com/en-us/blogs/2016/03/14/new-intel-vulkan-beta-1540204404-graphics-driver-for-windows-78110-1540">Intel</a>, <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Apple-Silicon-Vulkan-MoltenVK">Apple Silicon (Or the Apple M1)</a>)</li>
<li>Experience with C++ (familiarity with RAII, initializer lists)</li>
<li>A compiler with decent support of C++17 features (Visual Studio 2017+, GCC 7+, Or Clang 5+)</li>
<li>Some existing experience with 3D computer graphics</li>
</ul>
<p>This tutorial will not assume knowledge of OpenGL or Direct3D concepts, but it
does require you to know the basics of 3D computer graphics. It will not explain
the math behind perspective projection, for example. See <a href="https://paroj.github.io/gltut/">this online book</a>
for a great introduction of computer graphics concepts. Some other great computer graphics resources are:</p>
<ul>
<li><a href="https://github.com/RayTracing/raytracing.github.io">Ray tracing in one weekend</a></li>
<li><a href="http://www.pbr-book.org/">Physically Based Rendering book</a></li>
<li>Vulkan being used in a real engine in the open-source <a href="https://github.com/Novum/vkQuake">Quake</a> and <a href="https://github.com/DustinHLand/vkDOOM3">DOOM 3</a></li>
</ul>
<p>You can use C instead of C++ if you want, but you will have to use a different
linear algebra library and you will be on your own in terms of code structuring.
We will use C++ features like classes and RAII to organize logic and resource
lifetimes. There is also an <a href="https://github.com/bwasty/vulkan-tutorial-rs">alternative version</a> of this tutorial available for Rust developers.</p>
<p>To make it easier to follow along for developers using other programming languages, and to get some experience with the base API we'll be using the original C API to work with Vulkan. If you are using C++, however, you may prefer using the newer <a href="https://github.com/KhronosGroup/Vulkan-Hpp">Vulkan-Hpp</a> bindings that abstract some of the dirty work and help prevent certain classes of errors.</p>
<h2 id="e-book">E-book</h2>
<p>If you prefer to read this tutorial as an e-book, then you can download an EPUB
or PDF version here:</p>
<ul>
<li><a href="https://raw.githubusercontent.com/Overv/VulkanTutorial/master/ebook/Vulkan%20Tutorial%20en.epub">EPUB</a></li>
<li><a href="https://raw.githubusercontent.com/Overv/VulkanTutorial/master/ebook/Vulkan%20Tutorial%20en.pdf">PDF</a></li>
</ul>
<h2 id="tutorial-structure">Tutorial structure</h2>
<p>We'll start with an overview of how Vulkan works and the work we'll have to do
to get the first triangle on the screen. The purpose of all the smaller steps
will make more sense after you've understood their basic role in the whole
picture. Next, we'll set up the development environment with the <a href="https://lunarg.com/vulkan-sdk/">Vulkan SDK</a>,
the <a href="http://glm.g-truc.net/">GLM library</a> for linear algebra operations and
<a href="http://www.glfw.org/">GLFW</a> for window creation. The tutorial will cover how
to set these up on Windows with Visual Studio, and on Ubuntu Linux with GCC.</p>
<p>After that we'll implement all of the basic components of a Vulkan program that
are necessary to render your first triangle. Each chapter will follow roughly
the following structure:</p>
<ul>
<li>Introduce a new concept and its purpose</li>
<li>Use all of the relevant API calls to integrate it into your program</li>
<li>Abstract parts of it into helper functions</li>
</ul>
<p>Although each chapter is written as a follow-up on the previous one, it is also
possible to read the chapters as standalone articles introducing a certain
Vulkan feature. That means that the site is also useful as a reference. All of
the Vulkan functions and types are linked to the specification, so you can click
them to learn more. Vulkan is a very new API, so there may be some shortcomings
in the specification itself. You are encouraged to submit feedback to
<a href="https://github.com/KhronosGroup/Vulkan-Docs">this Khronos repository</a>.</p>
<p>As mentioned before, the Vulkan API has a rather verbose API with many
parameters to give you maximum control over the graphics hardware. This causes
basic operations like creating a texture to take a lot of steps that have to be
repeated every time. Therefore we'll be creating our own collection of helper
functions throughout the tutorial.</p>
<p>Every chapter will also conclude with a link to the full code listing up to that
point. You can refer to it if you have any doubts about the structure of the
code, or if you're dealing with a bug and want to compare. All of the code files
have been tested on graphics cards from multiple vendors to verify correctness.
Each chapter also has a comment section at the end where you can ask any
questions that are relevant to the specific subject matter. Please specify your
platform, driver version, source code, expected behavior and actual behavior to
help us help you.</p>
<p>This tutorial is intended to be a community effort. Vulkan is still a very new
API and best practices have not really been established yet. If you have any
type of feedback on the tutorial and site itself, then please don't hesitate to
submit an issue or pull request to the <a href="https://github.com/Overv/VulkanTutorial">GitHub repository</a>.
You can <em>watch</em> the repository to be notified of updates to the tutorial.</p>
<p>After you've gone through the ritual of drawing your very first Vulkan powered
triangle onscreen, we'll start expanding the program to include linear
transformations, textures and 3D models.</p>
<p>If you've played with graphics APIs before, then you'll know that there can be a
lot of steps until the first geometry shows up on the screen. There are many of
these initial steps in Vulkan, but you'll see that each of the individual steps
is easy to understand and does not feel redundant. It's also important to keep
in mind that once you have that boring looking triangle, drawing fully textured
3D models does not take that much extra work, and each step beyond that point is
much more rewarding.</p>
<p>If you encounter any problems while following the tutorial, then first check the
FAQ to see if your problem and its solution is already listed there. If you are
still stuck after that, then feel free to ask for help in the comment section of
the closest related chapter.</p>
<p>Ready to dive into the future of high performance graphics APIs? <a href="!en/Overview">Let's go!</a></p>
<h1 id="2---overview">2 - Overview</h1>
<p>This chapter will start off with an introduction of Vulkan and the problems
it addresses. After that we're going to look at the ingredients that are
required for the first triangle. This will give you a big picture to place each
of the subsequent chapters in. We will conclude by covering the structure of the
Vulkan API and the general usage patterns.</p>
<h2 id="origin-of-vulkan">Origin of Vulkan</h2>
<p>Just like the previous graphics APIs, Vulkan is designed as a cross-platform
abstraction over <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">GPUs</a>.
The problem with most of these APIs is that the era in which they were designed
featured graphics hardware that was mostly limited to configurable fixed
functionality. Programmers had to provide the vertex data in a standard format
and were at the mercy of the GPU manufacturers with regards to lighting and
shading options.</p>
<p>As graphics card architectures matured, they started offering more and more
programmable functionality. All this new functionality had to be integrated with
the existing APIs somehow. This resulted in less than ideal abstractions and a
lot of guesswork on the graphics driver side to map the programmer's intent to
the modern graphics architectures. That's why there are so many driver updates
for improving the performance in games, sometimes by significant margins.
Because of the complexity of these drivers, application developers also need to
deal with inconsistencies between vendors, like the syntax that is accepted for
<a href="https://en.wikipedia.org/wiki/Shader">shaders</a>. Aside from these new features,
the past decade also saw an influx of mobile devices with powerful graphics
hardware. These mobile GPUs have different architectures based on their energy
and space requirements. One such example is <a href="https://en.wikipedia.org/wiki/Tiled_rendering">tiled rendering</a>,
which would benefit from improved performance by offering the programmer more
control over this functionality. Another limitation originating from the age of
these APIs is limited multi-threading support, which can result in a bottleneck
on the CPU side.</p>
<p>Vulkan solves these problems by being designed from scratch for modern graphics
architectures. It reduces driver overhead by allowing programmers to clearly
specify their intent using a more verbose API, and allows multiple threads to
create and submit commands in parallel. It reduces inconsistencies in shader
compilation by switching to a standardized byte code format with a single
compiler. Lastly, it acknowledges the general purpose processing capabilities of
modern graphics cards by unifying the graphics and compute functionality into a
single API.</p>
<h2 id="what-it-takes-to-draw-a-triangle">What it takes to draw a triangle</h2>
<p>We'll now look at an overview of all the steps it takes to render a triangle in
a well-behaved Vulkan program. All of the concepts introduced here will be
elaborated on in the next chapters. This is just to give you a big picture to
relate all of the individual components to.</p>
<h3 id="step-1---instance-and-physical-device-selection">Step 1 - Instance and physical device selection</h3>
<p>A Vulkan application starts by setting up the Vulkan API through a <code>VkInstance</code>.
An instance is created by describing your application and any API extensions you
will be using. After creating the instance, you can query for Vulkan supported
hardware and select one or more <code>VkPhysicalDevice</code>s to use for operations. You
can query for properties like VRAM size and device capabilities to select
desired devices, for example to prefer using dedicated graphics cards.</p>
<h3 id="step-2---logical-device-and-queue-families">Step 2 - Logical device and queue families</h3>
<p>After selecting the right hardware device to use, you need to create a VkDevice
(logical device), where you describe more specifically which
VkPhysicalDeviceFeatures you will be using, like multi viewport rendering and
64 bit floats. You also need to specify which queue families you would like to
use. Most operations performed with Vulkan, like draw commands and memory
operations, are asynchronously executed by submitting them to a VkQueue. Queues
are allocated from queue families, where each queue family supports a specific
set of operations in its queues. For example, there could be separate queue
families for graphics, compute and memory transfer operations. The availability
of queue families could also be used as a distinguishing factor in physical
device selection. It is possible for a device with Vulkan support to not offer
any graphics functionality, however all graphics cards with Vulkan support today
will generally support all queue operations that we're interested in.</p>
<h3 id="step-3---window-surface-and-swap-chain">Step 3 - Window surface and swap chain</h3>
<p>Unless you're only interested in offscreen rendering, you will need to create a
window to present rendered images to. Windows can be created with the native
platform APIs or libraries like <a href="http://www.glfw.org/">GLFW</a> and <a href="https://www.libsdl.org/">SDL</a>.
We will be using GLFW in this tutorial, but more about that in the next chapter.</p>
<p>We need two more components to actually render to a window: a window surface
(VkSurfaceKHR) and a swap chain (VkSwapchainKHR). Note the <code>KHR</code> postfix, which
means that these objects are part of a Vulkan extension. The Vulkan API itself
is completely platform agnostic, which is why we need to use the standardized
WSI (Window System Interface) extension to interact with the window manager. The
surface is a cross-platform abstraction over windows to render to and is
generally instantiated by providing a reference to the native window handle, for
example <code>HWND</code> on Windows. Luckily, the GLFW library has a built-in function to
deal with the platform specific details of this.</p>
<p>The swap chain is a collection of render targets. Its basic purpose is to ensure
that the image that we're currently rendering to is different from the one that
is currently on the screen. This is important to make sure that only complete
images are shown. Every time we want to draw a frame we have to ask the swap
chain to provide us with an image to render to. When we've finished drawing a
frame, the image is returned to the swap chain for it to be presented to the
screen at some point. The number of render targets and conditions for presenting
finished images to the screen depends on the present mode. Common present modes
are  double buffering (vsync) and triple buffering. We'll look into these in the
swap chain creation chapter.</p>
<p>Some platforms allow you to render directly to a display without interacting with any window manager through the <code>VK_KHR_display</code> and <code>VK_KHR_display_swapchain</code> extensions. These allow you to create a surface that represents the entire screen and could be used to implement your own window manager, for example.</p>
<h3 id="step-4---image-views-and-framebuffers">Step 4 - Image views and framebuffers</h3>
<p>To draw to an image acquired from the swap chain, we have to wrap it into a
VkImageView and VkFramebuffer. An image view references a specific part of an
image to be used, and a framebuffer references image views that are to be used
for color, depth and stencil targets. Because there could be many different
images in the swap chain, we'll preemptively create an image view and
framebuffer for each of them and select the right one at draw time.</p>
<h3 id="step-5---render-passes">Step 5 - Render passes</h3>
<p>Render passes in Vulkan describe the type of images that are used during
rendering operations, how they will be used, and how their contents should be
treated. In our initial triangle rendering application, we'll tell Vulkan that
we will use a single image as color target and that we want it to be cleared
to a solid color right before the drawing operation. Whereas a render pass only
describes the type of images, a VkFramebuffer actually binds specific images to
these slots.</p>
<h3 id="step-6---graphics-pipeline">Step 6 - Graphics pipeline</h3>
<p>The graphics pipeline in Vulkan is set up by creating a VkPipeline object. It
describes the configurable state of the graphics card, like the viewport size
and depth buffer operation and the programmable state using VkShaderModule
objects. The VkShaderModule objects are created from shader byte code. The
driver also needs to know which render targets will be used in the pipeline,
which we specify by referencing the render pass.</p>
<p>One of the most distinctive features of Vulkan compared to existing APIs, is
that almost all configuration of the graphics pipeline needs to be set in advance.
That means that if you want to switch to a different shader or slightly
change your vertex layout, then you need to entirely recreate the graphics
pipeline. That means that you will have to create many VkPipeline objects in
advance for all the different combinations you need for your rendering
operations. Only some basic configuration, like viewport size and clear color,
can be changed dynamically. All of the state also needs to be described
explicitly, there is no default color blend state, for example.</p>
<p>The good news is that because you're doing the equivalent of ahead-of-time
compilation versus just-in-time compilation, there are more optimization
opportunities for the driver and runtime performance is more predictable,
because large state changes like switching to a different graphics pipeline are
made very explicit.</p>
<h3 id="step-7---command-pools-and-command-buffers">Step 7 - Command pools and command buffers</h3>
<p>As mentioned earlier, many of the operations in Vulkan that we want to execute,
like drawing operations, need to be submitted to a queue. These operations first
need to be recorded into a VkCommandBuffer before they can be submitted. These
command buffers are allocated from a <code>VkCommandPool</code> that is associated with a
specific queue family. To draw a simple triangle, we need to record a command
buffer with the following operations:</p>
<ul>
<li>Begin the render pass</li>
<li>Bind the graphics pipeline</li>
<li>Draw 3 vertices</li>
<li>End the render pass</li>
</ul>
<p>Because the image in the framebuffer depends on which specific image the swap
chain will give us, we need to record a command buffer for each possible image
and select the right one at draw time. The alternative would be to record the
command buffer again every frame, which is not as efficient.</p>
<h3 id="step-8---main-loop">Step 8 - Main loop</h3>
<p>Now that the drawing commands have been wrapped into a command buffer, the main
loop is quite straightforward. We first acquire an image from the swap chain
with vkAcquireNextImageKHR. We can then select the appropriate command buffer
for that image and execute it with vkQueueSubmit. Finally, we return the image
to the swap chain for presentation to the screen with vkQueuePresentKHR.</p>
<p>Operations that are submitted to queues are executed asynchronously. Therefore
we have to use synchronization objects like semaphores to ensure a correct
order of execution. Execution of the draw command buffer must be set up to wait
on image acquisition to finish, otherwise it may occur that we start rendering
to an image that is still being read for presentation on the screen. The
vkQueuePresentKHR call in turn needs to wait for rendering to be finished, for
which we'll use a second semaphore that is signaled after rendering completes.</p>
<h3 id="summary">Summary</h3>
<p>This whirlwind tour should give you a basic understanding of the work ahead for
drawing the first triangle. A real-world program contains more steps, like
allocating vertex buffers, creating uniform buffers and uploading texture images
that will be covered in subsequent chapters, but we'll start simple because
Vulkan has enough of a steep learning curve as it is. Note that we'll cheat a
bit by initially embedding the vertex coordinates in the vertex shader instead
of using a vertex buffer. That's because managing vertex buffers requires some
familiarity with command buffers first.</p>
<p>So in short, to draw the first triangle we need to:</p>
<ul>
<li>Create a VkInstance</li>
<li>Select a supported graphics card (VkPhysicalDevice)</li>
<li>Create a VkDevice and VkQueue for drawing and presentation</li>
<li>Create a window, window surface and swap chain</li>
<li>Wrap the swap chain images into VkImageView</li>
<li>Create a render pass that specifies the render targets and usage</li>
<li>Create framebuffers for the render pass</li>
<li>Set up the graphics pipeline</li>
<li>Allocate and record a command buffer with the draw commands for every possible
swap chain image</li>
<li>Draw frames by acquiring images, submitting the right draw command buffer and
returning the images back to the swap chain</li>
</ul>
<p>It's a lot of steps, but the purpose of each individual step will be made very
simple and clear in the upcoming chapters. If you're confused about the relation
of a single step compared to the whole program, you should refer back to this
chapter.</p>
<h2 id="api-concepts">API concepts</h2>
<p>This chapter will conclude with a short overview of how the Vulkan API is
structured at a lower level.</p>
<h3 id="coding-conventions">Coding conventions</h3>
<p>All of the Vulkan functions, enumerations and structs are defined in the
<code>vulkan.h</code> header, which is included in the <a href="https://lunarg.com/vulkan-sdk/">Vulkan SDK</a>
developed by LunarG. We'll look into installing this SDK in the next chapter.</p>
<p>Functions have a lower case <code>vk</code> prefix, types like enumerations and structs
have a <code>Vk</code> prefix and enumeration values have a <code>VK_</code> prefix. The API heavily
uses structs to provide parameters to functions. For example, object creation
generally follows this pattern:</p>
<pre class="hljs"><code><div>VkXXXCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = <span class="hljs-literal">nullptr</span>;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
<span class="hljs-keyword">if</span> (vkCreateXXX(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;object) != VK_SUCCESS) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"failed to create object"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</div></code></pre>
<p>Many structures in Vulkan require you to explicitly specify the type of
structure in the <code>sType</code> member. The <code>pNext</code> member can point to an extension
structure and will always be <code>nullptr</code> in this tutorial. Functions that create
or destroy an object will have a VkAllocationCallbacks parameter that allows you
to use a custom allocator for driver memory, which will also be left <code>nullptr</code>
in this tutorial.</p>
<p>Almost all functions return a VkResult that is either <code>VK_SUCCESS</code> or an error
code. The specification describes which error codes each function can return and
what they mean.</p>
<h3 id="validation-layers">Validation layers</h3>
<p>As mentioned earlier, Vulkan is designed for high performance and low driver
overhead. Therefore it will include very limited error checking and debugging
capabilities by default. The driver will often crash instead of returning an
error code if you do something wrong, or worse, it will appear to work on your
graphics card and completely fail on others.</p>
<p>Vulkan allows you to enable extensive checks through a feature known as
<em>validation layers</em>. Validation layers are pieces of code that can be inserted
between the API and the graphics driver to do things like running extra checks
on function parameters and tracking memory management problems. The nice thing
is that you can enable them during development and then completely disable them
when releasing your application for zero overhead. Anyone can write their own
validation layers, but the Vulkan SDK by LunarG provides a standard set of
validation layers that we'll be using in this tutorial. You also need to
register a callback function to receive debug messages from the layers.</p>
<p>Because Vulkan is so explicit about every operation and the validation layers
are so extensive, it can actually be a lot easier to find out why your screen is
black compared to OpenGL and Direct3D!</p>
<p>There's only one more step before we'll start writing code and that's <a href="!en/Development_environment">setting
up the development environment</a>.</p>
<h1 id="3---development-environment">3 - Development environment</h1>
<p>In this chapter we'll set up your environment for developing Vulkan applications
and install some useful libraries. All of the tools we'll use, with the
exception of the compiler, are compatible with Windows, Linux and MacOS, but the
steps for installing them differ a bit, which is why they're described
separately here.</p>
<h2 id="windows">Windows</h2>
<p>If you're developing for Windows, then I will assume that you are using Visual
Studio to compile your code. For complete C++17 support, you need to use either
Visual Studio 2017 or 2019. The steps outlined below were written for VS 2017.</p>
<h3 id="vulkan-sdk">Vulkan SDK</h3>
<p>The most important component you'll need for developing Vulkan applications is
the SDK. It includes the headers, standard validation layers, debugging tools
and a loader for the Vulkan functions. The loader looks up the functions in the
driver at runtime, similarly to GLEW for OpenGL - if you're familiar with that.</p>
<p>The SDK can be downloaded from <a href="https://vulkan.lunarg.com/">the LunarG website</a>
using the buttons at the bottom of the page. You don't have to create an
account, but it will give you access to some additional documentation that may
be useful to you.</p>
<p><img src="images/vulkan_sdk_download_buttons.png" alt=""></p>
<p>Proceed through the installation and pay attention to the install location of
the SDK. The first thing we'll do is verify that your graphics card and driver
properly support Vulkan. Go to the directory where you installed the SDK, open
the <code>Bin</code> directory and run the <code>vkcube.exe</code> demo. You should see the following:</p>
<p><img src="images/cube_demo.png" alt=""></p>
<p>If you receive an error message then ensure that your drivers are up-to-date,
include the Vulkan runtime and that your graphics card is supported. See the
<a href="!en/Introduction">introduction chapter</a> for links to drivers from the major
vendors.</p>
<p>There is another program in this directory that will be useful for development. The <code>glslangValidator.exe</code> and <code>glslc.exe</code> programs will be used to compile shaders from the
human-readable <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a> to
bytecode. We'll cover this in depth in the <a href="!en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">shader modules</a>
chapter. The <code>Bin</code> directory also contains the binaries of the Vulkan loader
and the validation layers, while the <code>Lib</code> directory contains the libraries.</p>
<p>Lastly, there's the <code>Include</code> directory that contains the Vulkan headers. Feel free to explore the other files, but we won't need them for this tutorial.</p>
<h3 id="glfw">GLFW</h3>
<p>As mentioned before, Vulkan by itself is a platform agnostic API and does not
include tools for creating a window to display the rendered results. To benefit
from the cross-platform advantages of Vulkan and to avoid the horrors of Win32,
we'll use the <a href="http://www.glfw.org/">GLFW library</a> to create a window, which
supports Windows, Linux and MacOS. There are other libraries available for this
purpose, like <a href="https://www.libsdl.org/">SDL</a>, but the advantage of GLFW is that
it also abstracts away some of the other platform-specific things in Vulkan
besides just window creation.</p>
<p>You can find the latest release of GLFW on the <a href="http://www.glfw.org/download.html">official website</a>.
In this tutorial we'll be using the 64-bit binaries, but you can of course also
choose to build in 32 bit mode. In that case make sure to link with the Vulkan
SDK binaries in the <code>Lib32</code> directory instead of <code>Lib</code>. After downloading it, extract the archive
to a convenient location. I've chosen to create a <code>Libraries</code> directory in the
Visual Studio directory under documents.</p>
<p><img src="images/glfw_directory.png" alt=""></p>
<h3 id="glm">GLM</h3>
<p>Unlike DirectX 12, Vulkan does not include a library for linear algebra
operations, so we'll have to download one. <a href="http://glm.g-truc.net/">GLM</a> is a
nice library that is designed for use with graphics APIs and is also commonly
used with OpenGL.</p>
<p>GLM is a header-only library, so just download the <a href="https://github.com/g-truc/glm/releases">latest version</a>
and store it in a convenient location. You should have a directory structure
similar to the following now:</p>
<p><img src="images/library_directory.png" alt=""></p>
<h3 id="setting-up-visual-studio">Setting up Visual Studio</h3>
<p>Now that you've installed all of the dependencies we can set up a basic Visual
Studio project for Vulkan and write a little bit of code to make sure that
everything works.</p>
<p>Start Visual Studio and create a new <code>Windows Desktop Wizard</code> project by entering a name and pressing <code>OK</code>.</p>
<p><img src="images/vs_new_cpp_project.png" alt=""></p>
<p>Make sure that <code>Console Application (.exe)</code> is selected as application type so that we have a place to print debug messages to, and check <code>Empty Project</code> to prevent Visual Studio from adding boilerplate code.</p>
<p><img src="images/vs_application_settings.png" alt=""></p>
<p>Press <code>OK</code> to create the project and add a C++ source file. You should
already know how to do that, but the steps are included here for completeness.</p>
<p><img src="images/vs_new_item.png" alt=""></p>
<p><img src="images/vs_new_source_file.png" alt=""></p>
<p>Now add the following code to the file. Don't worry about trying to
understand it right now; we're just making sure that you can compile and run
Vulkan applications. We'll start from scratch in the next chapter.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLFW_INCLUDE_VULKAN</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_RADIANS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_DEPTH_ZERO_TO_ONE</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/vec4.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/mat4x4.hpp&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    glfwInit();

    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    GLFWwindow* window = glfwCreateWindow(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">"Vulkan window"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);

    <span class="hljs-keyword">uint32_t</span> extensionCount = <span class="hljs-number">0</span>;
    vkEnumerateInstanceExtensionProperties(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; extensionCount &lt;&lt; <span class="hljs-string">" extensions supported\n"</span>;

    glm::mat4 matrix;
    glm::vec4 vec;
    <span class="hljs-keyword">auto</span> test = matrix * vec;

    <span class="hljs-keyword">while</span>(!glfwWindowShouldClose(window)) {
        glfwPollEvents();
    }

    glfwDestroyWindow(window);

    glfwTerminate();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>Let's now configure the project to get rid of the errors. Open the project
properties dialog and ensure that <code>All Configurations</code> is selected, because most
of the settings apply to both <code>Debug</code> and <code>Release</code> mode.</p>
<p><img src="images/vs_open_project_properties.png" alt=""></p>
<p><img src="images/vs_all_configs.png" alt=""></p>
<p>Go to <code>C++ -&gt; General -&gt; Additional Include Directories</code> and press <code>&lt;Edit...&gt;</code>
in the dropdown box.</p>
<p><img src="images/vs_cpp_general.png" alt=""></p>
<p>Add the header directories for Vulkan, GLFW and GLM:</p>
<p><img src="images/vs_include_dirs.png" alt=""></p>
<p>Next, open the editor for library directories under <code>Linker -&gt; General</code>:</p>
<p><img src="images/vs_link_settings.png" alt=""></p>
<p>And add the locations of the object files for Vulkan and GLFW:</p>
<p><img src="images/vs_link_dirs.png" alt=""></p>
<p>Go to <code>Linker -&gt; Input</code> and press <code>&lt;Edit...&gt;</code> in the <code>Additional Dependencies</code>
dropdown box.</p>
<p><img src="images/vs_link_input.png" alt=""></p>
<p>Enter the names of the Vulkan and GLFW object files:</p>
<p><img src="images/vs_dependencies.png" alt=""></p>
<p>And finally change the compiler to support C++17 features:</p>
<p><img src="images/vs_cpp17.png" alt=""></p>
<p>You can now close the project properties dialog. If you did everything right
then you should no longer see any more errors being highlighted in the code.</p>
<p>Finally, ensure that you are actually compiling in 64 bit mode:</p>
<p><img src="images/vs_build_mode.png" alt=""></p>
<p>Press <code>F5</code> to compile and run the project and you should see a command prompt
and a window pop up like this:</p>
<p><img src="images/vs_test_window.png" alt=""></p>
<p>The number of extensions should be non-zero. Congratulations, you're all set for
<a href="!en/Drawing_a_triangle/Setup/Base_code">playing with Vulkan</a>!</p>
<h2 id="linux">Linux</h2>
<p>These instructions will be aimed at Ubuntu, Fedora and Arch Linux users, but you may be able to follow
along by changing the package manager-specific commands to the ones that are appropriate for you. You should have a compiler that supports C++17 (GCC 7+ or Clang 5+). You'll also need <code>make</code>.</p>
<h3 id="vulkan-packages">Vulkan Packages</h3>
<p>The most important components you'll need for developing Vulkan applications on Linux are the Vulkan loader, validation layers, and a couple of command-line utilities to test whether your machine is Vulkan-capable:</p>
<ul>
<li><code>sudo apt install vulkan-tools</code> or <code>sudo dnf install vulkan-tools</code>: Command-line utilities, most importantly <code>vulkaninfo</code> and <code>vkcube</code>. Run these to confirm your machine supports Vulkan.</li>
<li><code>sudo apt install libvulkan-dev</code> or <code>sudo dnf install vulkan-loader-devel</code> : Installs Vulkan loader. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you're familiar with that.</li>
<li><code>sudo apt install vulkan-validationlayers-dev spirv-tools</code> or <code>sudo dnf install mesa-vulkan-devel vulkan-validation-layers-devel</code>: Installs the standard validation layers and required SPIR-V tools. These are crucial when debugging Vulkan applications, and we'll discuss them in the upcoming chapter.</li>
</ul>
<p>On Arch Linux, you can run <code>sudo pacman -S vulkan-devel</code> to install all the
required tools above.</p>
<p>If installation was successful, you should be all set with the Vulkan portion. Remember to run
<code>vkcube</code> and ensure you see the following pop up in a window:</p>
<p><img src="images/cube_demo_nowindow.png" alt=""></p>
<p>If you receive an error message then ensure that your drivers are up-to-date,
include the Vulkan runtime and that your graphics card is supported. See the
<a href="!en/Introduction">introduction chapter</a> for links to drivers from the major
vendors.</p>
<h3 id="glfw">GLFW</h3>
<p>As mentioned before, Vulkan by itself is a platform agnostic API and does not
include tools for creation a window to display the rendered results. To benefit
from the cross-platform advantages of Vulkan and to avoid the horrors of X11,
we'll use the <a href="http://www.glfw.org/">GLFW library</a> to create a window, which
supports Windows, Linux and MacOS. There are other libraries available for this
purpose, like <a href="https://www.libsdl.org/">SDL</a>, but the advantage of GLFW is that
it also abstracts away some of the other platform-specific things in Vulkan
besides just window creation.</p>
<p>We'll be installing GLFW from the following command:</p>
<pre class="hljs"><code><div>sudo apt install libglfw3-dev
</div></code></pre>
<p>or</p>
<pre class="hljs"><code><div>sudo dnf install glfw-devel
</div></code></pre>
<p>or</p>
<pre class="hljs"><code><div>sudo pacman -S glfw-wayland <span class="hljs-comment"># glfw-x11 for X11 users</span>
</div></code></pre>
<h3 id="glm">GLM</h3>
<p>Unlike DirectX 12, Vulkan does not include a library for linear algebra
operations, so we'll have to download one. <a href="http://glm.g-truc.net/">GLM</a> is a
nice library that is designed for use with graphics APIs and is also commonly
used with OpenGL.</p>
<p>It is a header-only library that can be installed from the <code>libglm-dev</code> or
<code>glm-devel</code> package:</p>
<pre class="hljs"><code><div>sudo apt install libglm-dev
</div></code></pre>
<p>or</p>
<pre class="hljs"><code><div>sudo dnf install glm-devel
</div></code></pre>
<p>or</p>
<pre class="hljs"><code><div>sudo pacman -S glm
</div></code></pre>
<h3 id="shader-compiler">Shader Compiler</h3>
<p>We have just about all we need, except we'll want a program to compile shaders from the human-readable  <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a> to bytecode.</p>
<p>Two popular shader compilers are Khronos Group's <code>glslangValidator</code> and Google's <code>glslc</code>. The latter has a familiar GCC- and Clang-like usage, so we'll go with that: on Ubuntu, download Google's <a href="https://github.com/google/shaderc/blob/main/downloads.md">unofficial binaries</a> and copy <code>glslc</code> to your <code>/usr/local/bin</code>. Note you may need to <code>sudo</code> depending on your permissions. On Fedora use <code>sudo dnf install glslc</code>, while on Arch Linux run <code>sudo pacman -S shaderc</code>.  To test, run <code>glslc</code> and it should rightfully complain we didn't pass any shaders to compile:</p>
<p><code>glslc: error: no input files</code></p>
<p>We'll cover <code>glslc</code> in depth in the <a href="!en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">shader modules</a> chapter.</p>
<h3 id="setting-up-a-makefile-project">Setting up a makefile project</h3>
<p>Now that you have installed all of the dependencies, we can set up a basic
makefile project for Vulkan and write a little bit of code to make sure that
everything works.</p>
<p>Create a new directory at a convenient location with a name like <code>VulkanTest</code>.
Create a source file called <code>main.cpp</code> and insert the following code. Don't
worry about trying to understand it right now; we're just making sure that you
can compile and run Vulkan applications. We'll start from scratch in the next
chapter.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLFW_INCLUDE_VULKAN</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_RADIANS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_DEPTH_ZERO_TO_ONE</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/vec4.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/mat4x4.hpp&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    glfwInit();

    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    GLFWwindow* window = glfwCreateWindow(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">"Vulkan window"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);

    <span class="hljs-keyword">uint32_t</span> extensionCount = <span class="hljs-number">0</span>;
    vkEnumerateInstanceExtensionProperties(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; extensionCount &lt;&lt; <span class="hljs-string">" extensions supported\n"</span>;

    glm::mat4 matrix;
    glm::vec4 vec;
    <span class="hljs-keyword">auto</span> test = matrix * vec;

    <span class="hljs-keyword">while</span>(!glfwWindowShouldClose(window)) {
        glfwPollEvents();
    }

    glfwDestroyWindow(window);

    glfwTerminate();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>Next, we'll write a makefile to compile and run this basic Vulkan code. Create a
new empty file called <code>Makefile</code>. I will assume that you already have some basic
experience with makefiles, like how variables and rules work. If not, you can
get up to speed very quickly with <a href="https://makefiletutorial.com/">this tutorial</a>.</p>
<p>We'll first define a couple of variables to simplify the remainder of the file.
Define a <code>CFLAGS</code> variable that will specify the basic compiler flags:</p>
<pre class="hljs"><code><div>CFLAGS = -std=c++17 -O2
</div></code></pre>
<p>We're going to use modern C++ (<code>-std=c++17</code>), and we'll set optimization level to O2. We can remove -O2 to compile programs faster, but we should remember to place it back for release builds.</p>
<p>Similarly, define the linker flags in a <code>LDFLAGS</code> variable:</p>
<pre class="hljs"><code><div>LDFLAGS = -lglfw -lvulkan -ldl -lpthread -lX11 -lXxf86vm -lXrandr -lXi
</div></code></pre>
<p>The flag <code>-lglfw</code> is for GLFW, <code>-lvulkan</code> links with the Vulkan function loader and the remaining flags are low-level system libraries that GLFW needs. The remaining flags are dependencies of GLFW itself: the threading and window management.</p>
<p>It is possible that the <code>Xxf68vm</code> and <code>Xi</code> libraries are not yet installed on your system. You can find them in the following packages:</p>
<pre class="hljs"><code><div>sudo apt install libxxf86vm-dev libxi-dev
</div></code></pre>
<p>or</p>
<pre class="hljs"><code><div>sudo dnf install libXi libXxf86vm
</div></code></pre>
<p>or</p>
<pre class="hljs"><code><div>sudo pacman -S libxi libxxf86vm
</div></code></pre>
<p>Specifying the rule to compile <code>VulkanTest</code> is straightforward now. Make sure to
use tabs for indentation instead of spaces.</p>
<pre class="hljs"><code><div>VulkanTest: main.cpp
    g++ $(CFLAGS) -o VulkanTest main.cpp $(LDFLAGS)
</div></code></pre>
<p>Verify that this rule works by saving the makefile and running <code>make</code> in the
directory with <code>main.cpp</code> and <code>Makefile</code>. This should result in a <code>VulkanTest</code>
executable.</p>
<p>We'll now define two more rules, <code>test</code> and <code>clean</code>, where the former will
run the executable and the latter will remove a built executable:</p>
<pre class="hljs"><code><div>.PHONY: test clean

test: VulkanTest
    ./VulkanTest

clean:
    rm -f VulkanTest
</div></code></pre>
<p>Running <code>make test</code> should show the program running successfully, and displaying the number of Vulkan extensions. The application should exit with the success return code (<code>0</code>) when you close the empty window. You should now have a complete makefile that resembles the following:</p>
<pre class="hljs"><code><div>CFLAGS = -std=c++17 -O2
LDFLAGS = -lglfw -lvulkan -ldl -lpthread -lX11 -lXxf86vm -lXrandr -lXi

VulkanTest: main.cpp
    g++ $(CFLAGS) -o VulkanTest main.cpp $(LDFLAGS)

.PHONY: test clean

test: VulkanTest
	./VulkanTest

clean:
    rm -f VulkanTest
</div></code></pre>
<p>You can now use this directory as a template for your Vulkan projects. Make a copy, rename it to something like <code>HelloTriangle</code> and remove all of the code in <code>main.cpp</code>.</p>
<p>You are now all set for <a href="!en/Drawing_a_triangle/Setup/Base_code">the real adventure</a>.</p>
<h2 id="macos">MacOS</h2>
<p>These instructions will assume you are using Xcode and the <a href="https://brew.sh/">Homebrew package manager</a>. Also, keep in mind that you will need at least MacOS version 10.11, and your device needs to support the <a href="https://en.wikipedia.org/wiki/Metal_(API)#Supported_GPUs">Metal API</a>.</p>
<h3 id="vulkan-sdk">Vulkan SDK</h3>
<p>The most important component you'll need for developing Vulkan applications is the SDK. It includes the headers, standard validation layers, debugging tools and a loader for the Vulkan functions. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you're familiar with that.</p>
<p>The SDK can be downloaded from <a href="https://vulkan.lunarg.com/">the LunarG website</a> using the buttons at the bottom of the page. You don't have to create an account, but it will give you access to some additional documentation that may be useful to you.</p>
<p><img src="images/vulkan_sdk_download_buttons.png" alt=""></p>
<p>The SDK version for MacOS internally uses <a href="https://moltengl.com/">MoltenVK</a>. There is no native support for Vulkan on MacOS, so what MoltenVK does is actually act as a layer that translates Vulkan API calls to Apple's Metal graphics framework. With this you can take advantage of debugging and performance benefits of Apple's Metal framework.</p>
<p>After downloading it, simply extract the contents to a folder of your choice (keep in mind you will need to reference it when creating your projects on Xcode). Inside the extracted folder, in the <code>Applications</code> folder you should have some executable files that will run a few demos using the SDK. Run the <code>vkcube</code> executable and you will see the following:</p>
<p><img src="images/cube_demo_mac.png" alt=""></p>
<h3 id="glfw">GLFW</h3>
<p>As mentioned before, Vulkan by itself is a platform agnostic API and does not include tools for creation a window to display the rendered results. We'll use the <a href="http://www.glfw.org/">GLFW library</a> to create a window, which supports Windows, Linux and MacOS. There are other libraries available for this purpose, like <a href="https://www.libsdl.org/">SDL</a>, but the advantage of GLFW is that it also abstracts away some of the other platform-specific things in Vulkan besides just window creation.</p>
<p>To install GLFW on MacOS we will use the Homebrew package manager to get the <code>glfw</code> package:</p>
<pre class="hljs"><code><div>brew install glfw
</div></code></pre>
<h3 id="glm">GLM</h3>
<p>Vulkan does not include a library for linear algebra operations, so we'll have to download one. <a href="http://glm.g-truc.net/">GLM</a> is a nice library that is designed for use with graphics APIs and is also commonly used with OpenGL.</p>
<p>It is a header-only library that can be installed from the <code>glm</code> package:</p>
<pre class="hljs"><code><div>brew install glm
</div></code></pre>
<h3 id="setting-up-xcode">Setting up Xcode</h3>
<p>Now that all the dependencies are installed we can set up a basic Xcode project for Vulkan. Most of the instructions here are essentially a lot of &quot;plumbing&quot; so we can get all the dependencies linked to the project. Also, keep in mind that during the following instructions whenever we mention the folder <code>vulkansdk</code> we are refering to the folder where you extracted the Vulkan SDK.</p>
<p>Start Xcode and create a new Xcode project. On the window that will open select Application &gt; Command Line Tool.</p>
<p><img src="images/xcode_new_project.png" alt=""></p>
<p>Select <code>Next</code>, write a name for the project and for <code>Language</code> select <code>C++</code>.</p>
<p><img src="images/xcode_new_project_2.png" alt=""></p>
<p>Press <code>Next</code> and the project should have been created. Now, let's change the code in the generated <code>main.cpp</code> file to the following code:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLFW_INCLUDE_VULKAN</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_RADIANS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_DEPTH_ZERO_TO_ONE</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/vec4.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/mat4x4.hpp&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    glfwInit();

    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    GLFWwindow* window = glfwCreateWindow(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">"Vulkan window"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);

    <span class="hljs-keyword">uint32_t</span> extensionCount = <span class="hljs-number">0</span>;
    vkEnumerateInstanceExtensionProperties(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; extensionCount &lt;&lt; <span class="hljs-string">" extensions supported\n"</span>;

    glm::mat4 matrix;
    glm::vec4 vec;
    <span class="hljs-keyword">auto</span> test = matrix * vec;

    <span class="hljs-keyword">while</span>(!glfwWindowShouldClose(window)) {
        glfwPollEvents();
    }

    glfwDestroyWindow(window);

    glfwTerminate();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>Keep in mind you are not required to understand all this code is doing yet, we are just setting up some API calls to make sure everything is working.</p>
<p>Xcode should already be showing some errors such as libraries it cannot find. We will now start configuring the project to get rid of those errors. On the <em>Project Navigator</em> panel select your project. Open the <em>Build Settings</em> tab and then:</p>
<ul>
<li>Find the <strong>Header Search Paths</strong> field and add a link to <code>/usr/local/include</code> (this is where Homebrew installs headers, so the glm and glfw3 header files should be there) and a link to <code>vulkansdk/macOS/include</code> for the Vulkan headers.</li>
<li>Find the <strong>Library Search Paths</strong> field and add a link to <code>/usr/local/lib</code> (again, this is where Homebrew installs libraries, so the glm and glfw3 lib files should be there) and a link to <code>vulkansdk/macOS/lib</code>.</li>
</ul>
<p>It should look like so (obviously, paths will be different depending on where you placed on your files):</p>
<p><img src="images/xcode_paths.png" alt=""></p>
<p>Now, in the <em>Build Phases</em> tab, on <strong>Link Binary With Libraries</strong> we will add both the <code>glfw3</code> and the <code>vulkan</code> frameworks. To make things easier we will be adding the dynamic libraries in the project (you can check the documentation of these libraries if you want to use the static frameworks).</p>
<ul>
<li>For glfw open the folder <code>/usr/local/lib</code> and there you will find a file name like <code>libglfw.3.x.dylib</code> (&quot;x&quot; is the library's version number, it might be different depending on when you downloaded the package from Homebrew). Simply drag that file to the Linked Frameworks and Libraries tab on Xcode.</li>
<li>For vulkan, go to <code>vulkansdk/macOS/lib</code>. Do the same for the both files <code>libvulkan.1.dylib</code> and <code>libvulkan.1.x.xx.dylib</code> (where &quot;x&quot; will be the version number of the the SDK you downloaded).</li>
</ul>
<p>After adding those libraries, in the same tab on <strong>Copy Files</strong> change <code>Destination</code> to &quot;Frameworks&quot;, clear the subpath and deselect &quot;Copy only when installing&quot;. Click on the &quot;+&quot; sign and add all those three frameworks here aswell.</p>
<p>Your Xcode configuration should look like:</p>
<p><img src="images/xcode_frameworks.png" alt=""></p>
<p>The last thing you need to setup are a couple of environment variables. On Xcode toolbar go to <code>Product</code> &gt; <code>Scheme</code> &gt; <code>Edit Scheme...</code>, and in the <code>Arguments</code> tab add the two following environment variables:</p>
<ul>
<li>VK_ICD_FILENAMES = <code>vulkansdk/macOS/share/vulkan/icd.d/MoltenVK_icd.json</code></li>
<li>VK_LAYER_PATH = <code>vulkansdk/macOS/share/vulkan/explicit_layer.d</code></li>
</ul>
<p>It should look like so:</p>
<p><img src="images/xcode_variables.png" alt=""></p>
<p>Finally, you should be all set! Now if you run the project (remembering to setting the build configuration to Debug or Release depending on the configuration you chose) you should see the following:</p>
<p><img src="images/xcode_output.png" alt=""></p>
<p>The number of extensions should be non-zero. The other logs are from the libraries, you might get different messages from those depending on your configuration.</p>
<p>You are now all set for <a href="!en/Drawing_a_triangle/Setup/Base_code">the real thing</a>.</p>
<h1 id="4---drawing-a-triangle">4 - Drawing a triangle</h1>
<h2 id="1-setup">1. Setup</h2>
<h3 id="00basecode">00_Base_code</h3>
<h4 id="general-structure">General structure</h4>
<p>In the previous chapter you've created a Vulkan project with all of the proper
configuration and tested it with the sample code. In this chapter we're starting
from scratch with the following code:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vulkan/vulkan.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdexcept&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloTriangleApplication</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        initVulkan();
        mainLoop();
        cleanup();
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{

    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    HelloTriangleApplication app;

    <span class="hljs-keyword">try</span> {
        app.<span class="hljs-built_in">run</span>();
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::exception&amp; e) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> EXIT_FAILURE;
    }

    <span class="hljs-keyword">return</span> EXIT_SUCCESS;
}
</div></code></pre>
<p>We first include the Vulkan header from the LunarG SDK, which provides the
functions, structures and enumerations. The <code>stdexcept</code> and <code>iostream</code> headers
are included for reporting and propagating errors. The <code>cstdlib</code>
header provides the <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> macros.</p>
<p>The program itself is wrapped into a class where we'll store the Vulkan objects
as private class members and add functions to initiate each of them, which will
be called from the <code>initVulkan</code> function. Once everything has been prepared, we
enter the main loop to start rendering frames. We'll fill in the <code>mainLoop</code>
function to include a loop that iterates until the window is closed in a moment.
Once the window is closed and <code>mainLoop</code> returns, we'll make sure to deallocate
the resources we've used in the <code>cleanup</code> function.</p>
<p>If any kind of fatal error occurs during execution then we'll throw a
<code>std::runtime_error</code> exception with a descriptive message, which will propagate
back to the <code>main</code> function and be printed to the command prompt. To handle
a variety of standard exception types as well, we catch the more general <code>std::exception</code>. One example of an error that we will deal with soon is finding
out that a certain required extension is not supported.</p>
<p>Roughly every chapter that follows after this one will add one new function that
will be called from <code>initVulkan</code> and one or more new Vulkan objects to the
private class members that need to be freed at the end in <code>cleanup</code>.</p>
<h4 id="resource-management">Resource management</h4>
<p>Just like each chunk of memory allocated with <code>malloc</code> requires a call to
<code>free</code>, every Vulkan object that we create needs to be explicitly destroyed when
we no longer need it. In C++ it is possible to perform automatic resource
management using <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>
or smart pointers provided in the <code>&lt;memory&gt;</code> header. However, I've chosen to be
explicit about allocation and deallocation of Vulkan objects in this tutorial.
After all, Vulkan's niche is to be explicit about every operation to avoid
mistakes, so it's good to be explicit about the lifetime of objects to learn how
the API works.</p>
<p>After following this tutorial, you could implement automatic resource management
by writing C++ classes that acquire Vulkan objects in their constructor and
release them in their destructor, or by providing a custom deleter to either
<code>std::unique_ptr</code> or <code>std::shared_ptr</code>, depending on your ownership requirements.
RAII is the recommended model for larger Vulkan programs, but
for learning purposes it's always good to know what's going on behind the
scenes.</p>
<p>Vulkan objects are either created directly with functions like <code>vkCreateXXX</code>, or
allocated through another object with functions like <code>vkAllocateXXX</code>. After
making sure that an object is no longer used anywhere, you need to destroy it
with the counterparts <code>vkDestroyXXX</code> and <code>vkFreeXXX</code>. The parameters for these
functions generally vary for different types of objects, but there is one
parameter that they all share: <code>pAllocator</code>. This is an optional parameter that
allows you to specify callbacks for a custom memory allocator. We will ignore
this parameter in the tutorial and always pass <code>nullptr</code> as argument.</p>
<h4 id="integrating-glfw">Integrating GLFW</h4>
<p>Vulkan works perfectly fine without creating a window if you want to use it for
off-screen rendering, but it's a lot more exciting to actually show something!
First replace the <code>#include &lt;vulkan/vulkan.h&gt;</code> line with</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLFW_INCLUDE_VULKAN</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span>
</div></code></pre>
<p>That way GLFW will include its own definitions and automatically load the Vulkan
header with it. Add a <code>initWindow</code> function and add a call to it from the <code>run</code>
function before the other calls. We'll use that function to initialize GLFW and
create a window.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
    initWindow();
    initVulkan();
    mainLoop();
    cleanup();
}

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initWindow</span><span class="hljs-params">()</span> </span>{

    }
</div></code></pre>
<p>The very first call in <code>initWindow</code> should be <code>glfwInit()</code>, which initializes
the GLFW library. Because GLFW was originally designed to create an OpenGL
context, we need to tell it to not create an OpenGL context with a subsequent
call:</p>
<pre class="hljs"><code><div>glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
</div></code></pre>
<p>Because handling resized windows takes special care that we'll look into later,
disable it for now with another window hint call:</p>
<pre class="hljs"><code><div>glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
</div></code></pre>
<p>All that's left now is creating the actual window. Add a <code>GLFWwindow* window;</code>
private class member to store a reference to it and initialize the window with:</p>
<pre class="hljs"><code><div>window = glfwCreateWindow(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">"Vulkan"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<p>The first three parameters specify the width, height and title of the window.
The fourth parameter allows you to optionally specify a monitor to open the
window on and the last parameter is only relevant to OpenGL.</p>
<p>It's a good idea to use constants instead of hardcoded width and height numbers
because we'll be referring to these values a couple of times in the future. I've
added the following lines above the <code>HelloTriangleApplication</code> class definition:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> WIDTH = <span class="hljs-number">800</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> HEIGHT = <span class="hljs-number">600</span>;
</div></code></pre>
<p>and replaced the window creation call with</p>
<pre class="hljs"><code><div>window = glfwCreateWindow(WIDTH, HEIGHT, <span class="hljs-string">"Vulkan"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<p>You should now have a <code>initWindow</code> function that looks like this:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initWindow</span><span class="hljs-params">()</span> </span>{
    glfwInit();

    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

    window = glfwCreateWindow(WIDTH, HEIGHT, <span class="hljs-string">"Vulkan"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
}
</div></code></pre>
<p>To keep the application running until either an error occurs or the window is
closed, we need to add an event loop to the <code>mainLoop</code> function as follows:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
    }
}
</div></code></pre>
<p>This code should be fairly self-explanatory. It loops and checks for events like
pressing the X button until the window has been closed by the user. This is also
the loop where we'll later call a function to render a single frame.</p>
<p>Once the window is closed, we need to clean up resources by destroying it and
terminating GLFW itself. This will be our first <code>cleanup</code> code:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    glfwDestroyWindow(window);

    glfwTerminate();
}
</div></code></pre>
<p>When you run the program now you should see a window titled <code>Vulkan</code> show up
until the application is terminated by closing the window. Now that we have the
skeleton for the Vulkan application, let's <a href="!en/Drawing_a_triangle/Setup/Instance">create the first Vulkan object</a>!</p>
<p><a href="/code/00_base_code.cpp">C++ code</a></p>
<h3 id="01instance">01_Instance</h3>
<h4 id="creating-an-instance">Creating an instance</h4>
<p>The very first thing you need to do is initialize the Vulkan library by creating
an <em>instance</em>. The instance is the connection between your application and the
Vulkan library and creating it involves specifying some details about your
application to the driver.</p>
<p>Start by adding a <code>createInstance</code> function and invoking it in the
<code>initVulkan</code> function.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
}
</div></code></pre>
<p>Additionally add a data member to hold the handle to the instance:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span>:
VkInstance instance;
</div></code></pre>
<p>Now, to create an instance we'll first have to fill in a struct with some
information about our application. This data is technically optional, but it may
provide some useful information to the driver in order to optimize our specific
application (e.g. because it uses a well-known graphics engine with
certain special behavior). This struct is called <code>VkApplicationInfo</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>{
    VkApplicationInfo appInfo{};
    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    appInfo.pApplicationName = <span class="hljs-string">"Hello Triangle"</span>;
    appInfo.applicationVersion = VK_MAKE_VERSION(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    appInfo.pEngineName = <span class="hljs-string">"No Engine"</span>;
    appInfo.engineVersion = VK_MAKE_VERSION(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    appInfo.apiVersion = VK_API_VERSION_1_0;
}
</div></code></pre>
<p>As mentioned before, many structs in Vulkan require you to explicitly specify
the type in the <code>sType</code> member. This is also one of the many structs with a
<code>pNext</code> member that can point to extension information in the future. We're
using value initialization here to leave it as <code>nullptr</code>.</p>
<p>A lot of information in Vulkan is passed through structs instead of function
parameters and we'll have to fill in one more struct to provide sufficient
information for creating an instance. This next struct is not optional and tells
the Vulkan driver which global extensions and validation layers we want to use.
Global here means that they apply to the entire program and not a specific
device, which will become clear in the next few chapters.</p>
<pre class="hljs"><code><div>VkInstanceCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
createInfo.pApplicationInfo = &amp;appInfo;
</div></code></pre>
<p>The first two parameters are straightforward. The next two layers specify the
desired global extensions. As mentioned in the overview chapter, Vulkan is a
platform agnostic API, which means that you need an extension to interface with
the window system. GLFW has a handy built-in function that returns the
extension(s) it needs to do that which we can pass to the struct:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>** glfwExtensions;

glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);

createInfo.enabledExtensionCount = glfwExtensionCount;
createInfo.ppEnabledExtensionNames = glfwExtensions;
</div></code></pre>
<p>The last two members of the struct determine the global validation layers to
enable. We'll talk about these more in-depth in the next chapter, so just leave
these empty for now.</p>
<pre class="hljs"><code><div>createInfo.enabledLayerCount = <span class="hljs-number">0</span>;
</div></code></pre>
<p>We've now specified everything Vulkan needs to create an instance and we can
finally issue the <code>vkCreateInstance</code> call:</p>
<pre class="hljs"><code><div>VkResult result = vkCreateInstance(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance);
</div></code></pre>
<p>As you'll see, the general pattern that object creation function parameters in
Vulkan follow is:</p>
<ul>
<li>Pointer to struct with creation info</li>
<li>Pointer to custom allocator callbacks, always <code>nullptr</code> in this tutorial</li>
<li>Pointer to the variable that stores the handle to the new object</li>
</ul>
<p>If everything went well then the handle to the instance was stored in the
<code>VkInstance</code> class member. Nearly all Vulkan functions return a value of type
<code>VkResult</code> that is either <code>VK_SUCCESS</code> or an error code. To check if the
instance was created successfully, we don't need to store the result and can
just use a check for the success value instead:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkCreateInstance(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create instance!"</span>);
}
</div></code></pre>
<p>Now run the program to make sure that the instance is created successfully.</p>
<h4 id="checking-for-extension-support">Checking for extension support</h4>
<p>If you look at the <code>vkCreateInstance</code> documentation then you'll see that one of
the possible error codes is <code>VK_ERROR_EXTENSION_NOT_PRESENT</code>. We could simply
specify the extensions we require and terminate if that error code comes back.
That makes sense for essential extensions like the window system interface, but
what if we want to check for optional functionality?</p>
<p>To retrieve a list of supported extensions before creating an instance, there's
the <code>vkEnumerateInstanceExtensionProperties</code> function. It takes a pointer to a
variable that stores the number of extensions and an array of
<code>VkExtensionProperties</code> to store details of the extensions. It also takes an
optional first parameter that allows us to filter extensions by a specific
validation layer, which we'll ignore for now.</p>
<p>To allocate an array to hold the extension details we first need to know how
many there are. You can request just the number of extensions by leaving the
latter parameter empty:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">uint32_t</span> extensionCount = <span class="hljs-number">0</span>;
vkEnumerateInstanceExtensionProperties(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<p>Now allocate an array to hold the extension details (<code>include &lt;vector&gt;</code>):</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkExtensionProperties&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(extensionCount)</span></span>;
</div></code></pre>
<p>Finally we can query the extension details:</p>
<pre class="hljs"><code><div>vkEnumerateInstanceExtensionProperties(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, extensions.data());
</div></code></pre>
<p>Each <code>VkExtensionProperties</code> struct contains the name and version of an
extension. We can list them with a simple for loop (<code>\t</code> is a tab for
indentation):</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"available extensions:\n"</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; extension : extensions) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'\t'</span> &lt;&lt; extension.extensionName &lt;&lt; <span class="hljs-string">'\n'</span>;
}
</div></code></pre>
<p>You can add this code to the <code>createInstance</code> function if you'd like to provide
some details about the Vulkan support. As a challenge, try to create a function
that checks if all of the extensions returned by
<code>glfwGetRequiredInstanceExtensions</code> are included in the supported extensions
list.</p>
<h4 id="cleaning-up">Cleaning up</h4>
<p>The <code>VkInstance</code> should be only destroyed right before the program exits. It can
be destroyed in <code>cleanup</code> with the <code>vkDestroyInstance</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    vkDestroyInstance(instance, <span class="hljs-literal">nullptr</span>);

    glfwDestroyWindow(window);

    glfwTerminate();
}
</div></code></pre>
<p>The parameters for the <code>vkDestroyInstance</code> function are straightforward. As
mentioned in the previous chapter, the allocation and deallocation functions
in Vulkan have an optional allocator callback that we'll ignore by passing
<code>nullptr</code> to it. All of the other Vulkan resources that we'll create in the
following chapters should be cleaned up before the instance is destroyed.</p>
<p>Before continuing with the more complex steps after instance creation, it's time
to evaluate our debugging options by checking out <a href="!en/Drawing_a_triangle/Setup/Validation_layers">validation layers</a>.</p>
<p><a href="/code/01_instance_creation.cpp">C++ code</a></p>
<h3 id="02validationlayers">02_Validation_layers</h3>
<h4 id="what-are-validation-layers">What are validation layers?</h4>
<p>The Vulkan API is designed around the idea of minimal driver overhead and one of
the manifestations of that goal is that there is very limited error checking in
the API by default. Even mistakes as simple as setting enumerations to incorrect
values or passing null pointers to required parameters are generally not
explicitly handled and will simply result in crashes or undefined behavior.
Because Vulkan requires you to be very explicit about everything you're doing,
it's easy to make many small mistakes like using a new GPU feature and
forgetting to request it at logical device creation time.</p>
<p>However, that doesn't mean that these checks can't be added to the API. Vulkan
introduces an elegant system for this known as <em>validation layers</em>. Validation
layers are optional components that hook into Vulkan function calls to apply
additional operations. Common operations in validation layers are:</p>
<ul>
<li>Checking the values of parameters against the specification to detect misuse</li>
<li>Tracking creation and destruction of objects to find resource leaks</li>
<li>Checking thread safety by tracking the threads that calls originate from</li>
<li>Logging every call and its parameters to the standard output</li>
<li>Tracing Vulkan calls for profiling and replaying</li>
</ul>
<p>Here's an example of what the implementation of a function in a diagnostics
validation layer could look like:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkResult <span class="hljs-title">vkCreateInstance</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> VkInstanceCreateInfo* pCreateInfo,
    <span class="hljs-keyword">const</span> VkAllocationCallbacks* pAllocator,
    VkInstance* instance)</span> </span>{

    <span class="hljs-keyword">if</span> (pCreateInfo == <span class="hljs-literal">nullptr</span> || instance == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-built_in">log</span>(<span class="hljs-string">"Null pointer passed to required parameter!"</span>);
        <span class="hljs-keyword">return</span> VK_ERROR_INITIALIZATION_FAILED;
    }

    <span class="hljs-keyword">return</span> real_vkCreateInstance(pCreateInfo, pAllocator, instance);
}
</div></code></pre>
<p>These validation layers can be freely stacked to include all the debugging
functionality that you're interested in. You can simply enable validation layers
for debug builds and completely disable them for release builds, which gives you
the best of both worlds!</p>
<p>Vulkan does not come with any validation layers built-in, but the LunarG Vulkan
SDK provides a nice set of layers that check for common errors. They're also
completely <a href="https://github.com/KhronosGroup/Vulkan-ValidationLayers">open source</a>,
so you can check which kind of mistakes they check for and contribute. Using the
validation layers is the best way to avoid your application breaking on
different drivers by accidentally relying on undefined behavior.</p>
<p>Validation layers can only be used if they have been installed onto the system.
For example, the LunarG validation layers are only available on PCs with the
Vulkan SDK installed.</p>
<p>There were formerly two different types of validation layers in Vulkan: instance
and device specific. The idea was that instance layers would only check
calls related to global Vulkan objects like instances, and device specific layers
would only check calls related to a specific GPU. Device specific layers have now been
deprecated, which means that instance validation layers apply to all Vulkan
calls. The specification document still recommends that you enable validation
layers at device level as well for compatibility, which is required by some
implementations. We'll simply specify the same layers as the instance at logical
device level, which we'll see <a href="!en/Drawing_a_triangle/Setup/Logical_device_and_queues">later on</a>.</p>
<h4 id="using-validation-layers">Using validation layers</h4>
<p>In this section we'll see how to enable the standard diagnostics layers provided
by the Vulkan SDK. Just like extensions, validation layers need to be enabled by
specifying their name. All of the useful standard validation is bundled into a layer included in the SDK that is known as <code>VK_LAYER_KHRONOS_validation</code>.</p>
<p>Let's first add two configuration variables to the program to specify the layers
to enable and whether to enable them or not. I've chosen to base that value on
whether the program is being compiled in debug mode or not. The <code>NDEBUG</code> macro
is part of the C++ standard and means &quot;not debug&quot;.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> WIDTH = <span class="hljs-number">800</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> HEIGHT = <span class="hljs-number">600</span>;

<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; validationLayers = {
    <span class="hljs-string">"VK_LAYER_KHRONOS_validation"</span>
};

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NDEBUG</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> enableValidationLayers = <span class="hljs-literal">false</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> enableValidationLayers = <span class="hljs-literal">true</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</div></code></pre>
<p>We'll add a new function <code>checkValidationLayerSupport</code> that checks if all of
the requested layers are available. First list all of the available layers
using the <code>vkEnumerateInstanceLayerProperties</code> function. Its usage is identical
to that of <code>vkEnumerateInstanceExtensionProperties</code> which was discussed in the
instance creation chapter.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkValidationLayerSupport</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">uint32_t</span> layerCount;
    vkEnumerateInstanceLayerProperties(&amp;layerCount, <span class="hljs-literal">nullptr</span>);

    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkLayerProperties&gt; <span class="hljs-title">availableLayers</span><span class="hljs-params">(layerCount)</span></span>;
    vkEnumerateInstanceLayerProperties(&amp;layerCount, availableLayers.data());

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</div></code></pre>
<p>Next, check if all of the layers in <code>validationLayers</code> exist in the
<code>availableLayers</code> list. You may need to include <code>&lt;cstring&gt;</code> for <code>strcmp</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* layerName : validationLayers) {
    <span class="hljs-keyword">bool</span> layerFound = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; layerProperties : availableLayers) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="hljs-number">0</span>) {
            layerFound = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">break</span>;
        }
    }

    <span class="hljs-keyword">if</span> (!layerFound) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
}

<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
</div></code></pre>
<p>We can now use this function in <code>createInstance</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (enableValidationLayers &amp;&amp; !checkValidationLayerSupport()) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"validation layers requested, but not available!"</span>);
    }

    ...
}
</div></code></pre>
<p>Now run the program in debug mode and ensure that the error does not occur. If
it does, then have a look at the FAQ.</p>
<p>Finally, modify the <code>VkInstanceCreateInfo</code> struct instantiation to include the
validation layer names if they are enabled:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (enableValidationLayers) {
    createInfo.enabledLayerCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());
    createInfo.ppEnabledLayerNames = validationLayers.data();
} <span class="hljs-keyword">else</span> {
    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>If the check was successful then <code>vkCreateInstance</code> should not ever return a
<code>VK_ERROR_LAYER_NOT_PRESENT</code> error, but you should run the program to make sure.</p>
<h4 id="message-callback">Message callback</h4>
<p>The validation layers will print debug messages to the standard output by default, but we can also handle them ourselves by providing an explicit callback in our program. This will also allow you to decide which kind of messages you would like to see, because not all are necessarily (fatal) errors. If you don't want to do that right now then you may skip to the last section in this chapter.</p>
<p>To set up a callback in the program to handle messages and the associated details, we have to set up a debug messenger with a callback using the <code>VK_EXT_debug_utils</code> extension.</p>
<p>We'll first create a <code>getRequiredExtensions</code> function that will return the
required list of extensions based on whether validation layers are enabled or
not:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">getRequiredExtensions</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>** glfwExtensions;
    glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);

    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;

    <span class="hljs-keyword">if</span> (enableValidationLayers) {
        extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
    }

    <span class="hljs-keyword">return</span> extensions;
}
</div></code></pre>
<p>The extensions specified by GLFW are always required, but the debug messenger
extension is conditionally added. Note that I've used the
<code>VK_EXT_DEBUG_UTILS_EXTENSION_NAME</code> macro here which is equal to the literal
string &quot;VK_EXT_debug_utils&quot;. Using this macro lets you avoid typos.</p>
<p>We can now use this function in <code>createInstance</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">auto</span> extensions = getRequiredExtensions();
createInfo.enabledExtensionCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(extensions.<span class="hljs-built_in">size</span>());
createInfo.ppEnabledExtensionNames = extensions.data();
</div></code></pre>
<p>Run the program to make sure you don't receive a
<code>VK_ERROR_EXTENSION_NOT_PRESENT</code> error. We don't really need to check for the
existence of this extension, because it should be implied by the availability of
the validation layers.</p>
<p>Now let's see what a debug callback function looks like. Add a new static member
function called <code>debugCallback</code> with the <code>PFN_vkDebugUtilsMessengerCallbackEXT</code>
prototype. The <code>VKAPI_ATTR</code> and <code>VKAPI_CALL</code> ensure that the function has the
right signature for Vulkan to call it.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="hljs-title">debugCallback</span><span class="hljs-params">(
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageType,
    <span class="hljs-keyword">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
    <span class="hljs-keyword">void</span>* pUserData)</span> </span>{

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"validation layer: "</span> &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> VK_FALSE;
}
</div></code></pre>
<p>The first parameter specifies the severity of the message, which is one of the following flags:</p>
<ul>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT</code>: Diagnostic message</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT</code>: Informational message like the creation of a resource</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT</code>: Message about behavior that is not necessarily an error, but very likely a bug in your application</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT</code>: Message about behavior that is invalid and may cause crashes</li>
</ul>
<p>The values of this enumeration are set up in such a way that you can use a comparison operation to check if a message is equal or worse compared to some level of severity, for example:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (messageSeverity &gt;= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
    <span class="hljs-comment">// Message is important enough to show</span>
}
</div></code></pre>
<p>The <code>messageType</code> parameter can have the following values:</p>
<ul>
<li><code>VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT</code>: Some event has happened that is unrelated to the specification or performance</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT</code>: Something has happened that violates the specification or indicates a possible mistake</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT</code>: Potential non-optimal use of Vulkan</li>
</ul>
<p>The <code>pCallbackData</code> parameter refers to a <code>VkDebugUtilsMessengerCallbackDataEXT</code> struct containing the details of the message itself, with the most important members being:</p>
<ul>
<li><code>pMessage</code>: The debug message as a null-terminated string</li>
<li><code>pObjects</code>: Array of Vulkan object handles related to the message</li>
<li><code>objectCount</code>: Number of objects in array</li>
</ul>
<p>Finally, the <code>pUserData</code> parameter contains a pointer that was specified during the setup of the callback and allows you to pass your own data to it.</p>
<p>The callback returns a boolean that indicates if the Vulkan call that triggered
the validation layer message should be aborted. If the callback returns true,
then the call is aborted with the <code>VK_ERROR_VALIDATION_FAILED_EXT</code> error. This
is normally only used to test the validation layers themselves, so you should
always return <code>VK_FALSE</code>.</p>
<p>All that remains now is telling Vulkan about the callback function. Perhaps
somewhat surprisingly, even the debug callback in Vulkan is managed with a
handle that needs to be explicitly created and destroyed. Such a callback is part of a <em>debug messenger</em> and you can have as many of them as you want. Add a class member for
this handle right under <code>instance</code>:</p>
<pre class="hljs"><code><div>VkDebugUtilsMessengerEXT debugMessenger;
</div></code></pre>
<p>Now add a function <code>setupDebugMessenger</code> to be called from <code>initVulkan</code> right
after <code>createInstance</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;

}
</div></code></pre>
<p>We'll need to fill in a structure with details about the messenger and its callback:</p>
<pre class="hljs"><code><div>VkDebugUtilsMessengerCreateInfoEXT createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
createInfo.pfnUserCallback = debugCallback;
createInfo.pUserData = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>The <code>messageSeverity</code> field allows you to specify all the types of severities you would like your callback to be called for. I've specified all types except for <code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT</code> here to receive notifications about possible problems while leaving out verbose general debug info.</p>
<p>Similarly the <code>messageType</code> field lets you filter which types of messages your callback is notified about. I've simply enabled all types here. You can always disable some if they're not useful to you.</p>
<p>Finally, the <code>pfnUserCallback</code> field specifies the pointer to the callback function. You can optionally pass a pointer to the <code>pUserData</code> field which will be passed along to the callback function via the <code>pUserData</code> parameter. You could use this to pass a pointer to the <code>HelloTriangleApplication</code> class, for example.</p>
<p>Note that there are many more ways to configure validation layer messages and debug callbacks, but this is a good setup to get started with for this tutorial. See the <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap50.html#VK_EXT_debug_utils">extension specification</a> for more info about the possibilities.</p>
<p>This struct should be passed to the <code>vkCreateDebugUtilsMessengerEXT</code> function to
create the <code>VkDebugUtilsMessengerEXT</code> object. Unfortunately, because this
function is an extension function, it is not automatically loaded. We have to
look up its address ourselves using <code>vkGetInstanceProcAddr</code>. We're going to
create our own proxy function that handles this in the background. I've added it
right above the <code>HelloTriangleApplication</code> class definition.</p>
<pre class="hljs"><code><div><span class="hljs-function">VkResult <span class="hljs-title">CreateDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, <span class="hljs-keyword">const</span> VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span class="hljs-keyword">const</span> VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger)</span> </span>{
    <span class="hljs-keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, <span class="hljs-string">"vkCreateDebugUtilsMessengerEXT"</span>);
    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">return</span> func(instance, pCreateInfo, pAllocator, pDebugMessenger);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;
    }
}
</div></code></pre>
<p>The <code>vkGetInstanceProcAddr</code> function will return <code>nullptr</code> if the function
couldn't be loaded. We can now call this function to create the extension
object if it's available:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to set up debug messenger!"</span>);
}
</div></code></pre>
<p>The second to last parameter is again the optional allocator callback that we
set to <code>nullptr</code>, other than that the parameters are fairly straightforward.
Since the debug messenger is specific to our Vulkan instance and its layers, it
needs to be explicitly specified as first argument. You will also see this
pattern with other <em>child</em> objects later on.</p>
<p>The <code>VkDebugUtilsMessengerEXT</code> object also needs to be cleaned up with a call to
<code>vkDestroyDebugUtilsMessengerEXT</code>. Similarly to <code>vkCreateDebugUtilsMessengerEXT</code>
the function needs to be explicitly loaded.</p>
<p>Create another proxy function right below <code>CreateDebugUtilsMessengerEXT</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, <span class="hljs-keyword">const</span> VkAllocationCallbacks* pAllocator)</span> </span>{
    <span class="hljs-keyword">auto</span> func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, <span class="hljs-string">"vkDestroyDebugUtilsMessengerEXT"</span>);
    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) {
        func(instance, debugMessenger, pAllocator);
    }
}
</div></code></pre>
<p>Make sure that this function is either a static class function or a function
outside the class. We can then call it in the <code>cleanup</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (enableValidationLayers) {
        DestroyDebugUtilsMessengerEXT(instance, debugMessenger, <span class="hljs-literal">nullptr</span>);
    }

    vkDestroyInstance(instance, <span class="hljs-literal">nullptr</span>);

    glfwDestroyWindow(window);

    glfwTerminate();
}
</div></code></pre>
<h4 id="debugging-instance-creation-and-destruction">Debugging instance creation and destruction</h4>
<p>Although we've now added debugging with validation layers to the program we're not covering everything quite yet. The <code>vkCreateDebugUtilsMessengerEXT</code> call requires a valid instance to have been created and <code>vkDestroyDebugUtilsMessengerEXT</code> must be called before the instance is destroyed. This currently leaves us unable to debug any issues in the <code>vkCreateInstance</code> and <code>vkDestroyInstance</code> calls.</p>
<p>However, if you closely read the <a href="https://github.com/KhronosGroup/Vulkan-Docs/blob/master/appendices/VK_EXT_debug_utils.txt#L120">extension documentation</a>, you'll see that there is a way to create a separate debug utils messenger specifically for those two function calls. It requires you to simply pass a pointer to a <code>VkDebugUtilsMessengerCreateInfoEXT</code> struct in the <code>pNext</code> extension field of <code>VkInstanceCreateInfo</code>. First extract population of the messenger create info into a separate function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">populateDebugMessengerCreateInfo</span><span class="hljs-params">(VkDebugUtilsMessengerCreateInfoEXT&amp; createInfo)</span> </span>{
    createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
    createInfo.pfnUserCallback = debugCallback;
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;

    VkDebugUtilsMessengerCreateInfoEXT createInfo;
    populateDebugMessengerCreateInfo(createInfo);

    <span class="hljs-keyword">if</span> (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to set up debug messenger!"</span>);
    }
}
</div></code></pre>
<p>We can now re-use this in the <code>createInstance</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>{
    ...

    VkInstanceCreateInfo createInfo{};
    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    createInfo.pApplicationInfo = &amp;appInfo;

    ...

    VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo{};
    <span class="hljs-keyword">if</span> (enableValidationLayers) {
        createInfo.enabledLayerCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());
        createInfo.ppEnabledLayerNames = validationLayers.data();

        populateDebugMessengerCreateInfo(debugCreateInfo);
        createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &amp;debugCreateInfo;
    } <span class="hljs-keyword">else</span> {
        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;

        createInfo.pNext = <span class="hljs-literal">nullptr</span>;
    }

    <span class="hljs-keyword">if</span> (vkCreateInstance(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create instance!"</span>);
    }
}
</div></code></pre>
<p>The <code>debugCreateInfo</code> variable is placed outside the if statement to ensure that it is not destroyed before the <code>vkCreateInstance</code> call. By creating an additional debug messenger this way it will automatically be used during <code>vkCreateInstance</code> and <code>vkDestroyInstance</code> and cleaned up after that.</p>
<h4 id="testing">Testing</h4>
<p>Now let's intentionally make a mistake to see the validation layers in action. Temporarily remove the call to <code>DestroyDebugUtilsMessengerEXT</code> in the <code>cleanup</code> function and run your program. Once it exits you should see something like this:</p>
<p><img src="images/validation_layer_test.png" alt=""></p>
<blockquote>
<p>If you don't see any messages then <a href="https://vulkan.lunarg.com/doc/view/1.2.131.1/windows/getting_started.html#user-content-verify-the-installation">check your installation</a>.</p>
</blockquote>
<p>If you want to see which call triggered a message, you can add a breakpoint to the message callback and look at the stack trace.</p>
<h4 id="configuration">Configuration</h4>
<p>There are a lot more settings for the behavior of validation layers than just
the flags specified in the <code>VkDebugUtilsMessengerCreateInfoEXT</code> struct. Browse
to the Vulkan SDK and go to the <code>Config</code> directory. There you will find a
<code>vk_layer_settings.txt</code> file that explains how to configure the layers.</p>
<p>To configure the layer settings for your own application, copy the file to the
<code>Debug</code> and <code>Release</code> directories of your project and follow the instructions to
set the desired behavior. However, for the remainder of this tutorial I'll
assume that you're using the default settings.</p>
<p>Throughout this tutorial I'll be making a couple of intentional mistakes to show
you how helpful the validation layers are with catching them and to teach you
how important it is to know exactly what you're doing with Vulkan. Now it's time
to look at <a href="!en/Drawing_a_triangle/Setup/Physical_devices_and_queue_families">Vulkan devices in the system</a>.</p>
<p><a href="/code/02_validation_layers.cpp">C++ code</a></p>
<h3 id="03physicaldevicesandqueuefamilies">03_Physical_devices_and_queue_families</h3>
<h4 id="selecting-a-physical-device">Selecting a physical device</h4>
<p>After initializing the Vulkan library through a VkInstance we need to look for
and select a graphics card in the system that supports the features we need. In
fact we can select any number of graphics cards and use them simultaneously, but
in this tutorial we'll stick to the first graphics card that suits our needs.</p>
<p>We'll add a function <code>pickPhysicalDevice</code> and add a call to it in the
<code>initVulkan</code> function.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    pickPhysicalDevice();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pickPhysicalDevice</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>The graphics card that we'll end up selecting will be stored in a
VkPhysicalDevice handle that is added as a new class member. This object will be
implicitly destroyed when the VkInstance is destroyed, so we won't need to do
anything new in the <code>cleanup</code> function.</p>
<pre class="hljs"><code><div>VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
</div></code></pre>
<p>Listing the graphics cards is very similar to listing extensions and starts with
querying just the number.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">uint32_t</span> deviceCount = <span class="hljs-number">0</span>;
vkEnumeratePhysicalDevices(instance, &amp;deviceCount, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<p>If there are 0 devices with Vulkan support then there is no point going further.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (deviceCount == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to find GPUs with Vulkan support!"</span>);
}
</div></code></pre>
<p>Otherwise we can now allocate an array to hold all of the VkPhysicalDevice
handles.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkPhysicalDevice&gt; <span class="hljs-title">devices</span><span class="hljs-params">(deviceCount)</span></span>;
vkEnumeratePhysicalDevices(instance, &amp;deviceCount, devices.data());
</div></code></pre>
<p>Now we need to evaluate each of them and check if they are suitable for the
operations we want to perform, because not all graphics cards are created equal.
For that we'll introduce a new function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<p>And we'll check if any of the physical devices meet the requirements that we'll
add to that function.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; device : devices) {
    <span class="hljs-keyword">if</span> (isDeviceSuitable(device)) {
        physicalDevice = device;
        <span class="hljs-keyword">break</span>;
    }
}

<span class="hljs-keyword">if</span> (physicalDevice == VK_NULL_HANDLE) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to find a suitable GPU!"</span>);
}
</div></code></pre>
<p>The next section will introduce the first requirements that we'll check for in
the <code>isDeviceSuitable</code> function. As we'll start using more Vulkan features in
the later chapters we will also extend this function to include more checks.</p>
<h4 id="base-device-suitability-checks">Base device suitability checks</h4>
<p>To evaluate the suitability of a device we can start by querying for some
details. Basic device properties like the name, type and supported Vulkan
version can be queried using vkGetPhysicalDeviceProperties.</p>
<pre class="hljs"><code><div>VkPhysicalDeviceProperties deviceProperties;
vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);
</div></code></pre>
<p>The support for optional features like texture compression, 64 bit floats and
multi viewport rendering (useful for VR) can be queried using
vkGetPhysicalDeviceFeatures:</p>
<pre class="hljs"><code><div>VkPhysicalDeviceFeatures deviceFeatures;
vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);
</div></code></pre>
<p>There are more details that can be queried from devices that we'll discuss later
concerning device memory and queue families (see the next section).</p>
<p>As an example, let's say we consider our application only usable for dedicated
graphics cards that support geometry shaders. Then the <code>isDeviceSuitable</code>
function would look like this:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    VkPhysicalDeviceProperties deviceProperties;
    VkPhysicalDeviceFeatures deviceFeatures;
    vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);
    vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);

    <span class="hljs-keyword">return</span> deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU &amp;&amp;
           deviceFeatures.geometryShader;
}
</div></code></pre>
<p>Instead of just checking if a device is suitable or not and going with the first
one, you could also give each device a score and pick the highest one. That way
you could favor a dedicated graphics card by giving it a higher score, but fall
back to an integrated GPU if that's the only available one. You could implement
something like that as follows:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span>

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pickPhysicalDevice</span><span class="hljs-params">()</span> </span>{
    ...

    <span class="hljs-comment">// Use an ordered map to automatically sort candidates by increasing score</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">multimap</span>&lt;<span class="hljs-keyword">int</span>, VkPhysicalDevice&gt; candidates;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; device : devices) {
        <span class="hljs-keyword">int</span> score = rateDeviceSuitability(device);
        candidates.insert(<span class="hljs-built_in">std</span>::make_pair(score, device));
    }

    <span class="hljs-comment">// Check if the best candidate is suitable at all</span>
    <span class="hljs-keyword">if</span> (candidates.rbegin()-&gt;first &gt; <span class="hljs-number">0</span>) {
        physicalDevice = candidates.rbegin()-&gt;second;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to find a suitable GPU!"</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rateDeviceSuitability</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    ...

    <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Discrete GPUs have a significant performance advantage</span>
    <span class="hljs-keyword">if</span> (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
        score += <span class="hljs-number">1000</span>;
    }

    <span class="hljs-comment">// Maximum possible size of textures affects graphics quality</span>
    score += deviceProperties.limits.maxImageDimension2D;

    <span class="hljs-comment">// Application can't function without geometry shaders</span>
    <span class="hljs-keyword">if</span> (!deviceFeatures.geometryShader) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">return</span> score;
}
</div></code></pre>
<p>You don't need to implement all that for this tutorial, but it's to give you an
idea of how you could design your device selection process. Of course you can
also just display the names of the choices and allow the user to select.</p>
<p>Because we're just starting out, Vulkan support is the only thing we need and
therefore we'll settle for just any GPU:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<p>In the next section we'll discuss the first real required feature to check for.</p>
<h4 id="queue-families">Queue families</h4>
<p>It has been briefly touched upon before that almost every operation in Vulkan,
anything from drawing to uploading textures, requires commands to be submitted
to a queue. There are different types of queues that originate from different
<em>queue families</em> and each family of queues allows only a subset of commands. For
example, there could be a queue family that only allows processing of compute
commands or one that only allows memory transfer related commands.</p>
<p>We need to check which queue families are supported by the device and which one
of these supports the commands that we want to use. For that purpose we'll add a
new function <code>findQueueFamilies</code> that looks for all the queue families we need.</p>
<p>Right now we are only going to look for a queue that supports graphics commands,
so the function could look like this:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    <span class="hljs-comment">// Logic to find graphics queue family</span>
}
</div></code></pre>
<p>However, in one of the next chapters we're already going to look for yet another
queue, so it's better to prepare for that and bundle the indices into a struct:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueFamilyIndices</span> {</span>
    <span class="hljs-keyword">uint32_t</span> graphicsFamily;
};

<span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    QueueFamilyIndices indices;
    <span class="hljs-comment">// Logic to find queue family indices to populate struct with</span>
    <span class="hljs-keyword">return</span> indices;
}
</div></code></pre>
<p>But what if a queue family is not available? We could throw an exception in
<code>findQueueFamilies</code>, but this function is not really the right place to make
decisions about device suitability. For example, we may <em>prefer</em> devices with a
dedicated transfer queue family, but not require it. Therefore we need some way
of indicating whether a particular queue family was found.</p>
<p>It's not really possible to use a magic value to indicate the nonexistence of a
queue family, since any value of <code>uint32_t</code> could in theory be a valid queue
family index including <code>0</code>. Luckily C++17 introduced a data structure to
distinguish between the case of a value existing or not:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;optional&gt;</span></span>

...

<span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">uint32_t</span>&gt; graphicsFamily;

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::boolalpha &lt;&lt; graphicsFamily.has_value() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// false</span>

graphicsFamily = <span class="hljs-number">0</span>;

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::boolalpha &lt;&lt; graphicsFamily.has_value() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// true</span>
</div></code></pre>
<p><code>std::optional</code> is a wrapper that contains no value until you assign something
to it. At any point you can query if it contains a value or not by calling its
<code>has_value()</code> member function. That means that we can change the logic to:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;optional&gt;</span></span>

...

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueFamilyIndices</span> {</span>
    <span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">uint32_t</span>&gt; graphicsFamily;
};

<span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    QueueFamilyIndices indices;
    <span class="hljs-comment">// Assign index to queue families that could be found</span>
    <span class="hljs-keyword">return</span> indices;
}
</div></code></pre>
<p>We can now begin to actually implement <code>findQueueFamilies</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    QueueFamilyIndices indices;

    ...

    <span class="hljs-keyword">return</span> indices;
}
</div></code></pre>
<p>The process of retrieving the list of queue families is exactly what you expect
and uses <code>vkGetPhysicalDeviceQueueFamilyProperties</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;
vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);

<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;
vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data());
</div></code></pre>
<p>The VkQueueFamilyProperties struct contains some details about the queue family,
including the type of operations that are supported and the number of queues
that can be created based on that family. We need to find at least one queue
family that supports <code>VK_QUEUE_GRAPHICS_BIT</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) {
    <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) {
        indices.graphicsFamily = i;
    }

    i++;
}
</div></code></pre>
<p>Now that we have this fancy queue family lookup function, we can use it as a
check in the <code>isDeviceSuitable</code> function to ensure that the device can process
the commands we want to use:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    QueueFamilyIndices indices = findQueueFamilies(device);

    <span class="hljs-keyword">return</span> indices.graphicsFamily.has_value();
}
</div></code></pre>
<p>To make this a little bit more convenient, we'll also add a generic check to the
struct itself:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueFamilyIndices</span> {</span>
    <span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">uint32_t</span>&gt; graphicsFamily;

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> graphicsFamily.has_value();
    }
};

...

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    QueueFamilyIndices indices = findQueueFamilies(device);

    <span class="hljs-keyword">return</span> indices.isComplete();
}
</div></code></pre>
<p>We can now also use this for an early exit from <code>findQueueFamilies</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) {
    ...

    <span class="hljs-keyword">if</span> (indices.isComplete()) {
        <span class="hljs-keyword">break</span>;
    }

    i++;
}
</div></code></pre>
<p>Great, that's all we need for now to find the right physical device! The next
step is to <a href="!en/Drawing_a_triangle/Setup/Logical_device_and_queues">create a logical device</a>
to interface with it.</p>
<p><a href="/code/03_physical_device_selection.cpp">C++ code</a></p>
<h3 id="04logicaldeviceandqueues">04_Logical_device_and_queues</h3>
<h4 id="introduction">Introduction</h4>
<p>After selecting a physical device to use we need to set up a <em>logical device</em> to
interface with it. The logical device creation process is similar to the
instance creation process and describes the features we want to use. We also
need to specify which queues to create now that we've queried which queue
families are available. You can even create multiple logical devices from the
same physical device if you have varying requirements.</p>
<p>Start by adding a new class member to store the logical device handle in.</p>
<pre class="hljs"><code><div>VkDevice device;
</div></code></pre>
<p>Next, add a <code>createLogicalDevice</code> function that is called from <code>initVulkan</code>.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    pickPhysicalDevice();
    createLogicalDevice();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createLogicalDevice</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<h4 id="specifying-the-queues-to-be-created">Specifying the queues to be created</h4>
<p>The creation of a logical device involves specifying a bunch of details in
structs again, of which the first one will be <code>VkDeviceQueueCreateInfo</code>. This
structure describes the number of queues we want for a single queue family.
Right now we're only interested in a queue with graphics capabilities.</p>
<pre class="hljs"><code><div>QueueFamilyIndices indices = findQueueFamilies(physicalDevice);

VkDeviceQueueCreateInfo queueCreateInfo{};
queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.value();
queueCreateInfo.queueCount = <span class="hljs-number">1</span>;
</div></code></pre>
<p>The currently available drivers will only allow you to create a small number of
queues for each queue family and you don't really need more than one. That's
because you can create all of the command buffers on multiple threads and then
submit them all at once on the main thread with a single low-overhead call.</p>
<p>Vulkan lets you assign priorities to queues to influence the scheduling of
command buffer execution using floating point numbers between <code>0.0</code> and <code>1.0</code>.
This is required even if there is only a single queue:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">float</span> queuePriority = <span class="hljs-number">1.0f</span>;
queueCreateInfo.pQueuePriorities = &amp;queuePriority;
</div></code></pre>
<h4 id="specifying-used-device-features">Specifying used device features</h4>
<p>The next information to specify is the set of device features that we'll be
using. These are the features that we queried support for with
<code>vkGetPhysicalDeviceFeatures</code> in the previous chapter, like geometry shaders.
Right now we don't need anything special, so we can simply define it and leave
everything to <code>VK_FALSE</code>. We'll come back to this structure once we're about to
start doing more interesting things with Vulkan.</p>
<pre class="hljs"><code><div>VkPhysicalDeviceFeatures deviceFeatures{};
</div></code></pre>
<h4 id="creating-the-logical-device">Creating the logical device</h4>
<p>With the previous two structures in place, we can start filling in the main
<code>VkDeviceCreateInfo</code> structure.</p>
<pre class="hljs"><code><div>VkDeviceCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
</div></code></pre>
<p>First add pointers to the queue creation info and device features structs:</p>
<pre class="hljs"><code><div>createInfo.pQueueCreateInfos = &amp;queueCreateInfo;
createInfo.queueCreateInfoCount = <span class="hljs-number">1</span>;

createInfo.pEnabledFeatures = &amp;deviceFeatures;
</div></code></pre>
<p>The remainder of the information bears a resemblance to the
<code>VkInstanceCreateInfo</code> struct and requires you to specify extensions and
validation layers. The difference is that these are device specific this time.</p>
<p>An example of a device specific extension is <code>VK_KHR_swapchain</code>, which allows
you to present rendered images from that device to windows. It is possible that
there are Vulkan devices in the system that lack this ability, for example
because they only support compute operations. We will come back to this
extension in the swap chain chapter.</p>
<p>Previous implementations of Vulkan made a distinction between instance and device specific validation layers, but this is <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap40.html#extendingvulkan-layers-devicelayerdeprecation">no longer the case</a>. That means that the <code>enabledLayerCount</code> and <code>ppEnabledLayerNames</code> fields of <code>VkDeviceCreateInfo</code> are ignored by up-to-date implementations. However, it is still a good idea to set them anyway to be compatible with older implementations:</p>
<pre class="hljs"><code><div>createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;

<span class="hljs-keyword">if</span> (enableValidationLayers) {
    createInfo.enabledLayerCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());
    createInfo.ppEnabledLayerNames = validationLayers.data();
} <span class="hljs-keyword">else</span> {
    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>We won't need any device specific extensions for now.</p>
<p>That's it, we're now ready to instantiate the logical device with a call to the
appropriately named <code>vkCreateDevice</code> function.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkCreateDevice(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create logical device!"</span>);
}
</div></code></pre>
<p>The parameters are the physical device to interface with, the queue and usage
info we just specified, the optional allocation callbacks pointer and a pointer
to a variable to store the logical device handle in. Similarly to the instance
creation function, this call can return errors based on enabling non-existent
extensions or specifying the desired usage of unsupported features.</p>
<p>The device should be destroyed in <code>cleanup</code> with the <code>vkDestroyDevice</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    vkDestroyDevice(device, <span class="hljs-literal">nullptr</span>);
    ...
}
</div></code></pre>
<p>Logical devices don't interact directly with instances, which is why it's not
included as a parameter.</p>
<h4 id="retrieving-queue-handles">Retrieving queue handles</h4>
<p>The queues are automatically created along with the logical device, but we don't
have a handle to interface with them yet. First add a class member to store a
handle to the graphics queue:</p>
<pre class="hljs"><code><div>VkQueue graphicsQueue;
</div></code></pre>
<p>Device queues are implicitly cleaned up when the device is destroyed, so we
don't need to do anything in <code>cleanup</code>.</p>
<p>We can use the <code>vkGetDeviceQueue</code> function to retrieve queue handles for each
queue family. The parameters are the logical device, queue family, queue index
and a pointer to the variable to store the queue handle in. Because we're only
creating a single queue from this family, we'll simply use index <code>0</code>.</p>
<pre class="hljs"><code><div>vkGetDeviceQueue(device, indices.graphicsFamily.value(), <span class="hljs-number">0</span>, &amp;graphicsQueue);
</div></code></pre>
<p>With the logical device and queue handles we can now actually start using the
graphics card to do things! In the next few chapters we'll set up the resources
to present results to the window system.</p>
<p><a href="/code/04_logical_device.cpp">C++ code</a></p>
<h2 id="2-presentation">2. Presentation</h2>
<h3 id="00windowsurface">00_Window_surface</h3>
<p>Since Vulkan is a platform agnostic API, it can not interface directly with the
window system on its own. To establish the connection between Vulkan and the
window system to present results to the screen, we need to use the WSI (Window
System Integration) extensions. In this chapter we'll discuss the first one,
which is <code>VK_KHR_surface</code>. It exposes a <code>VkSurfaceKHR</code> object that represents an
abstract type of surface to present rendered images to. The surface in our
program will be backed by the window that we've already opened with GLFW.</p>
<p>The <code>VK_KHR_surface</code> extension is an instance level extension and we've actually
already enabled it, because it's included in the list returned by
<code>glfwGetRequiredInstanceExtensions</code>. The list also includes some other WSI
extensions that we'll use in the next couple of chapters.</p>
<p>The window surface needs to be created right after the instance creation,
because it can actually influence the physical device selection. The reason we
postponed this is because window surfaces are part of the larger topic of
render targets and presentation for which the explanation would have cluttered
the basic setup. It should also be noted that window surfaces are an entirely
optional component in Vulkan, if you just need off-screen rendering. Vulkan
allows you to do that without hacks like creating an invisible window
(necessary for OpenGL).</p>
<h4 id="window-surface-creation">Window surface creation</h4>
<p>Start by adding a <code>surface</code> class member right below the debug callback.</p>
<pre class="hljs"><code><div>VkSurfaceKHR surface;
</div></code></pre>
<p>Although the <code>VkSurfaceKHR</code> object and its usage is platform agnostic, its
creation isn't because it depends on window system details. For example, it
needs the <code>HWND</code> and <code>HMODULE</code> handles on Windows. Therefore there is a
platform-specific addition to the extension, which on Windows is called
<code>VK_KHR_win32_surface</code> and is also automatically included in the list from
<code>glfwGetRequiredInstanceExtensions</code>.</p>
<p>I will demonstrate how this platform specific extension can be used to create a
surface on Windows, but we won't actually use it in this tutorial. It doesn't
make any sense to use a library like GLFW and then proceed to use
platform-specific code anyway. GLFW actually has <code>glfwCreateWindowSurface</code> that
handles the platform differences for us. Still, it's good to see what it does
behind the scenes before we start relying on it.</p>
<p>To access native platform functions, you need to update the includes at the top:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VK_USE_PLATFORM_WIN32_KHR</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLFW_INCLUDE_VULKAN</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLFW_EXPOSE_NATIVE_WIN32</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3native.h&gt;</span></span>
</div></code></pre>
<p>Because a window surface is a Vulkan object, it comes with a
<code>VkWin32SurfaceCreateInfoKHR</code> struct that needs to be filled in. It has two
important parameters: <code>hwnd</code> and <code>hinstance</code>. These are the handles to the
window and the process.</p>
<pre class="hljs"><code><div>VkWin32SurfaceCreateInfoKHR createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
createInfo.hwnd = glfwGetWin32Window(window);
createInfo.hinstance = GetModuleHandle(<span class="hljs-literal">nullptr</span>);
</div></code></pre>
<p>The <code>glfwGetWin32Window</code> function is used to get the raw <code>HWND</code> from the GLFW
window object. The <code>GetModuleHandle</code> call returns the <code>HINSTANCE</code> handle of the
current process.</p>
<p>After that the surface can be created with <code>vkCreateWin32SurfaceKHR</code>, which includes a parameter for the instance, surface creation details, custom allocators and the variable for the surface handle to be stored in. Technically this is a WSI extension function, but it is so commonly used that the standard Vulkan loader includes it, so unlike other extensions you don't need to explicitly load it.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkCreateWin32SurfaceKHR(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;surface) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create window surface!"</span>);
}
</div></code></pre>
<p>The process is similar for other platforms like Linux, where
<code>vkCreateXcbSurfaceKHR</code> takes an XCB connection and window as creation details
with X11.</p>
<p>The <code>glfwCreateWindowSurface</code> function performs exactly this operation with a
different implementation for each platform. We'll now integrate it into our
program. Add a function <code>createSurface</code> to be called from <code>initVulkan</code> right
after instance creation and <code>setupDebugMessenger</code>.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createSurface</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>The GLFW call takes simple parameters instead of a struct which makes the
implementation of the function very straightforward:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createSurface</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (glfwCreateWindowSurface(instance, window, <span class="hljs-literal">nullptr</span>, &amp;surface) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create window surface!"</span>);
    }
}
</div></code></pre>
<p>The parameters are the <code>VkInstance</code>, GLFW window pointer, custom allocators and
pointer to <code>VkSurfaceKHR</code> variable. It simply passes through the <code>VkResult</code> from
the relevant platform call. GLFW doesn't offer a special function for destroying
a surface, but that can easily be done through the original API:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
        ...
        vkDestroySurfaceKHR(instance, surface, <span class="hljs-literal">nullptr</span>);
        vkDestroyInstance(instance, <span class="hljs-literal">nullptr</span>);
        ...
    }
</div></code></pre>
<p>Make sure that the surface is destroyed before the instance.</p>
<h4 id="querying-for-presentation-support">Querying for presentation support</h4>
<p>Although the Vulkan implementation may support window system integration, that
does not mean that every device in the system supports it. Therefore we need to
extend <code>isDeviceSuitable</code> to ensure that a device can present images to the
surface we created. Since the presentation is a queue-specific feature, the
problem is actually about finding a queue family that supports presenting to the
surface we created.</p>
<p>It's actually possible that the queue families supporting drawing commands and
the ones supporting presentation do not overlap. Therefore we have to take into
account that there could be a distinct presentation queue by modifying the
<code>QueueFamilyIndices</code> structure:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueFamilyIndices</span> {</span>
    <span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">uint32_t</span>&gt; graphicsFamily;
    <span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">uint32_t</span>&gt; presentFamily;

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> graphicsFamily.has_value() &amp;&amp; presentFamily.has_value();
    }
};
</div></code></pre>
<p>Next, we'll modify the <code>findQueueFamilies</code> function to look for a queue family
that has the capability of presenting to our window surface. The function to
check for that is <code>vkGetPhysicalDeviceSurfaceSupportKHR</code>, which takes the
physical device, queue family index and surface as parameters. Add a call to it
in the same loop as the <code>VK_QUEUE_GRAPHICS_BIT</code>:</p>
<pre class="hljs"><code><div>VkBool32 presentSupport = <span class="hljs-literal">false</span>;
vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &amp;presentSupport);
</div></code></pre>
<p>Then simply check the value of the boolean and store the presentation family
queue index:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (presentSupport) {
    indices.presentFamily = i;
}
</div></code></pre>
<p>Note that it's very likely that these end up being the same queue family after
all, but throughout the program we will treat them as if they were separate
queues for a uniform approach. Nevertheless, you could add logic to explicitly
prefer a physical device that supports drawing and presentation in the same
queue for improved performance.</p>
<h4 id="creating-the-presentation-queue">Creating the presentation queue</h4>
<p>The one thing that remains is modifying the logical device creation procedure to
create the presentation queue and retrieve the <code>VkQueue</code> handle. Add a member
variable for the handle:</p>
<pre class="hljs"><code><div>VkQueue presentQueue;
</div></code></pre>
<p>Next, we need to have multiple <code>VkDeviceQueueCreateInfo</code> structs to create a
queue from both families. An elegant way to do that is to create a set of all
unique queue families that are necessary for the required queues:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span>

...

QueueFamilyIndices indices = findQueueFamilies(physicalDevice);

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; uniqueQueueFamilies = {indices.graphicsFamily.value(), indices.presentFamily.value()};

<span class="hljs-keyword">float</span> queuePriority = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> queueFamily : uniqueQueueFamilies) {
    VkDeviceQueueCreateInfo queueCreateInfo{};
    queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    queueCreateInfo.queueFamilyIndex = queueFamily;
    queueCreateInfo.queueCount = <span class="hljs-number">1</span>;
    queueCreateInfo.pQueuePriorities = &amp;queuePriority;
    queueCreateInfos.push_back(queueCreateInfo);
}
</div></code></pre>
<p>And modify <code>VkDeviceCreateInfo</code> to point to the vector:</p>
<pre class="hljs"><code><div>createInfo.queueCreateInfoCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(queueCreateInfos.<span class="hljs-built_in">size</span>());
createInfo.pQueueCreateInfos = queueCreateInfos.data();
</div></code></pre>
<p>If the queue families are the same, then we only need to pass its index once.
Finally, add a call to retrieve the queue handle:</p>
<pre class="hljs"><code><div>vkGetDeviceQueue(device, indices.presentFamily.value(), <span class="hljs-number">0</span>, &amp;presentQueue);
</div></code></pre>
<p>In case the queue families are the same, the two handles will most likely have
the same value now. In the next chapter we're going to look at swap chains and
how they give us the ability to present images to the surface.</p>
<p><a href="/code/05_window_surface.cpp">C++ code</a></p>
<h3 id="01swapchain">01_Swap_chain</h3>
<p>Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen. This infrastructure is
known as the <em>swap chain</em> and must be created explicitly in Vulkan. The swap
chain is essentially a queue of images that are waiting to be presented to the
screen. Our application will acquire such an image to draw to it, and then
return it to the queue. How exactly the queue works and the conditions for
presenting an image from the queue depend on how the swap chain is set up, but
the general purpose of the swap chain is to synchronize the presentation of
images with the refresh rate of the screen.</p>
<h4 id="checking-for-swap-chain-support">Checking for swap chain support</h4>
<p>Not all graphics cards are capable of presenting images directly to a screen for
various reasons, for example because they are designed for servers and don't
have any display outputs. Secondly, since image presentation is heavily tied
into the window system and the surfaces associated with windows, it is not
actually part of the Vulkan core. You have to enable the <code>VK_KHR_swapchain</code>
device extension after querying for its support.</p>
<p>For that purpose we'll first extend the <code>isDeviceSuitable</code> function to check if
this extension is supported. We've previously seen how to list the extensions
that are supported by a <code>VkPhysicalDevice</code>, so doing that should be fairly
straightforward. Note that the Vulkan header file provides a nice macro
<code>VK_KHR_SWAPCHAIN_EXTENSION_NAME</code> that is defined as <code>VK_KHR_swapchain</code>. The
advantage of using this macro is that the compiler will catch misspellings.</p>
<p>First declare a list of required device extensions, similar to the list of
validation layers to enable.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; deviceExtensions = {
    VK_KHR_SWAPCHAIN_EXTENSION_NAME
};
</div></code></pre>
<p>Next, create a new function <code>checkDeviceExtensionSupport</code> that is called from
<code>isDeviceSuitable</code> as an additional check:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    QueueFamilyIndices indices = findQueueFamilies(device);

    <span class="hljs-keyword">bool</span> extensionsSupported = checkDeviceExtensionSupport(device);

    <span class="hljs-keyword">return</span> indices.isComplete() &amp;&amp; extensionsSupported;
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkDeviceExtensionSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<p>Modify the body of the function to enumerate the extensions and check if all of
the required extensions are amongst them.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkDeviceExtensionSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    <span class="hljs-keyword">uint32_t</span> extensionCount;
    vkEnumerateDeviceExtensionProperties(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);

    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkExtensionProperties&gt; <span class="hljs-title">availableExtensions</span><span class="hljs-params">(extensionCount)</span></span>;
    vkEnumerateDeviceExtensionProperties(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, availableExtensions.data());

    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">requiredExtensions</span><span class="hljs-params">(deviceExtensions.<span class="hljs-built_in">begin</span>(), deviceExtensions.<span class="hljs-built_in">end</span>())</span></span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; extension : availableExtensions) {
        requiredExtensions.erase(extension.extensionName);
    }

    <span class="hljs-keyword">return</span> requiredExtensions.empty();
}
</div></code></pre>
<p>I've chosen to use a set of strings here to represent the unconfirmed required
extensions. That way we can easily tick them off while enumerating the sequence
of available extensions. Of course you can also use a nested loop like in
<code>checkValidationLayerSupport</code>. The performance difference is irrelevant. Now run
the code and verify that your graphics card is indeed capable of creating a
swap chain. It should be noted that the availability of a presentation queue,
as we checked in the previous chapter, implies that the swap chain extension
must be supported. However, it's still good to be explicit about things, and
the extension does have to be explicitly enabled.</p>
<h4 id="enabling-device-extensions">Enabling device extensions</h4>
<p>Using a swapchain requires enabling the <code>VK_KHR_swapchain</code> extension first.
Enabling the extension just requires a small change to the logical device
creation structure:</p>
<pre class="hljs"><code><div>createInfo.enabledExtensionCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(deviceExtensions.<span class="hljs-built_in">size</span>());
createInfo.ppEnabledExtensionNames = deviceExtensions.data();
</div></code></pre>
<p>Make sure to replace the existing line <code>createInfo.enabledExtensionCount = 0;</code> when you do so.</p>
<h4 id="querying-details-of-swap-chain-support">Querying details of swap chain support</h4>
<p>Just checking if a swap chain is available is not sufficient, because it may not
actually be compatible with our window surface. Creating a swap chain also
involves a lot more settings than instance and device creation, so we need to
query for some more details before we're able to proceed.</p>
<p>There are basically three kinds of properties we need to check:</p>
<ul>
<li>Basic surface capabilities (min/max number of images in swap chain, min/max
width and height of images)</li>
<li>Surface formats (pixel format, color space)</li>
<li>Available presentation modes</li>
</ul>
<p>Similar to <code>findQueueFamilies</code>, we'll use a struct to pass these details around
once they've been queried. The three aforementioned types of properties come in
the form of the following structs and lists of structs:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwapChainSupportDetails</span> {</span>
    VkSurfaceCapabilitiesKHR capabilities;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkSurfaceFormatKHR&gt; formats;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkPresentModeKHR&gt; presentModes;
};
</div></code></pre>
<p>We'll now create a new function <code>querySwapChainSupport</code> that will populate this
struct.</p>
<pre class="hljs"><code><div><span class="hljs-function">SwapChainSupportDetails <span class="hljs-title">querySwapChainSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    SwapChainSupportDetails details;

    <span class="hljs-keyword">return</span> details;
}
</div></code></pre>
<p>This section covers how to query the structs that include this information. The
meaning of these structs and exactly which data they contain is discussed in the
next section.</p>
<p>Let's start with the basic surface capabilities. These properties are simple to
query and are returned into a single <code>VkSurfaceCapabilitiesKHR</code> struct.</p>
<pre class="hljs"><code><div>vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &amp;details.capabilities);
</div></code></pre>
<p>This function takes the specified <code>VkPhysicalDevice</code> and <code>VkSurfaceKHR</code> window
surface into account when determining the supported capabilities. All of the
support querying functions have these two as first parameters because they are
the core components of the swap chain.</p>
<p>The next step is about querying the supported surface formats. Because this is a
list of structs, it follows the familiar ritual of 2 function calls:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">uint32_t</span> formatCount;
vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, <span class="hljs-literal">nullptr</span>);

<span class="hljs-keyword">if</span> (formatCount != <span class="hljs-number">0</span>) {
    details.formats.resize(formatCount);
    vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, details.formats.data());
}
</div></code></pre>
<p>Make sure that the vector is resized to hold all the available formats. And
finally, querying the supported presentation modes works exactly the same way
with <code>vkGetPhysicalDeviceSurfacePresentModesKHR</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">uint32_t</span> presentModeCount;
vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, <span class="hljs-literal">nullptr</span>);

<span class="hljs-keyword">if</span> (presentModeCount != <span class="hljs-number">0</span>) {
    details.presentModes.resize(presentModeCount);
    vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, details.presentModes.data());
}
</div></code></pre>
<p>All of the details are in the struct now, so let's extend <code>isDeviceSuitable</code>
once more to utilize this function to verify that swap chain support is
adequate. Swap chain support is sufficient for this tutorial if there is at
least one supported image format and one supported presentation mode given the
window surface we have.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> swapChainAdequate = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">if</span> (extensionsSupported) {
    SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);
    swapChainAdequate = !swapChainSupport.formats.empty() &amp;&amp; !swapChainSupport.presentModes.empty();
}
</div></code></pre>
<p>It is important that we only try to query for swap chain support after verifying
that the extension is available. The last line of the function changes to:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">return</span> indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate;
</div></code></pre>
<h4 id="choosing-the-right-settings-for-the-swap-chain">Choosing the right settings for the swap chain</h4>
<p>If the <code>swapChainAdequate</code> conditions were met then the support is definitely
sufficient, but there may still be many different modes of varying optimality.
We'll now write a couple of functions to find the right settings for the best
possible swap chain. There are three types of settings to determine:</p>
<ul>
<li>Surface format (color depth)</li>
<li>Presentation mode (conditions for &quot;swapping&quot; images to the screen)</li>
<li>Swap extent (resolution of images in swap chain)</li>
</ul>
<p>For each of these settings we'll have an ideal value in mind that we'll go with
if it's available and otherwise we'll create some logic to find the next best
thing.</p>
<h5 id="surface-format">Surface format</h5>
<p>The function for this setting starts out like this. We'll later pass the
<code>formats</code> member of the <code>SwapChainSupportDetails</code> struct as argument.</p>
<pre class="hljs"><code><div><span class="hljs-function">VkSurfaceFormatKHR <span class="hljs-title">chooseSwapSurfaceFormat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats)</span> </span>{

}
</div></code></pre>
<p>Each <code>VkSurfaceFormatKHR</code> entry contains a <code>format</code> and a <code>colorSpace</code> member. The
<code>format</code> member specifies the color channels and types. For example,
<code>VK_FORMAT_B8G8R8A8_SRGB</code> means that we store the B, G, R and alpha channels in
that order with an 8 bit unsigned integer for a total of 32 bits per pixel. The
<code>colorSpace</code> member indicates if the SRGB color space is supported or not using
the <code>VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</code> flag. Note that this flag used to be
called <code>VK_COLORSPACE_SRGB_NONLINEAR_KHR</code> in old versions of the specification.</p>
<p>For the color space we'll use SRGB if it is available, because it <a href="http://stackoverflow.com/questions/12524623/">results in more accurate perceived colors</a>. It is also pretty much the standard color space for images, like the textures we'll use later on.
Because of that we should also use an SRGB color format, of which one of the most common ones is <code>VK_FORMAT_B8G8R8A8_SRGB</code>.</p>
<p>Let's go through the list and see if the preferred combination is available:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; availableFormat : availableFormats) {
    <span class="hljs-keyword">if</span> (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
        <span class="hljs-keyword">return</span> availableFormat;
    }
}
</div></code></pre>
<p>If that also fails then we could start ranking the available formats based on
how &quot;good&quot; they are, but in most cases it's okay to just settle with the first
format that is specified.</p>
<pre class="hljs"><code><div><span class="hljs-function">VkSurfaceFormatKHR <span class="hljs-title">chooseSwapSurfaceFormat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; availableFormat : availableFormats) {
        <span class="hljs-keyword">if</span> (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
            <span class="hljs-keyword">return</span> availableFormat;
        }
    }

    <span class="hljs-keyword">return</span> availableFormats[<span class="hljs-number">0</span>];
}
</div></code></pre>
<h5 id="presentation-mode">Presentation mode</h5>
<p>The presentation mode is arguably the most important setting for the swap chain,
because it represents the actual conditions for showing images to the screen.
There are four possible modes available in Vulkan:</p>
<ul>
<li><code>VK_PRESENT_MODE_IMMEDIATE_KHR</code>: Images submitted by your application are
transferred to the screen right away, which may result in tearing.</li>
<li><code>VK_PRESENT_MODE_FIFO_KHR</code>: The swap chain is a queue where the display takes
an image from the front of the queue when the display is refreshed and the
program inserts rendered images at the back of the queue. If the queue is full
then the program has to wait. This is most similar to vertical sync as found in
modern games. The moment that the display is refreshed is known as &quot;vertical
blank&quot;.</li>
<li><code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code>: This mode only differs from the previous
one if the application is late and the queue was empty at the last vertical
blank. Instead of waiting for the next vertical blank, the image is transferred
right away when it finally arrives. This may result in visible tearing.</li>
<li><code>VK_PRESENT_MODE_MAILBOX_KHR</code>: This is another variation of the second mode.
Instead of blocking the application when the queue is full, the images that are
already queued are simply replaced with the newer ones. This mode can be used to
render frames as fast as possible while still avoiding tearing, resulting in fewer latency issues than standard vertical sync. This is commonly known as &quot;triple buffering&quot;, although the existence of three buffers alone does not necessarily mean that the framerate is unlocked.</li>
</ul>
<p>Only the <code>VK_PRESENT_MODE_FIFO_KHR</code> mode is guaranteed to be available, so we'll
again have to write a function that looks for the best mode that is available:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkPresentModeKHR <span class="hljs-title">chooseSwapPresentMode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkPresentModeKHR&gt;&amp; availablePresentModes)</span> </span>{
    <span class="hljs-keyword">return</span> VK_PRESENT_MODE_FIFO_KHR;
}
</div></code></pre>
<p>I personally think that <code>VK_PRESENT_MODE_MAILBOX_KHR</code> is a very nice trade-off if energy usage is not a concern. It allows us to avoid tearing while still maintaining a fairly low latency by rendering new images that are as up-to-date as possible right until the vertical blank. On mobile devices, where energy usage is more important, you will probably want to use <code>VK_PRESENT_MODE_FIFO_KHR</code> instead. Now, let's look through the list to see if <code>VK_PRESENT_MODE_MAILBOX_KHR</code> is available:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkPresentModeKHR <span class="hljs-title">chooseSwapPresentMode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkPresentModeKHR&gt;&amp; availablePresentModes)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; availablePresentMode : availablePresentModes) {
        <span class="hljs-keyword">if</span> (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) {
            <span class="hljs-keyword">return</span> availablePresentMode;
        }
    }

    <span class="hljs-keyword">return</span> VK_PRESENT_MODE_FIFO_KHR;
}
</div></code></pre>
<h5 id="swap-extent">Swap extent</h5>
<p>That leaves only one major property, for which we'll add one last function:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkExtent2D <span class="hljs-title">chooseSwapExtent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span> </span>{

}
</div></code></pre>
<p>The swap extent is the resolution of the swap chain images and it's almost
always exactly equal to the resolution of the window that we're drawing to <em>in
pixels</em> (more on that in a moment). The range of the possible resolutions is
defined in the <code>VkSurfaceCapabilitiesKHR</code> structure. Vulkan tells us to match
the resolution of the window by setting the width and height in the
<code>currentExtent</code> member. However, some window managers do allow us to differ here
and this is indicated by setting the width and height in <code>currentExtent</code> to a
special value: the maximum value of <code>uint32_t</code>. In that case we'll pick the
resolution that best matches the window within the <code>minImageExtent</code> and
<code>maxImageExtent</code> bounds. But we must specify the resolution in the correct unit.</p>
<p>GLFW uses two units when measuring sizes: pixels and
<a href="https://www.glfw.org/docs/latest/intro_guide.html#coordinate_systems">screen coordinates</a>.
For example, the resolution <code>{WIDTH, HEIGHT}</code> that we specified earlier when
creating the window is measured in screen coordinates. But Vulkan works with
pixels, so the swap chain extent must be specified in pixels as well.
Unfortunately, if you are using a high DPI display (like Apple's Retina
display), screen coordinates don't correspond to pixels. Instead, due to the
higher pixel density, the resolution of the window in pixel will be larger than
the resolution in screen coordinates. So if Vulkan doesn't fix the swap extent
for us, we can't just use the original <code>{WIDTH, HEIGHT}</code>. Instead, we must use
<code>glfwGetFramebufferSize</code> to query the resolution of the window in pixel before
matching it against the minimum and maximum image extent.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdint&gt; // Necessary for uint32_t</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits&gt; // Necessary for std::numeric_limits</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt; // Necessary for std::clamp</span></span>

...

<span class="hljs-function">VkExtent2D <span class="hljs-title">chooseSwapExtent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span> </span>{
    <span class="hljs-keyword">if</span> (capabilities.currentExtent.<span class="hljs-built_in">width</span> != <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">uint32_t</span>&gt;::<span class="hljs-built_in">max</span>()) {
        <span class="hljs-keyword">return</span> capabilities.currentExtent;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>;
        glfwGetFramebufferSize(window, &amp;<span class="hljs-built_in">width</span>, &amp;<span class="hljs-built_in">height</span>);

        VkExtent2D actualExtent = {
            <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(<span class="hljs-built_in">width</span>),
            <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(<span class="hljs-built_in">height</span>)
        };

        actualExtent.<span class="hljs-built_in">width</span> = <span class="hljs-built_in">std</span>::clamp(actualExtent.<span class="hljs-built_in">width</span>, capabilities.minImageExtent.<span class="hljs-built_in">width</span>, capabilities.maxImageExtent.<span class="hljs-built_in">width</span>);
        actualExtent.<span class="hljs-built_in">height</span> = <span class="hljs-built_in">std</span>::clamp(actualExtent.<span class="hljs-built_in">height</span>, capabilities.minImageExtent.<span class="hljs-built_in">height</span>, capabilities.maxImageExtent.<span class="hljs-built_in">height</span>);

        <span class="hljs-keyword">return</span> actualExtent;
    }
}
</div></code></pre>
<p>The <code>clamp</code> function is used here to bound the values of <code>width</code> and <code>height</code> between the allowed minimum and maximum extents that are supported by the implementation.</p>
<h4 id="creating-the-swap-chain">Creating the swap chain</h4>
<p>Now that we have all of these helper functions assisting us with the choices we
have to make at runtime, we finally have all the information that is needed to
create a working swap chain.</p>
<p>Create a <code>createSwapChain</code> function that starts out with the results of these
calls and make sure to call it from <code>initVulkan</code> after logical device creation.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createSwapChain</span><span class="hljs-params">()</span> </span>{
    SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice);

    VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);
    VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);
    VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);
}
</div></code></pre>
<p>Aside from these properties we also have to decide how many images we would like to have in the swap chain. The implementation specifies the minimum number that it requires to function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">uint32_t</span> imageCount = swapChainSupport.capabilities.minImageCount;
</div></code></pre>
<p>However, simply sticking to this minimum means that we may sometimes have to wait on the driver to complete internal operations before we can acquire another image to render to. Therefore it is recommended to request at least one more image than the minimum:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">uint32_t</span> imageCount = swapChainSupport.capabilities.minImageCount + <span class="hljs-number">1</span>;
</div></code></pre>
<p>We should also make sure to not exceed the maximum number of images while doing this, where <code>0</code> is a special value that means that there is no maximum:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (swapChainSupport.capabilities.maxImageCount &gt; <span class="hljs-number">0</span> &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) {
    imageCount = swapChainSupport.capabilities.maxImageCount;
}
</div></code></pre>
<p>As is tradition with Vulkan objects, creating the swap chain object requires
filling in a large structure. It starts out very familiarly:</p>
<pre class="hljs"><code><div>VkSwapchainCreateInfoKHR createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
createInfo.surface = surface;
</div></code></pre>
<p>After specifying which surface the swap chain should be tied to, the details of
the swap chain images are specified:</p>
<pre class="hljs"><code><div>createInfo.minImageCount = imageCount;
createInfo.imageFormat = surfaceFormat.format;
createInfo.imageColorSpace = surfaceFormat.colorSpace;
createInfo.imageExtent = extent;
createInfo.imageArrayLayers = <span class="hljs-number">1</span>;
createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
</div></code></pre>
<p>The <code>imageArrayLayers</code> specifies the amount of layers each image consists of.
This is always <code>1</code> unless you are developing a stereoscopic 3D application. The
<code>imageUsage</code> bit field specifies what kind of operations we'll use the images in
the swap chain for. In this tutorial we're going to render directly to them,
which means that they're used as color attachment. It is also possible that
you'll render images to a separate image first to perform operations like
post-processing. In that case you may use a value like
<code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> instead and use a memory operation to transfer
the rendered image to a swap chain image.</p>
<pre class="hljs"><code><div>QueueFamilyIndices indices = findQueueFamilies(physicalDevice);
<span class="hljs-keyword">uint32_t</span> queueFamilyIndices[] = {indices.graphicsFamily.value(), indices.presentFamily.value()};

<span class="hljs-keyword">if</span> (indices.graphicsFamily != indices.presentFamily) {
    createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
    createInfo.queueFamilyIndexCount = <span class="hljs-number">2</span>;
    createInfo.pQueueFamilyIndices = queueFamilyIndices;
} <span class="hljs-keyword">else</span> {
    createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
    createInfo.queueFamilyIndexCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span>
    createInfo.pQueueFamilyIndices = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
}
</div></code></pre>
<p>Next, we need to specify how to handle swap chain images that will be used
across multiple queue families. That will be the case in our application if the
graphics queue family is different from the presentation queue. We'll be drawing
on the images in the swap chain from the graphics queue and then submitting them
on the presentation queue. There are two ways to handle images that are
accessed from multiple queues:</p>
<ul>
<li><code>VK_SHARING_MODE_EXCLUSIVE</code>: An image is owned by one queue family at a time
and ownership must be explicitly transferred before using it in another queue
family. This option offers the best performance.</li>
<li><code>VK_SHARING_MODE_CONCURRENT</code>: Images can be used across multiple queue
families without explicit ownership transfers.</li>
</ul>
<p>If the queue families differ, then we'll be using the concurrent mode in this
tutorial to avoid having to do the ownership chapters, because these involve
some concepts that are better explained at a later time. Concurrent mode
requires you to specify in advance between which queue families ownership will
be shared using the <code>queueFamilyIndexCount</code> and <code>pQueueFamilyIndices</code>
parameters. If the graphics queue family and presentation queue family are the
same, which will be the case on most hardware, then we should stick to exclusive
mode, because concurrent mode requires you to specify at least two distinct
queue families.</p>
<pre class="hljs"><code><div>createInfo.preTransform = swapChainSupport.capabilities.currentTransform;
</div></code></pre>
<p>We can specify that a certain transform should be applied to images in the swap
chain if it is supported (<code>supportedTransforms</code> in <code>capabilities</code>), like a 90
degree clockwise rotation or horizontal flip. To specify that you do not want
any transformation, simply specify the current transformation.</p>
<pre class="hljs"><code><div>createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
</div></code></pre>
<p>The <code>compositeAlpha</code> field specifies if the alpha channel should be used for
blending with other windows in the window system. You'll almost always want to
simply ignore the alpha channel, hence <code>VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</code>.</p>
<pre class="hljs"><code><div>createInfo.presentMode = presentMode;
createInfo.clipped = VK_TRUE;
</div></code></pre>
<p>The <code>presentMode</code> member speaks for itself. If the <code>clipped</code> member is set to
<code>VK_TRUE</code> then that means that we don't care about the color of pixels that are
obscured, for example because another window is in front of them. Unless you
really need to be able to read these pixels back and get predictable results,
you'll get the best performance by enabling clipping.</p>
<pre class="hljs"><code><div>createInfo.oldSwapchain = VK_NULL_HANDLE;
</div></code></pre>
<p>That leaves one last field, <code>oldSwapChain</code>. With Vulkan it's possible that your swap chain becomes invalid or unoptimized while your application is
running, for example because the window was resized. In that case the swap chain
actually needs to be recreated from scratch and a reference to the old one must
be specified in this field. This is a complex topic that we'll learn more about
in <a href="!en/Drawing_a_triangle/Swap_chain_recreation">a future chapter</a>. For now we'll
assume that we'll only ever create one swap chain.</p>
<p>Now add a class member to store the <code>VkSwapchainKHR</code> object:</p>
<pre class="hljs"><code><div>VkSwapchainKHR swapChain;
</div></code></pre>
<p>Creating the swap chain is now as simple as calling <code>vkCreateSwapchainKHR</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkCreateSwapchainKHR(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChain) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create swap chain!"</span>);
}
</div></code></pre>
<p>The parameters are the logical device, swap chain creation info, optional custom
allocators and a pointer to the variable to store the handle in. No surprises
there. It should be cleaned up using <code>vkDestroySwapchainKHR</code> before the device:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    vkDestroySwapchainKHR(device, swapChain, <span class="hljs-literal">nullptr</span>);
    ...
}
</div></code></pre>
<p>Now run the application to ensure that the swap chain is created successfully! If at this point you get an access violation error in <code>vkCreateSwapchainKHR</code> or see a message like <code>Failed to find 'vkGetInstanceProcAddress' in layer SteamOverlayVulkanLayer.dll</code>, then see the <a href="!en/FAQ">FAQ entry</a> about the Steam overlay layer.</p>
<p>Try removing the <code>createInfo.imageExtent = extent;</code> line with validation layers
enabled. You'll see that one of the validation layers immediately catches the
mistake and a helpful message is printed:</p>
<p><img src="images/swap_chain_validation_layer.png" alt=""></p>
<h4 id="retrieving-the-swap-chain-images">Retrieving the swap chain images</h4>
<p>The swap chain has been created now, so all that remains is retrieving the
handles of the <code>VkImage</code>s in it. We'll reference these during rendering
operations in later chapters. Add a class member to store the handles:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkImage&gt; swapChainImages;
</div></code></pre>
<p>The images were created by the implementation for the swap chain and they will
be automatically cleaned up once the swap chain has been destroyed, therefore we
don't need to add any cleanup code.</p>
<p>I'm adding the code to retrieve the handles to the end of the <code>createSwapChain</code>
function, right after the <code>vkCreateSwapchainKHR</code> call. Retrieving them is very
similar to the other times where we retrieved an array of objects from Vulkan. Remember that we only specified a minimum number of images in the swap chain, so the implementation is allowed to create a swap chain with more. That's why we'll first query the final number of images with <code>vkGetSwapchainImagesKHR</code>, then resize the container and finally call it again
to retrieve the handles.</p>
<pre class="hljs"><code><div>vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, <span class="hljs-literal">nullptr</span>);
swapChainImages.resize(imageCount);
vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, swapChainImages.data());
</div></code></pre>
<p>One last thing, store the format and extent we've chosen for the swap chain
images in member variables. We'll need them in future chapters.</p>
<pre class="hljs"><code><div>VkSwapchainKHR swapChain;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkImage&gt; swapChainImages;
VkFormat swapChainImageFormat;
VkExtent2D swapChainExtent;

...

swapChainImageFormat = surfaceFormat.format;
swapChainExtent = extent;
</div></code></pre>
<p>We now have a set of images that can be drawn onto and can be presented to the
window. The next chapter will begin to cover how we can set up the images as
render targets and then we start looking into the actual graphics pipeline and
drawing commands!</p>
<p><a href="/code/06_swap_chain_creation.cpp">C++ code</a></p>
<h3 id="02imageviews">02_Image_views</h3>
<p>To use any <code>VkImage</code>, including those in the swap chain, in the render pipeline
we have to create a <code>VkImageView</code> object. An image view is quite literally a
view into an image. It describes how to access the image and which part of the
image to access, for example if it should be treated as a 2D texture depth
texture without any mipmapping levels.</p>
<p>In this chapter we'll write a <code>createImageViews</code> function that creates a basic
image view for every image in the swap chain so that we can use them as color
targets later on.</p>
<p>First add a class member to store the image views in:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkImageView&gt; swapChainImageViews;
</div></code></pre>
<p>Create the <code>createImageViews</code> function and call it right after swap chain
creation.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createImageViews</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>The first thing we need to do is resize the list to fit all of the image views
we'll be creating:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createImageViews</span><span class="hljs-params">()</span> </span>{
    swapChainImageViews.resize(swapChainImages.<span class="hljs-built_in">size</span>());

}
</div></code></pre>
<p>Next, set up the loop that iterates over all of the swap chain images.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImages.<span class="hljs-built_in">size</span>(); i++) {

}
</div></code></pre>
<p>The parameters for image view creation are specified in a
<code>VkImageViewCreateInfo</code> structure. The first few parameters are straightforward.</p>
<pre class="hljs"><code><div>VkImageViewCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
createInfo.<span class="hljs-built_in">image</span> = swapChainImages[i];
</div></code></pre>
<p>The <code>viewType</code> and <code>format</code> fields specify how the image data should be
interpreted. The <code>viewType</code> parameter allows you to treat images as 1D textures,
2D textures, 3D textures and cube maps.</p>
<pre class="hljs"><code><div>createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
createInfo.format = swapChainImageFormat;
</div></code></pre>
<p>The <code>components</code> field allows you to swizzle the color channels around. For
example, you can map all of the channels to the red channel for a monochrome
texture. You can also map constant values of <code>0</code> and <code>1</code> to a channel. In our
case we'll stick to the default mapping.</p>
<pre class="hljs"><code><div>createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
</div></code></pre>
<p>The <code>subresourceRange</code> field describes what the image's purpose is and which
part of the image should be accessed. Our images will be used as color targets
without any mipmapping levels or multiple layers.</p>
<pre class="hljs"><code><div>createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
createInfo.subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;
createInfo.subresourceRange.levelCount = <span class="hljs-number">1</span>;
createInfo.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;
createInfo.subresourceRange.layerCount = <span class="hljs-number">1</span>;
</div></code></pre>
<p>If you were working on a stereographic 3D application, then you would create a
swap chain with multiple layers. You could then create multiple image views for
each image representing the views for the left and right eyes by accessing
different layers.</p>
<p>Creating the image view is now a matter of calling <code>vkCreateImageView</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkCreateImageView(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainImageViews[i]) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create image views!"</span>);
}
</div></code></pre>
<p>Unlike images, the image views were explicitly created by us, so we need to add
a similar loop to destroy them again at the end of the program:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> imageView : swapChainImageViews) {
        vkDestroyImageView(device, imageView, <span class="hljs-literal">nullptr</span>);
    }

    ...
}
</div></code></pre>
<p>An image view is sufficient to start using an image as a texture, but it's not
quite ready to be used as a render target just yet. That requires one more step
of indirection, known as a framebuffer. But first we'll have to set up the
graphics pipeline.</p>
<p><a href="/code/07_image_views.cpp">C++ code</a></p>
<h2 id="3-graphics-pipeline-basics">3. Graphics pipeline basics</h2>
<h3 id="00introduction">00_Introduction</h3>
<p>Over the course of the next few chapters we'll be setting up a graphics pipeline
that is configured to draw our first triangle. The graphics pipeline is the
sequence of operations that take the vertices and textures of your meshes all
the way to the pixels in the render targets. A simplified overview is displayed
below:</p>
<p><img src="images/vulkan_simplified_pipeline.svg" alt=""></p>
<p>The <em>input assembler</em> collects the raw vertex data from the buffers you specify
and may also use an index buffer to repeat certain elements without having to
duplicate the vertex data itself.</p>
<p>The <em>vertex shader</em> is run for every vertex and generally applies
transformations to turn vertex positions from model space to screen space. It
also passes per-vertex data down the pipeline.</p>
<p>The <em>tessellation shaders</em> allow you to subdivide geometry based on certain
rules to increase the mesh quality. This is often used to make surfaces like
brick walls and staircases look less flat when they are nearby.</p>
<p>The <em>geometry shader</em> is run on every primitive (triangle, line, point) and can
discard it or output more primitives than came in. This is similar to the
tessellation shader, but much more flexible. However, it is not used much in
today's applications because the performance is not that good on most graphics
cards except for Intel's integrated GPUs.</p>
<p>The <em>rasterization</em> stage discretizes the primitives into <em>fragments</em>. These are
the pixel elements that they fill on the framebuffer. Any fragments that fall
outside the screen are discarded and the attributes outputted by the vertex
shader are interpolated across the fragments, as shown in the figure. Usually
the fragments that are behind other primitive fragments are also discarded here
because of depth testing.</p>
<p>The <em>fragment shader</em> is invoked for every fragment that survives and determines
which framebuffer(s) the fragments are written to and with which color and depth
values. It can do this using the interpolated data from the vertex shader, which
can include things like texture coordinates and normals for lighting.</p>
<p>The <em>color blending</em> stage applies operations to mix different fragments that
map to the same pixel in the framebuffer. Fragments can simply overwrite each
other, add up or be mixed based upon transparency.</p>
<p>Stages with a green color are known as <em>fixed-function</em> stages. These stages
allow you to tweak their operations using parameters, but the way they work is
predefined.</p>
<p>Stages with an orange color on the other hand are <code>programmable</code>, which means
that you can upload your own code to the graphics card to apply exactly the
operations you want. This allows you to use fragment shaders, for example, to
implement anything from texturing and lighting to ray tracers. These programs
run on many GPU cores simultaneously to process many objects, like vertices and
fragments in parallel.</p>
<p>If you've used older APIs like OpenGL and Direct3D before, then you'll be used
to being able to change any pipeline settings at will with calls like
<code>glBlendFunc</code> and <code>OMSetBlendState</code>. The graphics pipeline in Vulkan is almost
completely immutable, so you must recreate the pipeline from scratch if you want
to change shaders, bind different framebuffers or change the blend function. The
disadvantage is that you'll have to create a number of pipelines that represent
all of the different combinations of states you want to use in your rendering
operations. However, because all of the operations you'll be doing in the
pipeline are known in advance, the driver can optimize for it much better.</p>
<p>Some of the programmable stages are optional based on what you intend to do. For
example, the tessellation and geometry stages can be disabled if you are just
drawing simple geometry. If you are only interested in depth values then you can
disable the fragment shader stage, which is useful for <a href="https://en.wikipedia.org/wiki/Shadow_mapping">shadow map</a>
generation.</p>
<p>In the next chapter we'll first create the two programmable stages required to
put a triangle onto the screen: the vertex shader and fragment shader. The
fixed-function configuration like blending mode, viewport, rasterization will be
set up in the chapter after that. The final part of setting up the graphics
pipeline in Vulkan involves the specification of input and output framebuffers.</p>
<p>Create a <code>createGraphicsPipeline</code> function that is called right after
<code>createImageViews</code> in <code>initVulkan</code>. We'll work on this function throughout the
following chapters.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createGraphicsPipeline();
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p><a href="/code/08_graphics_pipeline.cpp">C++ code</a></p>
<h3 id="01shadermodules">01_Shader_modules</h3>
<p>Unlike earlier APIs, shader code in Vulkan has to be specified in a bytecode
format as opposed to human-readable syntax like <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a>
and <a href="https://en.wikipedia.org/wiki/High-Level_Shading_Language">HLSL</a>. This
bytecode format is called <a href="https://www.khronos.org/spir">SPIR-V</a> and is designed
to be used with both Vulkan and OpenCL (both Khronos APIs). It is a format that
can be used to write graphics and compute shaders, but we will focus on shaders
used in Vulkan's graphics pipelines in this tutorial.</p>
<p>The advantage of using a bytecode format is that the compilers written by GPU
vendors to turn shader code into native code are significantly less complex. The
past has shown that with human-readable syntax like GLSL, some GPU vendors were
rather flexible with their interpretation of the standard. If you happen to
write non-trivial shaders with a GPU from one of these vendors, then you'd risk
other vendor's drivers rejecting your code due to syntax errors, or worse, your
shader running differently because of compiler bugs. With a straightforward
bytecode format like SPIR-V that will hopefully be avoided.</p>
<p>However, that does not mean that we need to write this bytecode by hand. Khronos
has released their own vendor-independent compiler that compiles GLSL to SPIR-V.
This compiler is designed to verify that your shader code is fully standards
compliant and produces one SPIR-V binary that you can ship with your program.
You can also include this compiler as a library to produce SPIR-V at runtime,
but we won't be doing that in this tutorial. Although we can use this compiler directly via <code>glslangValidator.exe</code>, we will be using <code>glslc.exe</code> by Google instead. The advantage of <code>glslc</code> is that it uses the same parameter format as well-known compilers like GCC and Clang and includes some extra functionality like <em>includes</em>. Both of them are already included in the Vulkan SDK, so you don't need to download anything extra.</p>
<p>GLSL is a shading language with a C-style syntax. Programs written in it have a
<code>main</code> function that is invoked for every object. Instead of using parameters
for input and a return value as output, GLSL uses global variables to handle
input and output. The language includes many features to aid in graphics
programming, like built-in vector and matrix primitives. Functions for
operations like cross products, matrix-vector products and reflections around a
vector are included. The vector type is called <code>vec</code> with a number indicating
the amount of elements. For example, a 3D position would be stored in a <code>vec3</code>.
It is possible to access single components through members like <code>.x</code>, but it's
also possible to create a new vector from multiple components at the same time.
For example, the expression <code>vec3(1.0, 2.0, 3.0).xy</code> would result in <code>vec2</code>. The
constructors of vectors can also take combinations of vector objects and scalar
values. For example, a <code>vec3</code> can be constructed with
<code>vec3(vec2(1.0, 2.0), 3.0)</code>.</p>
<p>As the previous chapter mentioned, we need to write a vertex shader and a
fragment shader to get a triangle on the screen. The next two sections will
cover the GLSL code of each of those and after that I'll show you how to produce
two SPIR-V binaries and load them into the program.</p>
<h4 id="vertex-shader">Vertex shader</h4>
<p>The vertex shader processes each incoming vertex. It takes its attributes, like
world position, color, normal and texture coordinates as input. The output is
the final position in clip coordinates and the attributes that need to be passed
on to the fragment shader, like color and texture coordinates. These values will
then be interpolated over the fragments by the rasterizer to produce a smooth
gradient.</p>
<p>A <em>clip coordinate</em> is a four dimensional vector from the vertex shader that is
subsequently turned into a <em>normalized device coordinate</em> by dividing the whole
vector by its last component. These normalized device coordinates are
<a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">homogeneous coordinates</a>
that map the framebuffer to a [-1, 1] by [-1, 1] coordinate system that looks
like the following:</p>
<p><img src="images/normalized_device_coordinates.svg" alt=""></p>
<p>You should already be familiar with these if you have dabbled in computer
graphics before. If you have used OpenGL before, then you'll notice that the
sign of the Y coordinates is now flipped. The Z coordinate now uses the same
range as it does in Direct3D, from 0 to 1.</p>
<p>For our first triangle we won't be applying any transformations, we'll just
specify the positions of the three vertices directly as normalized device
coordinates to create the following shape:</p>
<p><img src="images/triangle_coordinates.svg" alt=""></p>
<p>We can directly output normalized device coordinates by outputting them as clip
coordinates from the vertex shader with the last component set to <code>1</code>. That way
the division to transform clip coordinates to normalized device coordinates will
not change anything.</p>
<p>Normally these coordinates would be stored in a vertex buffer, but creating a
vertex buffer in Vulkan and filling it with data is not trivial. Therefore I've
decided to postpone that until after we've had the satisfaction of seeing a
triangle pop up on the screen. We're going to do something a little unorthodox
in the meanwhile: include the coordinates directly inside the vertex shader. The
code looks like this:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#version 450</span>

<span class="hljs-type">vec2</span> positions[<span class="hljs-number">3</span>] = <span class="hljs-type">vec2</span>[](
    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">-0.5</span>),
    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),
    <span class="hljs-type">vec2</span>(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>)
);

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(positions[gl_VertexIndex], <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
}
</div></code></pre>
<p>The <code>main</code> function is invoked for every vertex. The built-in <code>gl_VertexIndex</code>
variable contains the index of the current vertex. This is usually an index into
the vertex buffer, but in our case it will be an index into a hardcoded array
of vertex data. The position of each vertex is accessed from the constant array
in the shader and combined with dummy <code>z</code> and <code>w</code> components to produce a
position in clip coordinates. The built-in variable <code>gl_Position</code> functions as
the output.</p>
<h4 id="fragment-shader">Fragment shader</h4>
<p>The triangle that is formed by the positions from the vertex shader fills an
area on the screen with fragments. The fragment shader is invoked on these
fragments to produce a color and depth for the framebuffer (or framebuffers). A
simple fragment shader that outputs the color red for the entire triangle looks
like this:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#version 450</span>

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;

<span class="hljs-type">void</span> main() {
    outColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
}
</div></code></pre>
<p>The <code>main</code> function is called for every fragment just like the vertex shader
<code>main</code> function is called for every vertex. Colors in GLSL are 4-component
vectors with the R, G, B and alpha channels within the [0, 1] range. Unlike
<code>gl_Position</code> in the vertex shader, there is no built-in variable to output a
color for the current fragment. You have to specify your own output variable for
each framebuffer where the <code>layout(location = 0)</code> modifier specifies the index
of the framebuffer. The color red is written to this <code>outColor</code> variable that is
linked to the first (and only) framebuffer at index <code>0</code>.</p>
<h4 id="per-vertex-colors">Per-vertex colors</h4>
<p>Making the entire triangle red is not very interesting, wouldn't something like
the following look a lot nicer?</p>
<p><img src="images/triangle_coordinates_colors.png" alt=""></p>
<p>We have to make a couple of changes to both shaders to accomplish this. First
off, we need to specify a distinct color for each of the three vertices. The
vertex shader should now include an array with colors just like it does for
positions:</p>
<pre class="hljs"><code><div><span class="hljs-type">vec3</span> colors[<span class="hljs-number">3</span>] = <span class="hljs-type">vec3</span>[](
    <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>),
    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>),
    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)
);
</div></code></pre>
<p>Now we just need to pass these per-vertex colors to the fragment shader so it
can output their interpolated values to the framebuffer. Add an output for color
to the vertex shader and write to it in the <code>main</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(positions[gl_VertexIndex], <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
    fragColor = colors[gl_VertexIndex];
}
</div></code></pre>
<p>Next, we need to add a matching input in the fragment shader:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> fragColor;

<span class="hljs-type">void</span> main() {
    outColor = <span class="hljs-type">vec4</span>(fragColor, <span class="hljs-number">1.0</span>);
}
</div></code></pre>
<p>The input variable does not necessarily have to use the same name, they will be
linked together using the indexes specified by the <code>location</code> directives. The
<code>main</code> function has been modified to output the color along with an alpha value.
As shown in the image above, the values for <code>fragColor</code> will be automatically
interpolated for the fragments between the three vertices, resulting in a smooth
gradient.</p>
<h4 id="compiling-the-shaders">Compiling the shaders</h4>
<p>Create a directory called <code>shaders</code> in the root directory of your project and
store the vertex shader in a file called <code>shader.vert</code> and the fragment shader
in a file called <code>shader.frag</code> in that directory. GLSL shaders don't have an
official extension, but these two are commonly used to distinguish them.</p>
<p>The contents of <code>shader.vert</code> should be:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#version 450</span>

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;

<span class="hljs-type">vec2</span> positions[<span class="hljs-number">3</span>] = <span class="hljs-type">vec2</span>[](
    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">-0.5</span>),
    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),
    <span class="hljs-type">vec2</span>(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>)
);

<span class="hljs-type">vec3</span> colors[<span class="hljs-number">3</span>] = <span class="hljs-type">vec3</span>[](
    <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>),
    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>),
    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)
);

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(positions[gl_VertexIndex], <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
    fragColor = colors[gl_VertexIndex];
}
</div></code></pre>
<p>And the contents of <code>shader.frag</code> should be:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#version 450</span>

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> fragColor;

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;

<span class="hljs-type">void</span> main() {
    outColor = <span class="hljs-type">vec4</span>(fragColor, <span class="hljs-number">1.0</span>);
}
</div></code></pre>
<p>We're now going to compile these into SPIR-V bytecode using the
<code>glslc</code> program.</p>
<p><strong>Windows</strong></p>
<p>Create a <code>compile.bat</code> file with the following contents:</p>
<pre class="hljs"><code><div>C:/VulkanSDK/x.x.x.x/Bin32/glslc.exe shader.vert -o vert.spv
C:/VulkanSDK/x.x.x.x/Bin32/glslc.exe shader.frag -o frag.spv
pause
</div></code></pre>
<p>Replace the path to <code>glslc.exe</code> with the path to where you installed
the Vulkan SDK. Double click the file to run it.</p>
<p><strong>Linux</strong></p>
<p>Create a <code>compile.sh</code> file with the following contents:</p>
<pre class="hljs"><code><div>/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslc shader.vert -o vert.spv
/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslc shader.frag -o frag.spv
</div></code></pre>
<p>Replace the path to <code>glslc</code> with the path to where you installed the
Vulkan SDK. Make the script executable with <code>chmod +x compile.sh</code> and run it.</p>
<p><strong>End of platform-specific instructions</strong></p>
<p>These two commands tell the compiler to read the GLSL source file and output a SPIR-V bytecode file using the <code>-o</code> (output) flag.</p>
<p>If your shader contains a syntax error then the compiler will tell you the line
number and problem, as you would expect. Try leaving out a semicolon for example
and run the compile script again. Also try running the compiler without any
arguments to see what kinds of flags it supports. It can, for example, also
output the bytecode into a human-readable format so you can see exactly what
your shader is doing and any optimizations that have been applied at this stage.</p>
<p>Compiling shaders on the commandline is one of the most straightforward options and it's the one that we'll use in this tutorial, but it's also possible to compile shaders directly from your own code. The Vulkan SDK includes <a href="https://github.com/google/shaderc">libshaderc</a>, which is a library to compile GLSL code to SPIR-V from within your program.</p>
<h4 id="loading-a-shader">Loading a shader</h4>
<p>Now that we have a way of producing SPIR-V shaders, it's time to load them into
our program to plug them into the graphics pipeline at some point. We'll first
write a simple helper function to load the binary data from the files.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span>

...

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">readFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; filename)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, <span class="hljs-built_in">std</span>::ios::ate | <span class="hljs-built_in">std</span>::ios::binary)</span></span>;

    <span class="hljs-keyword">if</span> (!file.is_open()) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to open file!"</span>);
    }
}
</div></code></pre>
<p>The <code>readFile</code> function will read all of the bytes from the specified file and
return them in a byte array managed by <code>std::vector</code>. We start by opening the
file with two flags:</p>
<ul>
<li><code>ate</code>: Start reading at the end of the file</li>
<li><code>binary</code>: Read the file as binary file (avoid text transformations)</li>
</ul>
<p>The advantage of starting to read at the end of the file is that we can use the
read position to determine the size of the file and allocate a buffer:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">size_t</span> fileSize = (<span class="hljs-keyword">size_t</span>) file.tellg();
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(fileSize)</span></span>;
</div></code></pre>
<p>After that, we can seek back to the beginning of the file and read all of the
bytes at once:</p>
<pre class="hljs"><code><div>file.seekg(<span class="hljs-number">0</span>);
file.<span class="hljs-built_in">read</span>(<span class="hljs-built_in">buffer</span>.data(), fileSize);
</div></code></pre>
<p>And finally close the file and return the bytes:</p>
<pre class="hljs"><code><div>file.<span class="hljs-built_in">close</span>();

<span class="hljs-keyword">return</span> <span class="hljs-built_in">buffer</span>;
</div></code></pre>
<p>We'll now call this function from <code>createGraphicsPipeline</code> to load the bytecode
of the two shaders:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> vertShaderCode = readFile(<span class="hljs-string">"shaders/vert.spv"</span>);
    <span class="hljs-keyword">auto</span> fragShaderCode = readFile(<span class="hljs-string">"shaders/frag.spv"</span>);
}
</div></code></pre>
<p>Make sure that the shaders are loaded correctly by printing the size of the
buffers and checking if they match the actual file size in bytes. Note that the code doesn't need to be null terminated since it's binary code and we will later be explicit about its size.</p>
<h4 id="creating-shader-modules">Creating shader modules</h4>
<p>Before we can pass the code to the pipeline, we have to wrap it in a
<code>VkShaderModule</code> object. Let's create a helper function <code>createShaderModule</code> to
do that.</p>
<pre class="hljs"><code><div><span class="hljs-function">VkShaderModule <span class="hljs-title">createShaderModule</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&amp; code)</span> </span>{

}
</div></code></pre>
<p>The function will take a buffer with the bytecode as parameter and create a
<code>VkShaderModule</code> from it.</p>
<p>Creating a shader module is simple, we only need to specify a pointer to the
buffer with the bytecode and the length of it. This information is specified in
a <code>VkShaderModuleCreateInfo</code> structure. The one catch is that the size of the
bytecode is specified in bytes, but the bytecode pointer is a <code>uint32_t</code> pointer
rather than a <code>char</code> pointer. Therefore we will need to cast the pointer with
<code>reinterpret_cast</code> as shown below. When you perform a cast like this, you also
need to ensure that the data satisfies the alignment requirements of <code>uint32_t</code>.
Lucky for us, the data is stored in an <code>std::vector</code> where the default allocator
already ensures that the data satisfies the worst case alignment requirements.</p>
<pre class="hljs"><code><div>VkShaderModuleCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
createInfo.codeSize = code.<span class="hljs-built_in">size</span>();
createInfo.pCode = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span>*&gt;(code.data());
</div></code></pre>
<p>The <code>VkShaderModule</code> can then be created with a call to <code>vkCreateShaderModule</code>:</p>
<pre class="hljs"><code><div>VkShaderModule shaderModule;
<span class="hljs-keyword">if</span> (vkCreateShaderModule(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;shaderModule) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create shader module!"</span>);
}
</div></code></pre>
<p>The parameters are the same as those in previous object creation functions: the
logical device, pointer to create info structure, optional pointer to custom
allocators and handle output variable. The buffer with the code can be freed
immediately after creating the shader module. Don't forget to return the created
shader module:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">return</span> shaderModule;
</div></code></pre>
<p>Shader modules are just a thin wrapper around the shader bytecode that we've previously loaded from a file and the functions defined in it. The compilation and linking of the SPIR-V bytecode to machine code for execution by the GPU doesn't happen until the graphics pipeline is created. That means that we're allowed to destroy the shader modules again as soon as pipeline creation is finished, which is why we'll make them local variables in the <code>createGraphicsPipeline</code> function instead of class members:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> vertShaderCode = readFile(<span class="hljs-string">"shaders/vert.spv"</span>);
    <span class="hljs-keyword">auto</span> fragShaderCode = readFile(<span class="hljs-string">"shaders/frag.spv"</span>);

    VkShaderModule vertShaderModule = createShaderModule(vertShaderCode);
    VkShaderModule fragShaderModule = createShaderModule(fragShaderCode);
</div></code></pre>
<p>The cleanup should then happen at the end of the function by adding two calls to <code>vkDestroyShaderModule</code>. All of the remaining code in this chapter will be inserted before these lines.</p>
<pre class="hljs"><code><div>    ...
    vkDestroyShaderModule(device, fragShaderModule, <span class="hljs-literal">nullptr</span>);
    vkDestroyShaderModule(device, vertShaderModule, <span class="hljs-literal">nullptr</span>);
}
</div></code></pre>
<h4 id="shader-stage-creation">Shader stage creation</h4>
<p>To actually use the shaders we'll need to assign them to a specific pipeline stage through <code>VkPipelineShaderStageCreateInfo</code> structures as part of the actual pipeline creation process.</p>
<p>We'll start by filling in the structure for the vertex shader, again in the
<code>createGraphicsPipeline</code> function.</p>
<pre class="hljs"><code><div>VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
</div></code></pre>
<p>The first step, besides the obligatory <code>sType</code> member, is telling Vulkan in
which pipeline stage the shader is going to be used. There is an enum value for
each of the programmable stages described in the previous chapter.</p>
<pre class="hljs"><code><div>vertShaderStageInfo.<span class="hljs-keyword">module</span> = vertShaderModule;
vertShaderStageInfo.pName = <span class="hljs-string">"main"</span>;
</div></code></pre>
<p>The next two members specify the shader module containing the code, and the
function to invoke, known as the <em>entrypoint</em>. That means that it's possible to combine multiple fragment
shaders into a single shader module and use different entry points to
differentiate between their behaviors. In this case we'll stick to the standard
<code>main</code>, however.</p>
<p>There is one more (optional) member, <code>pSpecializationInfo</code>, which we won't be
using here, but is worth discussing. It allows you to specify values for shader
constants. You can use a single shader module where its behavior can be
configured at pipeline creation by specifying different values for the constants
used in it. This is more efficient than configuring the shader using variables
at render time, because the compiler can do optimizations like eliminating <code>if</code>
statements that depend on these values. If you don't have any constants like
that, then you can set the member to <code>nullptr</code>, which our struct initialization
does automatically.</p>
<p>Modifying the structure to suit the fragment shader is easy:</p>
<pre class="hljs"><code><div>VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
fragShaderStageInfo.<span class="hljs-keyword">module</span> = fragShaderModule;
fragShaderStageInfo.pName = <span class="hljs-string">"main"</span>;
</div></code></pre>
<p>Finish by defining an array that contains these two structs, which we'll later
use to reference them in the actual pipeline creation step.</p>
<pre class="hljs"><code><div>VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};
</div></code></pre>
<p>That's all there is to describing the programmable stages of the pipeline. In
the next chapter we'll look at the fixed-function stages.</p>
<p><a href="/code/09_shader_modules.cpp">C++ code</a> /
<a href="/code/09_shader_base.vert">Vertex shader</a> /
<a href="/code/09_shader_base.frag">Fragment shader</a></p>
<h3 id="02fixedfunctions">02_Fixed_functions</h3>
<p>The older graphics APIs provided default state for most of the stages of the
graphics pipeline. In Vulkan you have to be explicit about everything, from
viewport size to color blending function. In this chapter we'll fill in all of
the structures to configure these fixed-function operations.</p>
<h4 id="vertex-input">Vertex input</h4>
<p>The <code>VkPipelineVertexInputStateCreateInfo</code> structure describes the format of the
vertex data that will be passed to the vertex shader. It describes this in
roughly two ways:</p>
<ul>
<li>Bindings: spacing between data and whether the data is per-vertex or
per-instance (see <a href="https://en.wikipedia.org/wiki/Geometry_instancing">instancing</a>)</li>
<li>Attribute descriptions: type of the attributes passed to the vertex shader,
which binding to load them from and at which offset</li>
</ul>
<p>Because we're hard coding the vertex data directly in the vertex shader, we'll
fill in this structure to specify that there is no vertex data to load for now.
We'll get back to it in the vertex buffer chapter.</p>
<pre class="hljs"><code><div>VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
vertexInputInfo.vertexBindingDescriptionCount = <span class="hljs-number">0</span>;
vertexInputInfo.pVertexBindingDescriptions = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
vertexInputInfo.vertexAttributeDescriptionCount = <span class="hljs-number">0</span>;
vertexInputInfo.pVertexAttributeDescriptions = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>The <code>pVertexBindingDescriptions</code> and <code>pVertexAttributeDescriptions</code> members
point to an array of structs that describe the aforementioned details for
loading vertex data. Add this structure to the <code>createGraphicsPipeline</code> function
right after the <code>shaderStages</code> array.</p>
<h4 id="input-assembly">Input assembly</h4>
<p>The <code>VkPipelineInputAssemblyStateCreateInfo</code> struct describes two things: what
kind of geometry will be drawn from the vertices and if primitive restart should
be enabled. The former is specified in the <code>topology</code> member and can have values
like:</p>
<ul>
<li><code>VK_PRIMITIVE_TOPOLOGY_POINT_LIST</code>: points from vertices</li>
<li><code>VK_PRIMITIVE_TOPOLOGY_LINE_LIST</code>: line from every 2 vertices without reuse</li>
<li><code>VK_PRIMITIVE_TOPOLOGY_LINE_STRIP</code>: the end vertex of every line is used as
start vertex for the next line</li>
<li><code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code>: triangle from every 3 vertices without
reuse</li>
<li><code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP </code>: the second and third vertex of every
triangle are used as first two vertices of the next triangle</li>
</ul>
<p>Normally, the vertices are loaded from the vertex buffer by index in sequential
order, but with an <em>element buffer</em> you can specify the indices to use yourself.
This allows you to perform optimizations like reusing vertices. If you set the
<code>primitiveRestartEnable</code>  member to <code>VK_TRUE</code>, then it's possible to break up
lines and triangles in the <code>_STRIP</code> topology modes by using a special index of
<code>0xFFFF</code> or <code>0xFFFFFFFF</code>.</p>
<p>We intend to draw triangles throughout this tutorial, so we'll stick to the
following data for the structure:</p>
<pre class="hljs"><code><div>VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
inputAssembly.primitiveRestartEnable = VK_FALSE;
</div></code></pre>
<h4 id="viewports-and-scissors">Viewports and scissors</h4>
<p>A viewport basically describes the region of the framebuffer that the output
will be rendered to. This will almost always be <code>(0, 0)</code> to <code>(width, height)</code>
and in this tutorial that will also be the case.</p>
<pre class="hljs"><code><div>VkViewport viewport{};
viewport.x = <span class="hljs-number">0.0f</span>;
viewport.y = <span class="hljs-number">0.0f</span>;
viewport.<span class="hljs-built_in">width</span> = (<span class="hljs-keyword">float</span>) swapChainExtent.<span class="hljs-built_in">width</span>;
viewport.<span class="hljs-built_in">height</span> = (<span class="hljs-keyword">float</span>) swapChainExtent.<span class="hljs-built_in">height</span>;
viewport.minDepth = <span class="hljs-number">0.0f</span>;
viewport.maxDepth = <span class="hljs-number">1.0f</span>;
</div></code></pre>
<p>Remember that the size of the swap chain and its images may differ from the
<code>WIDTH</code> and <code>HEIGHT</code> of the window. The swap chain images will be used as
framebuffers later on, so we should stick to their size.</p>
<p>The <code>minDepth</code> and <code>maxDepth</code> values specify the range of depth values to use
for the framebuffer. These values must be within the <code>[0.0f, 1.0f]</code> range, but
<code>minDepth</code> may be higher than <code>maxDepth</code>. If you aren't doing anything special,
then you should stick to the standard values of <code>0.0f</code> and <code>1.0f</code>.</p>
<p>While viewports define the transformation from the image to the framebuffer,
scissor rectangles define in which regions pixels will actually be stored. Any
pixels outside the scissor rectangles will be discarded by the rasterizer. They
function like a filter rather than a transformation. The difference is
illustrated below. Note that the left scissor rectangle is just one of the many
possibilities that would result in that image, as long as it's larger than the
viewport.</p>
<p><img src="images/viewports_scissors.png" alt=""></p>
<p>In this tutorial we simply want to draw to the entire framebuffer, so we'll
specify a scissor rectangle that covers it entirely:</p>
<pre class="hljs"><code><div>VkRect2D scissor{};
scissor.offset = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>};
scissor.extent = swapChainExtent;
</div></code></pre>
<p>Now this viewport and scissor rectangle need to be combined into a viewport
state using the <code>VkPipelineViewportStateCreateInfo</code> struct. It is possible to
use multiple viewports and scissor rectangles on some graphics cards, so its
members reference an array of them. Using multiple requires enabling a GPU
feature (see logical device creation).</p>
<pre class="hljs"><code><div>VkPipelineViewportStateCreateInfo viewportState{};
viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
viewportState.viewportCount = <span class="hljs-number">1</span>;
viewportState.pViewports = &amp;viewport;
viewportState.scissorCount = <span class="hljs-number">1</span>;
viewportState.pScissors = &amp;scissor;
</div></code></pre>
<h4 id="rasterizer">Rasterizer</h4>
<p>The rasterizer takes the geometry that is shaped by the vertices from the vertex
shader and turns it into fragments to be colored by the fragment shader. It also
performs <a href="https://en.wikipedia.org/wiki/Z-buffering">depth testing</a>,
<a href="https://en.wikipedia.org/wiki/Back-face_culling">face culling</a> and the scissor
test, and it can be configured to output fragments that fill entire polygons or
just the edges (wireframe rendering). All this is configured using the
<code>VkPipelineRasterizationStateCreateInfo</code> structure.</p>
<pre class="hljs"><code><div>VkPipelineRasterizationStateCreateInfo rasterizer{};
rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
rasterizer.depthClampEnable = VK_FALSE;
</div></code></pre>
<p>If <code>depthClampEnable</code> is set to <code>VK_TRUE</code>, then fragments that are beyond the
near and far planes are clamped to them as opposed to discarding them. This is
useful in some special cases like shadow maps. Using this requires enabling a
GPU feature.</p>
<pre class="hljs"><code><div>rasterizer.rasterizerDiscardEnable = VK_FALSE;
</div></code></pre>
<p>If <code>rasterizerDiscardEnable</code> is set to <code>VK_TRUE</code>, then geometry never passes
through the rasterizer stage. This basically disables any output to the
framebuffer.</p>
<pre class="hljs"><code><div>rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
</div></code></pre>
<p>The <code>polygonMode</code> determines how fragments are generated for geometry. The
following modes are available:</p>
<ul>
<li><code>VK_POLYGON_MODE_FILL</code>: fill the area of the polygon with fragments</li>
<li><code>VK_POLYGON_MODE_LINE</code>: polygon edges are drawn as lines</li>
<li><code>VK_POLYGON_MODE_POINT</code>: polygon vertices are drawn as points</li>
</ul>
<p>Using any mode other than fill requires enabling a GPU feature.</p>
<pre class="hljs"><code><div>rasterizer.lineWidth = <span class="hljs-number">1.0f</span>;
</div></code></pre>
<p>The <code>lineWidth</code> member is straightforward, it describes the thickness of lines
in terms of number of fragments. The maximum line width that is supported
depends on the hardware and any line thicker than <code>1.0f</code> requires you to enable
the <code>wideLines</code> GPU feature.</p>
<pre class="hljs"><code><div>rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
</div></code></pre>
<p>The <code>cullMode</code> variable determines the type of face culling to use. You can
disable culling, cull the front faces, cull the back faces or both. The
<code>frontFace</code> variable specifies the vertex order for faces to be considered
front-facing and can be clockwise or counterclockwise.</p>
<pre class="hljs"><code><div>rasterizer.depthBiasEnable = VK_FALSE;
rasterizer.depthBiasConstantFactor = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span>
rasterizer.depthBiasClamp = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span>
rasterizer.depthBiasSlopeFactor = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>The rasterizer can alter the depth values by adding a constant value or biasing
them based on a fragment's slope. This is sometimes used for shadow mapping, but
we won't be using it. Just set <code>depthBiasEnable</code> to <code>VK_FALSE</code>.</p>
<h4 id="multisampling">Multisampling</h4>
<p>The <code>VkPipelineMultisampleStateCreateInfo</code> struct configures multisampling,
which is one of the ways to perform <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">anti-aliasing</a>.
It works by combining the fragment shader results of multiple polygons that
rasterize to the same pixel. This mainly occurs along edges, which is also where
the most noticeable aliasing artifacts occur. Because it doesn't need to run the
fragment shader multiple times if only one polygon maps to a pixel, it is
significantly less expensive than simply rendering to a higher resolution and
then downscaling. Enabling it requires enabling a GPU feature.</p>
<pre class="hljs"><code><div>VkPipelineMultisampleStateCreateInfo multisampling{};
multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
multisampling.sampleShadingEnable = VK_FALSE;
multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
multisampling.minSampleShading = <span class="hljs-number">1.0f</span>; <span class="hljs-comment">// Optional</span>
multisampling.pSampleMask = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
multisampling.alphaToCoverageEnable = VK_FALSE; <span class="hljs-comment">// Optional</span>
multisampling.alphaToOneEnable = VK_FALSE; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>We'll revisit multisampling in later chapter, for now let's keep it disabled.</p>
<h4 id="depth-and-stencil-testing">Depth and stencil testing</h4>
<p>If you are using a depth and/or stencil buffer, then you also need to configure
the depth and stencil tests using <code>VkPipelineDepthStencilStateCreateInfo</code>. We
don't have one right now, so we can simply pass a <code>nullptr</code> instead of a pointer
to such a struct. We'll get back to it in the depth buffering chapter.</p>
<h4 id="color-blending">Color blending</h4>
<p>After a fragment shader has returned a color, it needs to be combined with the
color that is already in the framebuffer. This transformation is known as color
blending and there are two ways to do it:</p>
<ul>
<li>Mix the old and new value to produce a final color</li>
<li>Combine the old and new value using a bitwise operation</li>
</ul>
<p>There are two types of structs to configure color blending. The first struct,
<code>VkPipelineColorBlendAttachmentState</code> contains the configuration per attached
framebuffer and the second struct, <code>VkPipelineColorBlendStateCreateInfo</code>
contains the <em>global</em> color blending settings. In our case we only have one
framebuffer:</p>
<pre class="hljs"><code><div>VkPipelineColorBlendAttachmentState colorBlendAttachment{};
colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
colorBlendAttachment.blendEnable = VK_FALSE;
colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; <span class="hljs-comment">// Optional</span>
colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="hljs-comment">// Optional</span>
colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; <span class="hljs-comment">// Optional</span>
colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; <span class="hljs-comment">// Optional</span>
colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="hljs-comment">// Optional</span>
colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>This per-framebuffer struct allows you to configure the first way of color
blending. The operations that will be performed are best demonstrated using the
following pseudocode:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (blendEnable) {
    finalColor.rgb = (srcColorBlendFactor * newColor.rgb) &lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb);
    finalColor.a = (srcAlphaBlendFactor * newColor.a) &lt;alphaBlendOp&gt; (dstAlphaBlendFactor * oldColor.a);
} <span class="hljs-keyword">else</span> {
    finalColor = newColor;
}

finalColor = finalColor &amp; colorWriteMask;
</div></code></pre>
<p>If <code>blendEnable</code> is set to <code>VK_FALSE</code>, then the new color from the fragment
shader is passed through unmodified. Otherwise, the two mixing operations are
performed to compute a new color. The resulting color is AND'd with the
<code>colorWriteMask</code> to determine which channels are actually passed through.</p>
<p>The most common way to use color blending is to implement alpha blending, where
we want the new color to be blended with the old color based on its opacity. The
<code>finalColor</code> should then be computed as follows:</p>
<pre class="hljs"><code><div>finalColor.rgb = newAlpha * newColor + (<span class="hljs-number">1</span> - newAlpha) * oldColor;
finalColor.a = newAlpha.a;
</div></code></pre>
<p>This can be accomplished with the following parameters:</p>
<pre class="hljs"><code><div>colorBlendAttachment.blendEnable = VK_TRUE;
colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;
</div></code></pre>
<p>You can find all of the possible operations in the <code>VkBlendFactor</code> and
<code>VkBlendOp</code> enumerations in the specification.</p>
<p>The second structure references the array of structures for all of the
framebuffers and allows you to set blend constants that you can use as blend
factors in the aforementioned calculations.</p>
<pre class="hljs"><code><div>VkPipelineColorBlendStateCreateInfo colorBlending{};
colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
colorBlending.logicOpEnable = VK_FALSE;
colorBlending.logicOp = VK_LOGIC_OP_COPY; <span class="hljs-comment">// Optional</span>
colorBlending.attachmentCount = <span class="hljs-number">1</span>;
colorBlending.pAttachments = &amp;colorBlendAttachment;
colorBlending.blendConstants[<span class="hljs-number">0</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span>
colorBlending.blendConstants[<span class="hljs-number">1</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span>
colorBlending.blendConstants[<span class="hljs-number">2</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span>
colorBlending.blendConstants[<span class="hljs-number">3</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>If you want to use the second method of blending (bitwise combination), then you
should set <code>logicOpEnable</code> to <code>VK_TRUE</code>. The bitwise operation can then be
specified in the <code>logicOp</code> field. Note that this will automatically disable the
first method, as if you had set <code>blendEnable</code> to <code>VK_FALSE</code> for every
attached framebuffer! The <code>colorWriteMask</code> will also be used in this mode to
determine which channels in the framebuffer will actually be affected. It is
also possible to disable both modes, as we've done here, in which case the
fragment colors will be written to the framebuffer unmodified.</p>
<h4 id="dynamic-state">Dynamic state</h4>
<p>A limited amount of the state that we've specified in the previous structs <em>can</em>
actually be changed without recreating the pipeline. Examples are the size of
the viewport, line width and blend constants. If you want to do that, then
you'll have to fill in a <code>VkPipelineDynamicStateCreateInfo</code> structure like this:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkDynamicState&gt; dynamicStates = {
    VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_LINE_WIDTH
};

VkPipelineDynamicStateCreateInfo dynamicState{};
dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
dynamicState.dynamicStateCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(dynamicStates.<span class="hljs-built_in">size</span>());
dynamicState.pDynamicStates = dynamicStates.data();
</div></code></pre>
<p>This will cause the configuration of these values to be ignored and you will be
required to specify the data at drawing time. We'll get back to this in a future
chapter. This struct can be substituted by a <code>nullptr</code> later on if you don't
have any dynamic state.</p>
<h4 id="pipeline-layout">Pipeline layout</h4>
<p>You can use <code>uniform</code> values in shaders, which are globals similar to dynamic
state variables that can be changed at drawing time to alter the behavior of
your shaders without having to recreate them. They are commonly used to pass the
transformation matrix to the vertex shader, or to create texture samplers in the
fragment shader.</p>
<p>These uniform values need to be specified during pipeline creation by creating a
<code>VkPipelineLayout</code> object. Even though we won't be using them until a future
chapter, we are still required to create an empty pipeline layout.</p>
<p>Create a class member to hold this object, because we'll refer to it from other
functions at a later point in time:</p>
<pre class="hljs"><code><div>VkPipelineLayout pipelineLayout;
</div></code></pre>
<p>And then create the object in the <code>createGraphicsPipeline</code> function:</p>
<pre class="hljs"><code><div>VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
pipelineLayoutInfo.setLayoutCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span>
pipelineLayoutInfo.pSetLayouts = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
pipelineLayoutInfo.pushConstantRangeCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span>
pipelineLayoutInfo.pPushConstantRanges = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>

<span class="hljs-keyword">if</span> (vkCreatePipelineLayout(device, &amp;pipelineLayoutInfo, <span class="hljs-literal">nullptr</span>, &amp;pipelineLayout) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create pipeline layout!"</span>);
}
</div></code></pre>
<p>The structure also specifies <em>push constants</em>, which are another way of passing
dynamic values to shaders that we may get into in a future chapter. The pipeline
layout will be referenced throughout the program's lifetime, so it should be
destroyed at the end:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    vkDestroyPipelineLayout(device, pipelineLayout, <span class="hljs-literal">nullptr</span>);
    ...
}
</div></code></pre>
<h4 id="conclusion">Conclusion</h4>
<p>That's it for all of the fixed-function state! It's a lot of work to set all of
this up from scratch, but the advantage is that we're now nearly fully aware of
everything that is going on in the graphics pipeline! This reduces the chance of
running into unexpected behavior because the default state of certain components
is not what you expect.</p>
<p>There is however one more object to create before we can finally create the
graphics pipeline and that is a <a href="!en/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes">render pass</a>.</p>
<p><a href="/code/10_fixed_functions.cpp">C++ code</a> /
<a href="/code/09_shader_base.vert">Vertex shader</a> /
<a href="/code/09_shader_base.frag">Fragment shader</a></p>
<h3 id="03renderpasses">03_Render_passes</h3>
<h4 id="setup">Setup</h4>
<p>Before we can finish creating the pipeline, we need to tell Vulkan about the
framebuffer attachments that will be used while rendering. We need to specify
how many color and depth buffers there will be, how many samples to use for each
of them and how their contents should be handled throughout the rendering
operations. All of this information is wrapped in a <em>render pass</em> object, for
which we'll create a new <code>createRenderPass</code> function. Call this function from
<code>initVulkan</code> before <code>createGraphicsPipeline</code>.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createRenderPass</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<h4 id="attachment-description">Attachment description</h4>
<p>In our case we'll have just a single color buffer attachment represented by one
of the images from the swap chain.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createRenderPass</span><span class="hljs-params">()</span> </span>{
    VkAttachmentDescription colorAttachment{};
    colorAttachment.format = swapChainImageFormat;
    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
}
</div></code></pre>
<p>The <code>format</code> of the color attachment should match the format of the swap chain
images, and we're not doing anything with multisampling yet, so we'll stick to 1
sample.</p>
<pre class="hljs"><code><div>colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
</div></code></pre>
<p>The <code>loadOp</code> and <code>storeOp</code> determine what to do with the data in the attachment
before rendering and after rendering. We have the following choices for
<code>loadOp</code>:</p>
<ul>
<li><code>VK_ATTACHMENT_LOAD_OP_LOAD</code>: Preserve the existing contents of the attachment</li>
<li><code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>: Clear the values to a constant at the start</li>
<li><code>VK_ATTACHMENT_LOAD_OP_DONT_CARE</code>: Existing contents are undefined; we don't
care about them</li>
</ul>
<p>In our case we're going to use the clear operation to clear the framebuffer to
black before drawing a new frame. There are only two possibilities for the
<code>storeOp</code>:</p>
<ul>
<li><code>VK_ATTACHMENT_STORE_OP_STORE</code>: Rendered contents will be stored in memory and
can be read later</li>
<li><code>VK_ATTACHMENT_STORE_OP_DONT_CARE</code>: Contents of the framebuffer will be
undefined after the rendering operation</li>
</ul>
<p>We're interested in seeing the rendered triangle on the screen, so we're going
with the store operation here.</p>
<pre class="hljs"><code><div>colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
</div></code></pre>
<p>The <code>loadOp</code> and <code>storeOp</code> apply to color and depth data, and <code>stencilLoadOp</code> /
<code>stencilStoreOp</code> apply to stencil data. Our application won't do anything with
the stencil buffer, so the results of loading and storing are irrelevant.</p>
<pre class="hljs"><code><div>colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
</div></code></pre>
<p>Textures and framebuffers in Vulkan are represented by <code>VkImage</code> objects with a
certain pixel format, however the layout of the pixels in memory can change
based on what you're trying to do with an image.</p>
<p>Some of the most common layouts are:</p>
<ul>
<li><code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code>: Images used as color attachment</li>
<li><code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code>: Images to be presented in the swap chain</li>
<li><code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>: Images to be used as destination for a
memory copy operation</li>
</ul>
<p>We'll discuss this topic in more depth in the texturing chapter, but what's
important to know right now is that images need to be transitioned to specific
layouts that are suitable for the operation that they're going to be involved in
next.</p>
<p>The <code>initialLayout</code> specifies which layout the image will have before the render
pass begins. The <code>finalLayout</code> specifies the layout to automatically transition
to when the render pass finishes. Using <code>VK_IMAGE_LAYOUT_UNDEFINED</code> for
<code>initialLayout</code> means that we don't care what previous layout the image was in.
The caveat of this special value is that the contents of the image are not
guaranteed to be preserved, but that doesn't matter since we're going to clear
it anyway. We want the image to be ready for presentation using the swap chain
after rendering, which is why we use <code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code> as
<code>finalLayout</code>.</p>
<h4 id="subpasses-and-attachment-references">Subpasses and attachment references</h4>
<p>A single render pass can consist of multiple subpasses. Subpasses are subsequent
rendering operations that depend on the contents of framebuffers in previous
passes, for example a sequence of post-processing effects that are applied one
after another. If you group these rendering operations into one render pass,
then Vulkan is able to reorder the operations and conserve memory bandwidth for
possibly better performance. For our very first triangle, however, we'll stick
to a single subpass.</p>
<p>Every subpass references one or more of the attachments that we've described
using the structure in the previous sections. These references are themselves
<code>VkAttachmentReference</code> structs that look like this:</p>
<pre class="hljs"><code><div>VkAttachmentReference colorAttachmentRef{};
colorAttachmentRef.attachment = <span class="hljs-number">0</span>;
colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
</div></code></pre>
<p>The <code>attachment</code> parameter specifies which attachment to reference by its index
in the attachment descriptions array. Our array consists of a single
<code>VkAttachmentDescription</code>, so its index is <code>0</code>. The <code>layout</code> specifies which
layout we would like the attachment to have during a subpass that uses this
reference. Vulkan will automatically transition the attachment to this layout
when the subpass is started. We intend to use the attachment to function as a
color buffer and the <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> layout will give
us the best performance, as its name implies.</p>
<p>The subpass is described using a <code>VkSubpassDescription</code> structure:</p>
<pre class="hljs"><code><div>VkSubpassDescription subpass{};
subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
</div></code></pre>
<p>Vulkan may also support compute subpasses in the future, so we have to be
explicit about this being a graphics subpass. Next, we specify the reference to
the color attachment:</p>
<pre class="hljs"><code><div>subpass.colorAttachmentCount = <span class="hljs-number">1</span>;
subpass.pColorAttachments = &amp;colorAttachmentRef;
</div></code></pre>
<p>The index of the attachment in this array is directly referenced from the
fragment shader with the <code>layout(location = 0) out vec4 outColor</code> directive!</p>
<p>The following other types of attachments can be referenced by a subpass:</p>
<ul>
<li><code>pInputAttachments</code>: Attachments that are read from a shader</li>
<li><code>pResolveAttachments</code>: Attachments used for multisampling color attachments</li>
<li><code>pDepthStencilAttachment</code>: Attachment for depth and stencil data</li>
<li><code>pPreserveAttachments</code>: Attachments that are not used by this subpass, but for
which the data must be preserved</li>
</ul>
<h4 id="render-pass">Render pass</h4>
<p>Now that the attachment and a basic subpass referencing it have been described,
we can create the render pass itself. Create a new class member variable to hold
the <code>VkRenderPass</code> object right above the <code>pipelineLayout</code> variable:</p>
<pre class="hljs"><code><div>VkRenderPass renderPass;
VkPipelineLayout pipelineLayout;
</div></code></pre>
<p>The render pass object can then be created by filling in the
<code>VkRenderPassCreateInfo</code> structure with an array of attachments and subpasses.
The <code>VkAttachmentReference</code> objects reference attachments using the indices of
this array.</p>
<pre class="hljs"><code><div>VkRenderPassCreateInfo renderPassInfo{};
renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
renderPassInfo.attachmentCount = <span class="hljs-number">1</span>;
renderPassInfo.pAttachments = &amp;colorAttachment;
renderPassInfo.subpassCount = <span class="hljs-number">1</span>;
renderPassInfo.pSubpasses = &amp;subpass;

<span class="hljs-keyword">if</span> (vkCreateRenderPass(device, &amp;renderPassInfo, <span class="hljs-literal">nullptr</span>, &amp;renderPass) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create render pass!"</span>);
}
</div></code></pre>
<p>Just like the pipeline layout, the render pass will be referenced throughout the
program, so it should only be cleaned up at the end:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    vkDestroyPipelineLayout(device, pipelineLayout, <span class="hljs-literal">nullptr</span>);
    vkDestroyRenderPass(device, renderPass, <span class="hljs-literal">nullptr</span>);
    ...
}
</div></code></pre>
<p>That was a lot of work, but in the next chapter it all comes together to finally
create the graphics pipeline object!</p>
<p><a href="/code/11_render_passes.cpp">C++ code</a> /
<a href="/code/09_shader_base.vert">Vertex shader</a> /
<a href="/code/09_shader_base.frag">Fragment shader</a></p>
<h3 id="04conclusion">04_Conclusion</h3>
<p>We can now combine all of the structures and objects from the previous chapters
to create the graphics pipeline! Here's the types of objects we have now, as a
quick recap:</p>
<ul>
<li>Shader stages: the shader modules that define the functionality of the
programmable stages of the graphics pipeline</li>
<li>Fixed-function state: all of the structures that define the fixed-function
stages of the pipeline, like input assembly, rasterizer, viewport and color
blending</li>
<li>Pipeline layout: the uniform and push values referenced by the shader that can
be updated at draw time</li>
<li>Render pass: the attachments referenced by the pipeline stages and their usage</li>
</ul>
<p>All of these combined fully define the functionality of the graphics pipeline,
so we can now begin filling in the <code>VkGraphicsPipelineCreateInfo</code> structure at
the end of the <code>createGraphicsPipeline</code> function. But before the calls to
<code>vkDestroyShaderModule</code> because these are still to be used during the creation.</p>
<pre class="hljs"><code><div>VkGraphicsPipelineCreateInfo pipelineInfo{};
pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
pipelineInfo.stageCount = <span class="hljs-number">2</span>;
pipelineInfo.pStages = shaderStages;
</div></code></pre>
<p>We start by referencing the array of <code>VkPipelineShaderStageCreateInfo</code> structs.</p>
<pre class="hljs"><code><div>pipelineInfo.pVertexInputState = &amp;vertexInputInfo;
pipelineInfo.pInputAssemblyState = &amp;inputAssembly;
pipelineInfo.pViewportState = &amp;viewportState;
pipelineInfo.pRasterizationState = &amp;rasterizer;
pipelineInfo.pMultisampleState = &amp;multisampling;
pipelineInfo.pDepthStencilState = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
pipelineInfo.pColorBlendState = &amp;colorBlending;
pipelineInfo.pDynamicState = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>Then we reference all of the structures describing the fixed-function stage.</p>
<pre class="hljs"><code><div>pipelineInfo.layout = pipelineLayout;
</div></code></pre>
<p>After that comes the pipeline layout, which is a Vulkan handle rather than a
struct pointer.</p>
<pre class="hljs"><code><div>pipelineInfo.renderPass = renderPass;
pipelineInfo.subpass = <span class="hljs-number">0</span>;
</div></code></pre>
<p>And finally we have the reference to the render pass and the index of the sub
pass where this graphics pipeline will be used. It is also possible to use other
render passes with this pipeline instead of this specific instance, but they
have to be <em>compatible</em> with <code>renderPass</code>. The requirements for compatibility
are described <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap8.html#renderpass-compatibility">here</a>,
but we won't be using that feature in this tutorial.</p>
<pre class="hljs"><code><div>pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; <span class="hljs-comment">// Optional</span>
pipelineInfo.basePipelineIndex = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>There are actually two more parameters: <code>basePipelineHandle</code> and
<code>basePipelineIndex</code>. Vulkan allows you to create a new graphics pipeline by
deriving from an existing pipeline. The idea of pipeline derivatives is that it
is less expensive to set up pipelines when they have much functionality in
common with an existing pipeline and switching between pipelines from the same
parent can also be done quicker. You can either specify the handle of an
existing pipeline with <code>basePipelineHandle</code> or reference another pipeline that
is about to be created by index with <code>basePipelineIndex</code>. Right now there is
only a single pipeline, so we'll simply specify a null handle and an invalid
index. These values are only used if the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code>
flag is also specified in the <code>flags</code> field of <code>VkGraphicsPipelineCreateInfo</code>.</p>
<p>Now prepare for the final step by creating a class member to hold the
<code>VkPipeline</code> object:</p>
<pre class="hljs"><code><div>VkPipeline graphicsPipeline;
</div></code></pre>
<p>And finally create the graphics pipeline:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, <span class="hljs-number">1</span>, &amp;pipelineInfo, <span class="hljs-literal">nullptr</span>, &amp;graphicsPipeline) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create graphics pipeline!"</span>);
}
</div></code></pre>
<p>The <code>vkCreateGraphicsPipelines</code> function actually has more parameters than the
usual object creation functions in Vulkan. It is designed to take multiple
<code>VkGraphicsPipelineCreateInfo</code> objects and create multiple <code>VkPipeline</code> objects
in a single call.</p>
<p>The second parameter, for which we've passed the <code>VK_NULL_HANDLE</code> argument,
references an optional <code>VkPipelineCache</code> object. A pipeline cache can be used to
store and reuse data relevant to pipeline creation across multiple calls to
<code>vkCreateGraphicsPipelines</code> and even across program executions if the cache is
stored to a file. This makes it possible to significantly speed up pipeline
creation at a later time. We'll get into this in the pipeline cache chapter.</p>
<p>The graphics pipeline is required for all common drawing operations, so it
should also only be destroyed at the end of the program:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    vkDestroyPipeline(device, graphicsPipeline, <span class="hljs-literal">nullptr</span>);
    vkDestroyPipelineLayout(device, pipelineLayout, <span class="hljs-literal">nullptr</span>);
    ...
}
</div></code></pre>
<p>Now run your program to confirm that all this hard work has resulted in a
successful pipeline creation! We are already getting quite close to seeing
something pop up on the screen. In the next couple of chapters we'll set up the
actual framebuffers from the swap chain images and prepare the drawing commands.</p>
<p><a href="/code/12_graphics_pipeline_complete.cpp">C++ code</a> /
<a href="/code/09_shader_base.vert">Vertex shader</a> /
<a href="/code/09_shader_base.frag">Fragment shader</a></p>
<h2 id="4-drawing">4. Drawing</h2>
<h3 id="00framebuffers">00_Framebuffers</h3>
<p>We've talked a lot about framebuffers in the past few chapters and we've set up
the render pass to expect a single framebuffer with the same format as the swap
chain images, but we haven't actually created any yet.</p>
<p>The attachments specified during render pass creation are bound by wrapping them
into a <code>VkFramebuffer</code> object. A framebuffer object references all of the
<code>VkImageView</code> objects that represent the attachments. In our case that will be
only a single one: the color attachment. However, the image that we have to use
for the attachment depends on which image the swap chain returns when we retrieve one
for presentation. That means that we have to create a framebuffer for all of the
images in the swap chain and use the one that corresponds to the retrieved image
at drawing time.</p>
<p>To that end, create another <code>std::vector</code> class member to hold the framebuffers:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkFramebuffer&gt; swapChainFramebuffers;
</div></code></pre>
<p>We'll create the objects for this array in a new function <code>createFramebuffers</code>
that is called from <code>initVulkan</code> right after creating the graphics pipeline:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createFramebuffers</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>Start by resizing the container to hold all of the framebuffers:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createFramebuffers</span><span class="hljs-params">()</span> </span>{
    swapChainFramebuffers.resize(swapChainImageViews.<span class="hljs-built_in">size</span>());
}
</div></code></pre>
<p>We'll then iterate through the image views and create framebuffers from them:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImageViews.<span class="hljs-built_in">size</span>(); i++) {
    VkImageView attachments[] = {
        swapChainImageViews[i]
    };

    VkFramebufferCreateInfo framebufferInfo{};
    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    framebufferInfo.renderPass = renderPass;
    framebufferInfo.attachmentCount = <span class="hljs-number">1</span>;
    framebufferInfo.pAttachments = attachments;
    framebufferInfo.<span class="hljs-built_in">width</span> = swapChainExtent.<span class="hljs-built_in">width</span>;
    framebufferInfo.<span class="hljs-built_in">height</span> = swapChainExtent.<span class="hljs-built_in">height</span>;
    framebufferInfo.layers = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (vkCreateFramebuffer(device, &amp;framebufferInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainFramebuffers[i]) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create framebuffer!"</span>);
    }
}
</div></code></pre>
<p>As you can see, creation of framebuffers is quite straightforward. We first need
to specify with which <code>renderPass</code> the framebuffer needs to be compatible. You
can only use a framebuffer with the render passes that it is compatible with,
which roughly means that they use the same number and type of attachments.</p>
<p>The <code>attachmentCount</code> and <code>pAttachments</code> parameters specify the <code>VkImageView</code>
objects that should be bound to the respective attachment descriptions in
the render pass <code>pAttachment</code> array.</p>
<p>The <code>width</code> and <code>height</code> parameters are self-explanatory and <code>layers</code> refers to
the number of layers in image arrays. Our swap chain images are single images,
so the number of layers is <code>1</code>.</p>
<p>We should delete the framebuffers before the image views and render pass that
they are based on, but only after we've finished rendering:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> framebuffer : swapChainFramebuffers) {
        vkDestroyFramebuffer(device, framebuffer, <span class="hljs-literal">nullptr</span>);
    }

    ...
}
</div></code></pre>
<p>We've now reached the milestone where we have all of the objects that are
required for rendering. In the next chapter we're going to write the first
actual drawing commands.</p>
<p><a href="/code/13_framebuffers.cpp">C++ code</a> /
<a href="/code/09_shader_base.vert">Vertex shader</a> /
<a href="/code/09_shader_base.frag">Fragment shader</a></p>
<h3 id="01commandbuffers">01_Command_buffers</h3>
<p>Commands in Vulkan, like drawing operations and memory transfers, are not
executed directly using function calls. You have to record all of the operations
you want to perform in command buffer objects. The advantage of this is that when
we are ready to tell the Vulkan what we want to do, all of the commands are
submitted together and Vulkan can more efficiently process the commands since all
of them are available together. In addition, this allows command recording to
happen in multiple threads if so desired.</p>
<h4 id="command-pools">Command pools</h4>
<p>We have to create a command pool before we can create command buffers. Command
pools manage the memory that is used to store the buffers and command buffers
are allocated from them. Add a new class member to store a <code>VkCommandPool</code>:</p>
<pre class="hljs"><code><div>VkCommandPool commandPool;
</div></code></pre>
<p>Then create a new function <code>createCommandPool</code> and call it from <code>initVulkan</code>
after the framebuffers were created.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
    createCommandPool();
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createCommandPool</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>Command pool creation only takes two parameters:</p>
<pre class="hljs"><code><div>QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice);

VkCommandPoolCreateInfo poolInfo{};
poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();
</div></code></pre>
<p>There are two possible flags for command pools:</p>
<ul>
<li><code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code>: Hint that command buffers are
rerecorded with new commands very often (may change memory allocation behavior)</li>
<li><code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code>: Allow command buffers to be
rerecorded individually, without this flag they all have to be reset together</li>
</ul>
<p>We will be recording a command buffer every frame, so we want to be able to
reset and rerecord over it. Thus, we need to set the
<code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code> flag bit for our command pool.</p>
<p>Command buffers are executed by submitting them on one of the device queues,
like the graphics and presentation queues we retrieved. Each command pool can
only allocate command buffers that are submitted on a single type of queue.
We're going to record commands for drawing, which is why we've chosen the
graphics queue family.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkCreateCommandPool(device, &amp;poolInfo, <span class="hljs-literal">nullptr</span>, &amp;commandPool) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create command pool!"</span>);
}
</div></code></pre>
<p>Finish creating the command pool using the <code>vkCreateCommandPool</code> function. It
doesn't have any special parameters. Commands will be used throughout the
program to draw things on the screen, so the pool should only be destroyed at
the end:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    vkDestroyCommandPool(device, commandPool, <span class="hljs-literal">nullptr</span>);

    ...
}
</div></code></pre>
<h4 id="command-buffer-allocation">Command buffer allocation</h4>
<p>We can now start allocating command buffers.</p>
<p>Create a <code>VkCommandBuffer</code> object as a class member. Command buffers
will be automatically freed when their command pool is destroyed, so we don't
need explicit cleanup.</p>
<pre class="hljs"><code><div>VkCommandBuffer commandBuffer;
</div></code></pre>
<p>We'll now start working on a <code>createCommandBuffer</code> function to allocate a single
command buffer from the command pool.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
    createCommandPool();
    createCommandBuffer();
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createCommandBuffer</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>Command buffers are allocated with the <code>vkAllocateCommandBuffers</code> function,
which takes a <code>VkCommandBufferAllocateInfo</code> struct as parameter that specifies
the command pool and number of buffers to allocate:</p>
<pre class="hljs"><code><div>VkCommandBufferAllocateInfo allocInfo{};
allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
allocInfo.commandPool = commandPool;
allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
allocInfo.commandBufferCount = <span class="hljs-number">1</span>;

<span class="hljs-keyword">if</span> (vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to allocate command buffers!"</span>);
}
</div></code></pre>
<p>The <code>level</code> parameter specifies if the allocated command buffers are primary or
secondary command buffers.</p>
<ul>
<li><code>VK_COMMAND_BUFFER_LEVEL_PRIMARY</code>: Can be submitted to a queue for execution,
but cannot be called from other command buffers.</li>
<li><code>VK_COMMAND_BUFFER_LEVEL_SECONDARY</code>: Cannot be submitted directly, but can be
called from primary command buffers.</li>
</ul>
<p>We won't make use of the secondary command buffer functionality here, but you
can imagine that it's helpful to reuse common operations from primary command
buffers.</p>
<p>Since we are only allocating one command buffer, the <code>commandBufferCount</code> parameter
is just one.</p>
<h4 id="command-buffer-recording">Command buffer recording</h4>
<p>We'll now start working on the <code>recordCommandBuffer</code> function that writes the
commands we want to execute into a command buffer. The <code>VkCommandBuffer</code> used
will be passed in as a parameter, as well as the index of the current swapchain
image we want to write to.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recordCommandBuffer</span><span class="hljs-params">(VkCommandBuffer commandBuffer, <span class="hljs-keyword">uint32_t</span> imageIndex)</span> </span>{

}
</div></code></pre>
<p>We always begin recording a command buffer by calling <code>vkBeginCommandBuffer</code>
with a small <code>VkCommandBufferBeginInfo</code> structure as argument that specifies
some details about the usage of this specific command buffer.</p>
<pre class="hljs"><code><div>VkCommandBufferBeginInfo beginInfo{};
beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
beginInfo.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span>
beginInfo.pInheritanceInfo = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>

<span class="hljs-keyword">if</span> (vkBeginCommandBuffer(commandBuffer, &amp;beginInfo) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to begin recording command buffer!"</span>);
}
</div></code></pre>
<p>The <code>flags</code> parameter specifies how we're going to use the command buffer. The
following values are available:</p>
<ul>
<li><code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code>: The command buffer will be
rerecorded right after executing it once.</li>
<li><code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code>: This is a secondary
command buffer that will be entirely within a single render pass.</li>
<li><code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code>: The command buffer can be
resubmitted while it is also already pending execution.</li>
</ul>
<p>None of these flags are applicable for us right now.</p>
<p>The <code>pInheritanceInfo</code> parameter is only relevant for secondary command buffers.
It specifies which state to inherit from the calling primary command buffers.</p>
<p>If the command buffer was already recorded once, then a call to
<code>vkBeginCommandBuffer</code> will implicitly reset it. It's not possible to append
commands to a buffer at a later time.</p>
<h4 id="starting-a-render-pass">Starting a render pass</h4>
<p>Drawing starts by beginning the render pass with <code>vkCmdBeginRenderPass</code>. The
render pass is configured using some parameters in a <code>VkRenderPassBeginInfo</code>
struct.</p>
<pre class="hljs"><code><div>VkRenderPassBeginInfo renderPassInfo{};
renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
renderPassInfo.renderPass = renderPass;
renderPassInfo.framebuffer = swapChainFramebuffers[imageIndex];
</div></code></pre>
<p>The first parameters are the render pass itself and the attachments to bind. We
created a framebuffer for each swap chain image where it is specified as a color
attachment. Thus we need to bind the framebuffer for the swapchain image we want
to draw to. Using the imageIndex parameter which was passed in, we can pick the
right framebuffer for the current swapchain image.</p>
<pre class="hljs"><code><div>renderPassInfo.renderArea.offset = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>};
renderPassInfo.renderArea.extent = swapChainExtent;
</div></code></pre>
<p>The next two parameters define the size of the render area. The render area
defines where shader loads and stores will take place. The pixels outside this
region will have undefined values. It should match the size of the attachments
for best performance.</p>
<pre class="hljs"><code><div>VkClearValue clearColor = {{{<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}}};
renderPassInfo.clearValueCount = <span class="hljs-number">1</span>;
renderPassInfo.pClearValues = &amp;clearColor;
</div></code></pre>
<p>The last two parameters define the clear values to use for
<code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>, which we used as load operation for the color
attachment. I've defined the clear color to simply be black with 100% opacity.</p>
<pre class="hljs"><code><div>vkCmdBeginRenderPass(commandBuffer, &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);
</div></code></pre>
<p>The render pass can now begin. All of the functions that record commands can be
recognized by their <code>vkCmd</code> prefix. They all return <code>void</code>, so there will be no
error handling until we've finished recording.</p>
<p>The first parameter for every command is always the command buffer to record the
command to. The second parameter specifies the details of the render pass we've
just provided. The final parameter controls how the drawing commands within the
render pass will be provided. It can have one of two values:</p>
<ul>
<li><code>VK_SUBPASS_CONTENTS_INLINE</code>: The render pass commands will be embedded in
the primary command buffer itself and no secondary command buffers will be
executed.</li>
<li><code>VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS</code>: The render pass commands will
be executed from secondary command buffers.</li>
</ul>
<p>We will not be using secondary command buffers, so we'll go with the first
option.</p>
<h4 id="basic-drawing-commands">Basic drawing commands</h4>
<p>We can now bind the graphics pipeline:</p>
<pre class="hljs"><code><div>vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
</div></code></pre>
<p>The second parameter specifies if the pipeline object is a graphics or compute
pipeline. We've now told Vulkan which operations to execute in the graphics
pipeline and which attachment to use in the fragment shader, so all that remains
is telling it to draw the triangle:</p>
<pre class="hljs"><code><div>vkCmdDraw(commandBuffer, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</div></code></pre>
<p>The actual <code>vkCmdDraw</code> function is a bit anticlimactic, but it's so simple
because of all the information we specified in advance. It has the following
parameters, aside from the command buffer:</p>
<ul>
<li><code>vertexCount</code>: Even though we don't have a vertex buffer, we technically still
have 3 vertices to draw.</li>
<li><code>instanceCount</code>: Used for instanced rendering, use <code>1</code> if you're not doing
that.</li>
<li><code>firstVertex</code>: Used as an offset into the vertex buffer, defines the lowest
value of <code>gl_VertexIndex</code>.</li>
<li><code>firstInstance</code>: Used as an offset for instanced rendering, defines the lowest
value of <code>gl_InstanceIndex</code>.</li>
</ul>
<h4 id="finishing-up">Finishing up</h4>
<p>The render pass can now be ended:</p>
<pre class="hljs"><code><div>vkCmdEndRenderPass(commandBuffer);
</div></code></pre>
<p>And we've finished recording the command buffer:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to record command buffer!"</span>);
}
</div></code></pre>
<p>In the next chapter we'll write the code for the main loop, which will acquire
an image from the swap chain, record and execute a command buffer, then return the
finished image to the swap chain.</p>
<p><a href="/code/14_command_buffers.cpp">C++ code</a> /
<a href="/code/09_shader_base.vert">Vertex shader</a> /
<a href="/code/09_shader_base.frag">Fragment shader</a></p>
<h3 id="02renderingandpresentation">02_Rendering_and_presentation</h3>
<p>This is the chapter where everything is going to come together. We're going to
write the <code>drawFrame</code> function that will be called from the main loop to put the
triangle on the screen. Let's start by creating the function and call it from
<code>mainLoop</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        drawFrame();
    }
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<h4 id="outline-of-a-frame">Outline of a frame</h4>
<p>At a high level, rendering a frame in Vulkan consists of a common set of steps:</p>
<ul>
<li>Wait for the previous frame to finish</li>
<li>Acquire an image from the swap chain</li>
<li>Record a command buffer which draws the scene onto that image</li>
<li>Submit the recorded command buffer</li>
<li>Present the swap chain image</li>
</ul>
<p>While we will expand the drawing function in later chapters, for now this is the
core of our render loop.</p>
<!-- Add an image that shows an outline of the frame -->
<h4 id="synchronization">Synchronization</h4>
<!-- Maybe add images for showing synchronization -->
<p>A core design philosophy in Vulkan is that synchronization of execution on
the GPU is explicit. The order of operations is up to us to define using various
synchronization primitives which tell the driver the order we want things to run
in. This means that many Vulkan API calls which start executing work on the GPU
are asynchronous, the functions will return before the operation has finished.</p>
<p>In this chapter there are a number of events that we need to order explicitly
because they happen on the GPU, such as:</p>
<ul>
<li>Acquire an image from the swap chain</li>
<li>Execute commands that draw onto the acquired image</li>
<li>Present that image to the screen for presentation, returning it to the swapchain</li>
</ul>
<p>Each of these events is set in motion using a single function call, but are all
executed asynchronously. The function calls will return before the operations
are actually finished and the order of execution is also undefined. That is
unfortunate, because each of the operations depends on the previous one
finishing. Thus we need to explore which primitives we can use to achieve
the desired ordering.</p>
<h5 id="semaphores">Semaphores</h5>
<p>A semaphore is used to add order between queue operations. Queue operations
refer to the work we submit to a queue, either in a command buffer or from
within a function as we will see later. Examples of queues are the graphics
queue and the presentation queue. Semaphores are used both to order work inside
the same queue and between different queues.</p>
<p>There happens to be two kinds of semaphores in Vulkan, binary and timeline.
Because only binary semaphores will be used in this tutorial, we will not
discuss timeline semaphores. Further mention of the term semaphore exclusively
refers to binary semaphores.</p>
<p>A semaphore is either unsignaled or signaled. It begins life as unsignaled. The
way we use a semaphore to order queue operations is by providing the same
semaphore as a 'signal' semaphore in one queue operation and as a 'wait'
semaphore in another queue operation. For example, lets say we have semaphore S
and queue operations A and B that we want to execute in order. What we tell
Vulkan is that operation A will 'signal' semaphore S when it finishes executing,
and operation B will 'wait' on semaphore S before it begins executing. When
operation A finishes, semaphore S will be signaled, while operation B wont
start until S is signaled. After operation B begins executing, semaphore S
is automatically reset back to being unsignaled, allowing it to be used again.</p>
<p>Pseudo-code of what was just described:</p>
<pre class="hljs"><code><div>VkCommandBuffer A, B = ... // record command buffers
VkSemaphore S = ... // create a semaphore

// enqueue A, signal S when done - starts executing immediately
vkQueueSubmit(work: A, signal: S, wait: None)

// enqueue B, wait on S to start
vkQueueSubmit(work: B, signal: None, wait: S)
</div></code></pre>
<p>Note that in this code snippet, both calls to <code>vkQueueSubmit()</code> return
immediately - the waiting only happens on the GPU. The CPU continues running
without blocking. To make the CPU wait, we need a different synchronization
primitive, which we will now describe.</p>
<h5 id="fences">Fences</h5>
<p>A fence has a similar purpose, in that it is used to synchronize execution, but
it is for ordering the execution on the CPU, otherwise known as the host.
Simply put, if the host needs to know when the GPU has finished something, we
use a fence.</p>
<p>Similar to semaphores, fences are either in a signaled or unsignaled state.
Whenever we submit work to execute, we can attach a fence to that work. When
the work is finished, the fence will be signaled. Then we can make the host
wait for the fence to be signaled, guaranteeing that the work has finished
before the host continues.</p>
<p>A concrete example is taking a screenshot. Say we have already done the
necessary work on the GPU. Now need to transfer the image from the GPU over
to the host and then save the memory to a file. We have command buffer A which
executes the transfer and fence F. We submit command buffer A with fence F,
then immediately tell the host to wait for F to signal. This causes the host to
block until command buffer A finishes execution. Thus we are safe to let the
host save the file to disk, as the memory transfer has completed.</p>
<p>Pseudo-code for what was described:</p>
<pre class="hljs"><code><div>VkCommandBuffer A = ... // record command buffer with the transfer
VkFence F = ... // create the fence

// enqueue A, start work immediately, signal F when done
vkQueueSubmit(work: A, fence: F)

vkWaitForFence(F) // blocks execution until A has finished executing

save_screenshot_to_disk() // can't run until the transfer has finished
</div></code></pre>
<p>Unlike the semaphore example, this example <em>does</em> block host execution. This
means the host won't do anything except wait until execution has finished. For
this case, we had to make sure the transfer was complete before we could save
the screenshot to disk.</p>
<p>In general, it is preferable to not block the host unless necessary. We want to
feed the GPU and the host with useful work to do. Waiting on fences to signal
is not useful work. Thus we prefer semaphores, or other synchronization
primitives not yet covered, to synchronize our work.</p>
<p>Fences must be reset manually to put them back into the unsignaled state. This
is because fences are used to control the execution of the host, and so the
host gets to decide when to reset the fence. Contrast this to semaphores which
are used to order work on the GPU without the host being involved.</p>
<p>In summary, semaphores are used to specify the execution order of operations on
the GPU while fences are used to keep the CPU and GPU in sync with each-other.</p>
<h5 id="what-to-choose">What to choose?</h5>
<p>We have two synchronization primitives to use and conveniently two places to
apply synchronization: Swapchain operations and waiting for the previous frame
to finish. We want to use semaphores for swapchain operations because they
happen on the GPU, thus we don't want to make the host wait around if we can
help it. For waiting on the previous frame to finish, we want to use fences
for the opposite reason, because we need the host to wait. This is so we don't
draw more than one frame at a time. Because we re-record the command buffer
every frame, we cannot record the next frame's work to the command buffer
until the current frame has finished executing, as we don't want to overwrite
the current contents of the command buffer while the GPU is using it.</p>
<h4 id="creating-the-synchronization-objects">Creating the synchronization objects</h4>
<p>We'll need one semaphore to signal that an image has been acquired from the
swapchain and is ready for rendering, another one to signal that rendering has
finished and presentation can happen, and a fence to make sure only one frame
is rendering at a time.</p>
<p>Create three class members to store these semaphore objects and fence object:</p>
<pre class="hljs"><code><div>VkSemaphore imageAvailableSemaphore;
VkSemaphore renderFinishedSemaphore;
VkFence inFlightFence;
</div></code></pre>
<p>To create the semaphores, we'll add the last <code>create</code> function for this part of
the tutorial: <code>createSyncObjects</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
    createCommandPool();
    createCommandBuffer();
    createSyncObjects();
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createSyncObjects</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>Creating semaphores requires filling in the <code>VkSemaphoreCreateInfo</code>, but in the
current version of the API it doesn't actually have any required fields besides
<code>sType</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createSyncObjects</span><span class="hljs-params">()</span> </span>{
    VkSemaphoreCreateInfo semaphoreInfo{};
    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
}
</div></code></pre>
<p>Future versions of the Vulkan API or extensions may add functionality for the
<code>flags</code> and <code>pNext</code> parameters like it does for the other structures.</p>
<p>Creating a fence requires filling in the <code>VkFenceCreateInfo</code>:</p>
<pre class="hljs"><code><div>VkFenceCreateInfo fenceInfo{};
fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
</div></code></pre>
<p>Creating the semaphores and fence follows the familiar pattern with
<code>vkCreateSemaphore</code> &amp; <code>vkCreateFence</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkCreateSemaphore(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;imageAvailableSemaphore) != VK_SUCCESS ||
    vkCreateSemaphore(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;renderFinishedSemaphore) != VK_SUCCESS ||
    vkCreateFence(device, &amp;fenceInfo, <span class="hljs-literal">nullptr</span>, &amp;inFlightFence) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create semaphores!"</span>);
}
</div></code></pre>
<p>The semaphores and fence should be cleaned up at the end of the program, when
all commands have finished and no more synchronization is necessary:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    vkDestroySemaphore(device, imageAvailableSemaphore, <span class="hljs-literal">nullptr</span>);
    vkDestroySemaphore(device, renderFinishedSemaphore, <span class="hljs-literal">nullptr</span>);
    vkDestroyFence(device, inFlightFence, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<p>Onto the main drawing function!</p>
<h4 id="waiting-for-the-previous-frame">Waiting for the previous frame</h4>
<p>At the start of the frame, we want to wait until the previous frame has
finished, so that the command buffer and semaphores are available to use. To do
that, we call <code>vkWaitForFences</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>{
    vkWaitForFences(device, <span class="hljs-number">1</span>, &amp;inFlightFence, VK_TRUE, UINT64_MAX);
}
</div></code></pre>
<p>The <code>vkWaitForFences</code> function takes an array of fences and waits on the host
for either any or all of the fences to be signaled before returning. The
<code>VK_TRUE</code> we pass here indicates that we want to wait for all fences, but in
the case of a single one it doesn't matter. This function also has a timeout
parameter that we set to the maximum value of a 64 bit unsigned integer,
<code>UINT64_MAX</code>, which effectively disables the timeout.</p>
<p>After waiting, we need to manually reset the fence to the unsignaled state with
the <code>vkResetFences</code> call:</p>
<pre class="hljs"><code><div>    vkResetFences(device, <span class="hljs-number">1</span>, &amp;inFlightFence);
</div></code></pre>
<p>Before we can proceed, there is a slight hiccup in our design. On the first
frame we call <code>drawFrame()</code>, which immediately waits on <code>inFlightFence</code> to
be signaled. <code>inFlightFence</code> is only signaled after a frame has finished
rendering, yet since this is the first frame, there are no previous frames in
which to signal the fence! Thus <code>vkWaitForFences()</code> blocks indefinitely,
waiting on something which will never happen.</p>
<p>Of the many solutions to this dilemma, there is a clever workaround built into
the API. Create the fence in the signaled state, so that the first call to
<code>vkWaitForFences()</code> returns immediately since the fence is already signaled.</p>
<p>To do this, we add the <code>VK_FENCE_CREATE_SIGNALED_BIT</code> flag to the <code>VkFenceCreateInfo</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createSyncObjects</span><span class="hljs-params">()</span> </span>{
    ...

    VkFenceCreateInfo fenceInfo{};
    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

    ...
}
</div></code></pre>
<h4 id="acquiring-an-image-from-the-swap-chain">Acquiring an image from the swap chain</h4>
<p>The next thing we need to do in the <code>drawFrame</code> function is acquire an image
from the swap chain. Recall that the swap chain is an extension feature, so we
must use a function with the <code>vk*KHR</code> naming convention:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">uint32_t</span> imageIndex;
    vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);
}
</div></code></pre>
<p>The first two parameters of <code>vkAcquireNextImageKHR</code> are the logical device and
the swap chain from which we wish to acquire an image. The third parameter
specifies a timeout in nanoseconds for an image to become available. Using the
maximum value of a 64 bit unsigned integer means we effectively disable the
timeout.</p>
<p>The next two parameters specify synchronization objects that are to be signaled
when the presentation engine is finished using the image. That's the point in
time where we can start drawing to it. It is possible to specify a semaphore,
fence or both. We're going to use our <code>imageAvailableSemaphore</code> for that purpose
here.</p>
<p>The last parameter specifies a variable to output the index of the swap chain
image that has become available. The index refers to the <code>VkImage</code> in our
<code>swapChainImages</code> array. We're going to use that index to pick the <code>VkFrameBuffer</code>.</p>
<h4 id="recording-the-command-buffer">Recording the command buffer</h4>
<p>With the imageIndex specifying the swap chain image to use in hand, we can now
record the command buffer. First, we call <code>vkResetCommandBuffer</code> on the command
buffer to make sure it is able to be recorded.</p>
<pre class="hljs"><code><div>vkResetCommandBuffer(commandBuffer, <span class="hljs-number">0</span>);
</div></code></pre>
<p>The second parameter of <code>vkResetCommandBuffer</code> is a <code>VkCommandBufferResetFlagBits</code>
flag. Since we don't want to do anything special, we leave it as 0.</p>
<p>Now call the function <code>recordCommandBuffer</code> to record the commands we want.</p>
<pre class="hljs"><code><div>recordCommandBuffer(commandBuffer, imageIndex);
</div></code></pre>
<p>With a fully recorded command buffer, we can now submit it.</p>
<h4 id="submitting-the-command-buffer">Submitting the command buffer</h4>
<p>Queue submission and synchronization is configured through parameters in the
<code>VkSubmitInfo</code> structure.</p>
<pre class="hljs"><code><div>VkSubmitInfo submitInfo{};
submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

VkSemaphore waitSemaphores[] = {imageAvailableSemaphore};
VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
submitInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;
submitInfo.pWaitSemaphores = waitSemaphores;
submitInfo.pWaitDstStageMask = waitStages;
</div></code></pre>
<p>The first three parameters specify which semaphores to wait on before execution
begins and in which stage(s) of the pipeline to wait. We want to wait with
writing colors to the image until it's available, so we're specifying the stage
of the graphics pipeline that writes to the color attachment. That means that
theoretically the implementation can already start executing our vertex shader
and such while the image is not yet available. Each entry in the <code>waitStages</code>
array corresponds to the semaphore with the same index in <code>pWaitSemaphores</code>.</p>
<pre class="hljs"><code><div>submitInfo.commandBufferCount = <span class="hljs-number">1</span>;
submitInfo.pCommandBuffers = &amp;commandBuffer;
</div></code></pre>
<p>The next two parameters specify which command buffers to actually submit for
execution. We simply submit the single command buffer we have.</p>
<pre class="hljs"><code><div>VkSemaphore signalSemaphores[] = {renderFinishedSemaphore};
submitInfo.signalSemaphoreCount = <span class="hljs-number">1</span>;
submitInfo.pSignalSemaphores = signalSemaphores;
</div></code></pre>
<p>The <code>signalSemaphoreCount</code> and <code>pSignalSemaphores</code> parameters specify which
semaphores to signal once the command buffer(s) have finished execution. In our
case we're using the <code>renderFinishedSemaphore</code> for that purpose.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkQueueSubmit(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFence) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to submit draw command buffer!"</span>);
}
</div></code></pre>
<p>We can now submit the command buffer to the graphics queue using
<code>vkQueueSubmit</code>. The function takes an array of <code>VkSubmitInfo</code> structures as
argument for efficiency when the workload is much larger. The last parameter
references an optional fence that will be signaled when the command buffers
finish execution. This allows us to know when it is safe for the command
buffer to be reused, thus we want to give it <code>inFlightFence</code>. Now on the next
frame, the CPU will wait for this command buffer to finish executing before it
records new commands into it.</p>
<h4 id="subpass-dependencies">Subpass dependencies</h4>
<p>Remember that the subpasses in a render pass automatically take care of image
layout transitions. These transitions are controlled by <em>subpass dependencies</em>,
which specify memory and execution dependencies between subpasses. We have only
a single subpass right now, but the operations right before and right after this
subpass also count as implicit &quot;subpasses&quot;.</p>
<p>There are two built-in dependencies that take care of the transition at the
start of the render pass and at the end of the render pass, but the former does
not occur at the right time. It assumes that the transition occurs at the start
of the pipeline, but we haven't acquired the image yet at that point! There are
two ways to deal with this problem. We could change the <code>waitStages</code> for the
<code>imageAvailableSemaphore</code> to <code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code> to ensure that
the render passes don't begin until the image is available, or we can make the
render pass wait for the <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> stage.
I've decided to go with the second option here, because it's a good excuse to
have a look at subpass dependencies and how they work.</p>
<p>Subpass dependencies are specified in <code>VkSubpassDependency</code> structs. Go to the
<code>createRenderPass</code> function and add one:</p>
<pre class="hljs"><code><div>VkSubpassDependency dependency{};
dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
dependency.dstSubpass = <span class="hljs-number">0</span>;
</div></code></pre>
<p>The first two fields specify the indices of the dependency and the dependent
subpass. The special value <code>VK_SUBPASS_EXTERNAL</code> refers to the implicit subpass
before or after the render pass depending on whether it is specified in
<code>srcSubpass</code> or <code>dstSubpass</code>. The index <code>0</code> refers to our subpass, which is the
first and only one. The <code>dstSubpass</code> must always be higher than <code>srcSubpass</code> to
prevent cycles in the dependency graph (unless one of the subpasses is
<code>VK_SUBPASS_EXTERNAL</code>).</p>
<pre class="hljs"><code><div>dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
dependency.srcAccessMask = <span class="hljs-number">0</span>;
</div></code></pre>
<p>The next two fields specify the operations to wait on and the stages in which
these operations occur. We need to wait for the swap chain to finish reading
from the image before we can access it. This can be accomplished by waiting on
the color attachment output stage itself.</p>
<pre class="hljs"><code><div>dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
</div></code></pre>
<p>The operations that should wait on this are in the color attachment stage and
involve the writing of the color attachment. These settings will
prevent the transition from happening until it's actually necessary (and
allowed): when we want to start writing colors to it.</p>
<pre class="hljs"><code><div>renderPassInfo.dependencyCount = <span class="hljs-number">1</span>;
renderPassInfo.pDependencies = &amp;dependency;
</div></code></pre>
<p>The <code>VkRenderPassCreateInfo</code> struct has two fields to specify an array of
dependencies.</p>
<h4 id="presentation">Presentation</h4>
<p>The last step of drawing a frame is submitting the result back to the swap chain
to have it eventually show up on the screen. Presentation is configured through
a <code>VkPresentInfoKHR</code> structure at the end of the <code>drawFrame</code> function.</p>
<pre class="hljs"><code><div>VkPresentInfoKHR presentInfo{};
presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

presentInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;
presentInfo.pWaitSemaphores = signalSemaphores;
</div></code></pre>
<p>The first two parameters specify which semaphores to wait on before presentation
can happen, just like <code>VkSubmitInfo</code>. Since we want to wait on the command buffer
to finish execution, thus our triangle being drawn, we take the semaphores
which will be signalled and wait on them, thus we use <code>signalSemaphores</code>.</p>
<pre class="hljs"><code><div>VkSwapchainKHR swapChains[] = {swapChain};
presentInfo.swapchainCount = <span class="hljs-number">1</span>;
presentInfo.pSwapchains = swapChains;
presentInfo.pImageIndices = &amp;imageIndex;
</div></code></pre>
<p>The next two parameters specify the swap chains to present images to and the
index of the image for each swap chain. This will almost always be a single one.</p>
<pre class="hljs"><code><div>presentInfo.pResults = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>There is one last optional parameter called <code>pResults</code>. It allows you to specify
an array of <code>VkResult</code> values to check for every individual swap chain if
presentation was successful. It's not necessary if you're only using a single
swap chain, because you can simply use the return value of the present function.</p>
<pre class="hljs"><code><div>vkQueuePresentKHR(presentQueue, &amp;presentInfo);
</div></code></pre>
<p>The <code>vkQueuePresentKHR</code> function submits the request to present an image to the
swap chain. We'll add error handling for both <code>vkAcquireNextImageKHR</code> and
<code>vkQueuePresentKHR</code> in the next chapter, because their failure does not
necessarily mean that the program should terminate, unlike the functions we've
seen so far.</p>
<p>If you did everything correctly up to this point, then you should now see
something resembling the following when you run your program:</p>
<p><img src="images/triangle.png" alt=""></p>
<blockquote>
<p>This colored triangle may look a bit different from the one you're used to seeing in graphics tutorials. That's because this tutorial lets the shader interpolate in linear color space and converts to sRGB color space afterwards. See <a href="https://medium.com/@heypete/hello-triangle-meet-swift-and-wide-color-6f9e246616d9">this blog post</a> for a discussion of the difference.</p>
</blockquote>
<p>Yay! Unfortunately, you'll see that when validation layers are enabled, the
program crashes as soon as you close it. The messages printed to the terminal
from <code>debugCallback</code> tell us why:</p>
<p><img src="images/semaphore_in_use.png" alt=""></p>
<p>Remember that all of the operations in <code>drawFrame</code> are asynchronous. That means
that when we exit the loop in <code>mainLoop</code>, drawing and presentation operations
may still be going on. Cleaning up resources while that is happening is a bad
idea.</p>
<p>To fix that problem, we should wait for the logical device to finish operations
before exiting <code>mainLoop</code> and destroying the window:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        drawFrame();
    }

    vkDeviceWaitIdle(device);
}
</div></code></pre>
<p>You can also wait for operations in a specific command queue to be finished with
<code>vkQueueWaitIdle</code>. These functions can be used as a very rudimentary way to
perform synchronization. You'll see that the program now exits without problems
when closing the window.</p>
<h4 id="conclusion">Conclusion</h4>
<p>A little over 900 lines of code later, we've finally gotten to the stage of seeing
something pop up on the screen! Bootstrapping a Vulkan program is definitely a
lot of work, but the take-away message is that Vulkan gives you an immense
amount of control through its explicitness. I recommend you to take some time
now to reread the code and build a mental model of the purpose of all of the
Vulkan objects in the program and how they relate to each other. We'll be
building on top of that knowledge to extend the functionality of the program
from this point on.</p>
<p>The next chapter will expand the render loop to handle multiple frames in flight.</p>
<p><a href="/code/15_hello_triangle.cpp">C++ code</a> /
<a href="/code/09_shader_base.vert">Vertex shader</a> /
<a href="/code/09_shader_base.frag">Fragment shader</a></p>
<h3 id="03framesinflight">03_Frames_in_flight</h3>
<h4 id="frames-in-flight">Frames in flight</h4>
<p>Right now our render loop has one glaring flaw. We are required to wait on the
previous frame to finish before we can start rendering the next which results
in unnecessary idling of the host.</p>
<!-- insert diagram showing our current render loop and the 'multi frame in flight' render loop -->
<p>The way to fix this is to allow multiple frames to be <em>in-flight</em> at once, that
is to say, allow the rendering of one frame to not interfere with the recording
of the next. How do we do this? Any resource that is accessed and modified
during rendering must be duplicated. Thus, we need multiple command buffers,
semaphores, and fences. In later chapters we will also add multiple instances
of other resources, so we will see this concept reappear.</p>
<p>Start by adding a constant at the top of the program that defines how many
frames should be processed concurrently:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_FRAMES_IN_FLIGHT = <span class="hljs-number">2</span>;
</div></code></pre>
<p>We choose the number 2 because we don't want the CPU to get <em>too</em> far ahead of
the GPU. With 2 frames in flight, the CPU and the GPU can be working on their
own tasks at the same time. If the CPU finishes early, it will wait till the
GPU finishes rendering before submitting more work. With 3 or more frames in
flight, the CPU could get ahead of the GPU, adding frames of latency.
Generally, extra latency isn't desired. But giving the application control over
the number of frames in flight is another example of Vulkan being explicit.</p>
<p>Each frame should have its own command buffer, set of semaphores, and fence.
Rename and then change them to be <code>std::vector</code>s of the objects:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkCommandBuffer&gt; commandBuffers;

...

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkSemaphore&gt; imageAvailableSemaphores;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkSemaphore&gt; renderFinishedSemaphores;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkFence&gt; inFlightFences;
</div></code></pre>
<p>Then we need to create multiple command buffers. Rename <code>createCommandBuffer</code>
to <code>createCommandBuffers</code>. Next we need to resize the command buffers vector
to the size of <code>MAX_FRAMES_IN_FLIGHT</code>, alter the <code>VkCommandBufferAllocateInfo</code>
to contain that many command buffers, and then change the destination to our
vector of command buffers:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createCommandBuffers</span><span class="hljs-params">()</span> </span>{
    commandBuffers.resize(MAX_FRAMES_IN_FLIGHT);
    ...
    allocInfo.commandBufferCount = (<span class="hljs-keyword">uint32_t</span>) commandBuffers.<span class="hljs-built_in">size</span>();

    <span class="hljs-keyword">if</span> (vkAllocateCommandBuffers(device, &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to allocate command buffers!"</span>);
    }
}
</div></code></pre>
<p>The <code>createSyncObjects</code> function should be changed to create all of the objects:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createSyncObjects</span><span class="hljs-params">()</span> </span>{
    imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

    VkSemaphoreCreateInfo semaphoreInfo{};
    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

    VkFenceCreateInfo fenceInfo{};
    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
        <span class="hljs-keyword">if</span> (vkCreateSemaphore(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS ||
            vkCreateSemaphore(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS ||
            vkCreateFence(device, &amp;fenceInfo, <span class="hljs-literal">nullptr</span>, &amp;inFlightFences[i]) != VK_SUCCESS) {

            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create synchronization objects for a frame!"</span>);
        }
    }
}
</div></code></pre>
<p>Similarly, they should also all be cleaned up:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
        vkDestroySemaphore(device, renderFinishedSemaphores[i], <span class="hljs-literal">nullptr</span>);
        vkDestroySemaphore(device, imageAvailableSemaphores[i], <span class="hljs-literal">nullptr</span>);
        vkDestroyFence(device, inFlightFences[i], <span class="hljs-literal">nullptr</span>);
    }

    ...
}
</div></code></pre>
<p>Remember, because command buffers are freed for us when we free the command
pool, there is nothing extra to do for command buffer cleanup.</p>
<p>To use the right objects every frame, we need to keep track of the current
frame. We will use a frame index for that purpose:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">uint32_t</span> currentFrame = <span class="hljs-number">0</span>;
</div></code></pre>
<p>The <code>drawFrame</code> function can now be modified to use the right objects:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>{
    vkWaitForFences(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);
    vkResetFences(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);

    vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);

    ...

    vkResetCommandBuffer(commandBuffers[currentFrame],  <span class="hljs-number">0</span>);
    recordCommandBuffer(commandBuffers[currentFrame], imageIndex);

    ...

    submitInfo.pCommandBuffers = &amp;commandBuffers[currentFrame];

    ...

    VkSemaphore waitSemaphores[] = {imageAvailableSemaphores[currentFrame]};

    ...

    VkSemaphore signalSemaphores[] = {renderFinishedSemaphores[currentFrame]};

    ...

    <span class="hljs-keyword">if</span> (vkQueueSubmit(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {
}
</div></code></pre>
<p>Of course, we shouldn't forget to advance to the next frame every time:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>{
    ...

    currentFrame = (currentFrame + <span class="hljs-number">1</span>) % MAX_FRAMES_IN_FLIGHT;
}
</div></code></pre>
<p>By using the modulo (%) operator, we ensure that the frame index loops around
after every <code>MAX_FRAMES_IN_FLIGHT</code> enqueued frames.</p>
<!-- Possibly use swapchain-image-count for renderFinished semaphores, as it can't
be known with a fence whether the semaphore is ready for re-use. -->
<p>We've now implemented all the needed synchronization to ensure that there are
no more than <code>MAX_FRAMES_IN_FLIGHT</code> frames of work enqueued and that these
frames are not stepping over eachother. Note that it is fine for other parts of
the code, like the final cleanup, to rely on more rough synchronization like
<code>vkDeviceWaitIdle</code>. You should decide on which approach to use based on
performance requirements.</p>
<p>To learn more about synchronization through examples, have a look at <a href="https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples#swapchain-image-acquire-and-present">this extensive overview</a> by Khronos.</p>
<p>In the next chapter we'll deal with one more small thing that is required for a
well-behaved Vulkan program.</p>
<p><a href="/code/16_frames_in_flight.cpp">C++ code</a> /
<a href="/code/09_shader_base.vert">Vertex shader</a> /
<a href="/code/09_shader_base.frag">Fragment shader</a></p>
<h2 id="5-swapchainrecreation">5. Swap_chain_recreation</h2>
<h3 id="introduction">Introduction</h3>
<p>The application we have now successfully draws a triangle, but there are some
circumstances that it isn't handling properly yet. It is possible for the window
surface to change such that the swap chain is no longer compatible with it. One
of the reasons that could cause this to happen is the size of the window
changing. We have to catch these events and recreate the swap chain.</p>
<h3 id="recreating-the-swap-chain">Recreating the swap chain</h3>
<p>Create a new <code>recreateSwapChain</code> function that calls <code>createSwapChain</code> and all
of the creation functions for the objects that depend on the swap chain or the
window size.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>{
    vkDeviceWaitIdle(device);

    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
}
</div></code></pre>
<p>We first call <code>vkDeviceWaitIdle</code>, because just like in the last chapter, we
shouldn't touch resources that may still be in use. Obviously, the first thing
we'll have to do is recreate the swap chain itself. The image views need to be
recreated because they are based directly on the swap chain images. The render
pass needs to be recreated because it depends on the format of the swap chain
images. It is rare for the swap chain image format to change during an operation
like a window resize, but it should still be handled. Viewport and scissor
rectangle size is specified during graphics pipeline creation, so the pipeline
also needs to be rebuilt. It is possible to avoid this by using dynamic state
for the viewports and scissor rectangles. Finally, the framebuffers directly
depend on the swap chain images.</p>
<p>To make sure that the old versions of these objects are cleaned up before
recreating them, we should move some of the cleanup code to a separate function
that we can call from the <code>recreateSwapChain</code> function. Let's call it
<code>cleanupSwapChain</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanupSwapChain</span><span class="hljs-params">()</span> </span>{

}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>{
    vkDeviceWaitIdle(device);

    cleanupSwapChain();

    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
}
</div></code></pre>
<p>we'll move the cleanup code of all objects that are recreated as part of a swap
chain refresh from <code>cleanup</code> to <code>cleanupSwapChain</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanupSwapChain</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainFramebuffers.<span class="hljs-built_in">size</span>(); i++) {
        vkDestroyFramebuffer(device, swapChainFramebuffers[i], <span class="hljs-literal">nullptr</span>);
    }

    vkDestroyPipeline(device, graphicsPipeline, <span class="hljs-literal">nullptr</span>);
    vkDestroyPipelineLayout(device, pipelineLayout, <span class="hljs-literal">nullptr</span>);
    vkDestroyRenderPass(device, renderPass, <span class="hljs-literal">nullptr</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImageViews.<span class="hljs-built_in">size</span>(); i++) {
        vkDestroyImageView(device, swapChainImageViews[i], <span class="hljs-literal">nullptr</span>);
    }

    vkDestroySwapchainKHR(device, swapChain, <span class="hljs-literal">nullptr</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    cleanupSwapChain();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
        vkDestroySemaphore(device, renderFinishedSemaphores[i], <span class="hljs-literal">nullptr</span>);
        vkDestroySemaphore(device, imageAvailableSemaphores[i], <span class="hljs-literal">nullptr</span>);
        vkDestroyFence(device, inFlightFences[i], <span class="hljs-literal">nullptr</span>);
    }

    vkDestroyCommandPool(device, commandPool, <span class="hljs-literal">nullptr</span>);

    vkDestroyDevice(device, <span class="hljs-literal">nullptr</span>);

    <span class="hljs-keyword">if</span> (enableValidationLayers) {
        DestroyDebugUtilsMessengerEXT(instance, debugMessenger, <span class="hljs-literal">nullptr</span>);
    }

    vkDestroySurfaceKHR(instance, surface, <span class="hljs-literal">nullptr</span>);
    vkDestroyInstance(instance, <span class="hljs-literal">nullptr</span>);

    glfwDestroyWindow(window);

    glfwTerminate();
}
</div></code></pre>
<p>Note that in <code>chooseSwapExtent</code> we already query the new window resolution to
make sure that the swap chain images have the (new) right size, so there's no
need to modify <code>chooseSwapExtent</code> (remember that we already had to use
<code>glfwGetFramebufferSize</code> get the resolution of the surface in pixels when
creating the swap chain).</p>
<p>That's all it takes to recreate the swap chain! However, the disadvantage of
this approach is that we need to stop all rendering before creating the new swap
chain. It is possible to create a new swap chain while drawing commands on an
image from the old swap chain are still in-flight. You need to pass the previous
swap chain to the <code>oldSwapChain</code> field in the <code>VkSwapchainCreateInfoKHR</code> struct
and destroy the old swap chain as soon as you've finished using it.</p>
<h3 id="suboptimal-or-out-of-date-swap-chain">Suboptimal or out-of-date swap chain</h3>
<p>Now we just need to figure out when swap chain recreation is necessary and call
our new <code>recreateSwapChain</code> function. Luckily, Vulkan will usually just tell us that the swap chain is no longer adequate during presentation. The <code>vkAcquireNextImageKHR</code> and
<code>vkQueuePresentKHR</code> functions can return the following special values to
indicate this.</p>
<ul>
<li><code>VK_ERROR_OUT_OF_DATE_KHR</code>: The swap chain has become incompatible with the
surface and can no longer be used for rendering. Usually happens after a window resize.</li>
<li><code>VK_SUBOPTIMAL_KHR</code>: The swap chain can still be used to successfully present
to the surface, but the surface properties are no longer matched exactly.</li>
</ul>
<pre class="hljs"><code><div>VkResult result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);

<span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR) {
    recreateSwapChain();
    <span class="hljs-keyword">return</span>;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to acquire swap chain image!"</span>);
}
</div></code></pre>
<p>If the swap chain turns out to be out of date when attempting to acquire an
image, then it is no longer possible to present to it. Therefore we should
immediately recreate the swap chain and try again in the next <code>drawFrame</code> call.</p>
<p>You could also decide to do that if the swap chain is suboptimal, but I've
chosen to proceed anyway in that case because we've already acquired an image.
Both <code>VK_SUCCESS</code> and <code>VK_SUBOPTIMAL_KHR</code> are considered &quot;success&quot; return codes.</p>
<pre class="hljs"><code><div>result = vkQueuePresentKHR(presentQueue, &amp;presentInfo);

<span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) {
    recreateSwapChain();
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to present swap chain image!"</span>);
}

currentFrame = (currentFrame + <span class="hljs-number">1</span>) % MAX_FRAMES_IN_FLIGHT;
</div></code></pre>
<p>The <code>vkQueuePresentKHR</code> function returns the same values with the same meaning.
In this case we will also recreate the swap chain if it is suboptimal, because
we want the best possible result.</p>
<h3 id="fixing-a-deadlock">Fixing a deadlock</h3>
<p>If we try to run the code now, it is possible to encounter a deadlock.
Debugging the code, we find that the application reaches <code>vkWaitForFences</code> but
never continues past it. This is because when <code>vkAcquireNextImageKHR</code> returns
<code>VK_ERROR_OUT_OF_DATE_KHR</code>, we recreate the swapchain and then return from
<code>drawFrame</code>. But before that happens, the current frame's fence was waited upon
and reset. Since we return immediately, no work is submitted for execution and
the fence will never be signaled, causing <code>vkWaitForFences</code> to halt forever.</p>
<p>There is a simple fix thankfully. Delay resetting the fence until after we
know for sure we will be submitting work with it. Thus, if we return early, the
fence is still signaled and <code>vkWaitForFences</code> wont deadlock the next time we
use the same fence object.</p>
<p>The beginning of <code>drawFrame</code> should now look like this:</p>
<pre class="hljs"><code><div>vkWaitForFences(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);

<span class="hljs-keyword">uint32_t</span> imageIndex;
VkResult result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);

<span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR) {
    recreateSwapChain();
    <span class="hljs-keyword">return</span>;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to acquire swap chain image!"</span>);
}

<span class="hljs-comment">// Only reset the fence if we are submitting work</span>
vkResetFences(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);
</div></code></pre>
<h3 id="handling-resizes-explicitly">Handling resizes explicitly</h3>
<p>Although many drivers and platforms trigger <code>VK_ERROR_OUT_OF_DATE_KHR</code> automatically after a window resize, it is not guaranteed to happen. That's why we'll add some extra code to also handle resizes explicitly. First add a new member variable that flags that a resize has happened:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkFence&gt; inFlightFences;

<span class="hljs-keyword">bool</span> framebufferResized = <span class="hljs-literal">false</span>;
</div></code></pre>
<p>The <code>drawFrame</code> function should then be modified to also check for this flag:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) {
    framebufferResized = <span class="hljs-literal">false</span>;
    recreateSwapChain();
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS) {
    ...
}
</div></code></pre>
<p>It is important to do this after <code>vkQueuePresentKHR</code> to ensure that the semaphores are in a consistent state, otherwise a signalled semaphore may never be properly waited upon. Now to actually detect resizes we can use the <code>glfwSetFramebufferSizeCallback</code> function in the GLFW framework to set up a callback:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initWindow</span><span class="hljs-params">()</span> </span>{
    glfwInit();

    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);

    window = glfwCreateWindow(WIDTH, HEIGHT, <span class="hljs-string">"Vulkan"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
    glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">framebufferResizeCallback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-keyword">int</span> <span class="hljs-built_in">height</span>)</span> </span>{

}
</div></code></pre>
<p>The reason that we're creating a <code>static</code> function as a callback is because GLFW does not know how to properly call a member function with the right <code>this</code> pointer to our <code>HelloTriangleApplication</code> instance.</p>
<p>However, we do get a reference to the <code>GLFWwindow</code> in the callback and there is another GLFW function that allows you to store an arbitrary pointer inside of it: <code>glfwSetWindowUserPointer</code>:</p>
<pre class="hljs"><code><div>window = glfwCreateWindow(WIDTH, HEIGHT, <span class="hljs-string">"Vulkan"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
glfwSetWindowUserPointer(window, <span class="hljs-keyword">this</span>);
glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);
</div></code></pre>
<p>This value can now be retrieved from within the callback with <code>glfwGetWindowUserPointer</code> to properly set the flag:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">framebufferResizeCallback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-keyword">int</span> <span class="hljs-built_in">height</span>)</span> </span>{
    <span class="hljs-keyword">auto</span> app = <span class="hljs-keyword">reinterpret_cast</span>&lt;HelloTriangleApplication*&gt;(glfwGetWindowUserPointer(window));
    app-&gt;framebufferResized = <span class="hljs-literal">true</span>;
}
</div></code></pre>
<p>Now try to run the program and resize the window to see if the framebuffer is indeed resized properly with the window.</p>
<h3 id="handling-minimization">Handling minimization</h3>
<p>There is another case where a swap chain may become out of date and that is a special kind of window resizing: window minimization. This case is special because it will result in a frame buffer size of <code>0</code>. In this tutorial we will handle that by pausing until the window is in the foreground again by extending the <code>recreateSwapChain</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">height</span> = <span class="hljs-number">0</span>;
    glfwGetFramebufferSize(window, &amp;<span class="hljs-built_in">width</span>, &amp;<span class="hljs-built_in">height</span>);
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">width</span> == <span class="hljs-number">0</span> || <span class="hljs-built_in">height</span> == <span class="hljs-number">0</span>) {
        glfwGetFramebufferSize(window, &amp;<span class="hljs-built_in">width</span>, &amp;<span class="hljs-built_in">height</span>);
        glfwWaitEvents();
    }

    vkDeviceWaitIdle(device);

    ...
}
</div></code></pre>
<p>The initial call to <code>glfwGetFramebufferSize</code> handles the case where the size is already correct and <code>glfwWaitEvents</code> would have nothing to wait on.</p>
<p>Congratulations, you've now finished your very first well-behaved Vulkan
program! In the next chapter we're going to get rid of the hardcoded vertices in
the vertex shader and actually use a vertex buffer.</p>
<p><a href="/code/17_swap_chain_recreation.cpp">C++ code</a> /
<a href="/code/09_shader_base.vert">Vertex shader</a> /
<a href="/code/09_shader_base.frag">Fragment shader</a></p>
<h1 id="5---vertex-buffers">5 - Vertex buffers</h1>
<h2 id="1-vertex-input-description">1. Vertex input description</h2>
<h3 id="introduction">Introduction</h3>
<p>In the next few chapters, we're going to replace the hardcoded vertex data in
the vertex shader with a vertex buffer in memory. We'll start with the easiest
approach of creating a CPU visible buffer and using <code>memcpy</code> to copy the vertex
data into it directly, and after that we'll see how to use a staging buffer to
copy the vertex data to high performance memory.</p>
<h3 id="vertex-shader">Vertex shader</h3>
<p>First change the vertex shader to no longer include the vertex data in the
shader code itself. The vertex shader takes input from a vertex buffer using the
<code>in</code> keyword.</p>
<pre class="hljs"><code><div><span class="hljs-meta">##version 450</span>

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
    fragColor = inColor;
}
</div></code></pre>
<p>The <code>inPosition</code> and <code>inColor</code> variables are <em>vertex attributes</em>. They're
properties that are specified per-vertex in the vertex buffer, just like we
manually specified a position and color per vertex using the two arrays. Make
sure to recompile the vertex shader!</p>
<p>Just like <code>fragColor</code>, the <code>layout(location = x)</code> annotations assign indices to
the inputs that we can later use to reference them. It is important to know that
some types, like <code>dvec3</code> 64 bit vectors, use multiple <em>slots</em>. That means that
the index after it must be at least 2 higher:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">dvec3</span> inPosition;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;
</div></code></pre>
<p>You can find more info about the layout qualifier in the <a href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)">OpenGL wiki</a>.</p>
<h3 id="vertex-data">Vertex data</h3>
<p>We're moving the vertex data from the shader code to an array in the code of our
program. Start by including the GLM library, which provides us with linear
algebra related types like vectors and matrices. We're going to use these types
to specify the position and color vectors.</p>
<pre class="hljs"><code><div>#<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/glm.hpp&gt;</span></span>
</div></code></pre>
<p>Create a new structure called <code>Vertex</code> with the two attributes that we're going
to use in the vertex shader inside it:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span> {</span>
    glm::vec2 pos;
    glm::vec3 color;
};
</div></code></pre>
<p>GLM conveniently provides us with C++ types that exactly match the vector types
used in the shader language.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices = {
    {{<span class="hljs-number">0.0f</span>, <span class="hljs-number">-0.5f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}}
};
</div></code></pre>
<p>Now use the <code>Vertex</code> structure to specify an array of vertex data. We're using
exactly the same position and color values as before, but now they're combined
into one array of vertices. This is known as <em>interleaving</em> vertex attributes.</p>
<h3 id="binding-descriptions">Binding descriptions</h3>
<p>The next step is to tell Vulkan how to pass this data format to the vertex
shader once it's been uploaded into GPU memory. There are two types of
structures needed to convey this information.</p>
<p>The first structure is <code>VkVertexInputBindingDescription</code> and we'll add a member
function to the <code>Vertex</code> struct to populate it with the right data.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span> {</span>
    glm::vec2 pos;
    glm::vec3 color;

    <span class="hljs-function"><span class="hljs-keyword">static</span> VkVertexInputBindingDescription <span class="hljs-title">getBindingDescription</span><span class="hljs-params">()</span> </span>{
        VkVertexInputBindingDescription bindingDescription{};

        <span class="hljs-keyword">return</span> bindingDescription;
    }
};
</div></code></pre>
<p>A vertex binding describes at which rate to load data from memory throughout the
vertices. It specifies the number of bytes between data entries and whether to
move to the next data entry after each vertex or after each instance.</p>
<pre class="hljs"><code><div>VkVertexInputBindingDescription bindingDescription{};
bindingDescription.binding = <span class="hljs-number">0</span>;
bindingDescription.stride = <span class="hljs-keyword">sizeof</span>(Vertex);
bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
</div></code></pre>
<p>All of our per-vertex data is packed together in one array, so we're only going
to have one binding. The <code>binding</code> parameter specifies the index of the binding
in the array of bindings. The <code>stride</code> parameter specifies the number of bytes
from one entry to the next, and the <code>inputRate</code> parameter can have one of the
following values:</p>
<ul>
<li><code>VK_VERTEX_INPUT_RATE_VERTEX</code>: Move to the next data entry after each vertex</li>
<li><code>VK_VERTEX_INPUT_RATE_INSTANCE</code>: Move to the next data entry after each
instance</li>
</ul>
<p>We're not going to use instanced rendering, so we'll stick to per-vertex data.</p>
<h3 id="attribute-descriptions">Attribute descriptions</h3>
<p>The second structure that describes how to handle vertex input is
<code>VkVertexInputAttributeDescription</code>. We're going to add another helper function
to <code>Vertex</code> to fill in these structs.</p>
<pre class="hljs"><code><div>#<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span>

...

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkVertexInputAttributeDescription, 2&gt; <span class="hljs-title">getAttributeDescriptions</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions{};

    <span class="hljs-keyword">return</span> attributeDescriptions;
}
</div></code></pre>
<p>As the function prototype indicates, there are going to be two of these
structures. An attribute description struct describes how to extract a vertex
attribute from a chunk of vertex data originating from a binding description. We
have two attributes, position and color, so we need two attribute description
structs.</p>
<pre class="hljs"><code><div>attributeDescriptions[<span class="hljs-number">0</span>].binding = <span class="hljs-number">0</span>;
attributeDescriptions[<span class="hljs-number">0</span>].location = <span class="hljs-number">0</span>;
attributeDescriptions[<span class="hljs-number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;
attributeDescriptions[<span class="hljs-number">0</span>].offset = offsetof(Vertex, pos);
</div></code></pre>
<p>The <code>binding</code> parameter tells Vulkan from which binding the per-vertex data
comes. The <code>location</code> parameter references the <code>location</code> directive of the
input in the vertex shader. The input in the vertex shader with location <code>0</code> is
the position, which has two 32-bit float components.</p>
<p>The <code>format</code> parameter describes the type of data for the attribute. A bit
confusingly, the formats are specified using the same enumeration as color
formats. The following shader types and formats are commonly used together:</p>
<ul>
<li><code>float</code>: <code>VK_FORMAT_R32_SFLOAT</code></li>
<li><code>vec2</code>: <code>VK_FORMAT_R32G32_SFLOAT</code></li>
<li><code>vec3</code>: <code>VK_FORMAT_R32G32B32_SFLOAT</code></li>
<li><code>vec4</code>: <code>VK_FORMAT_R32G32B32A32_SFLOAT</code></li>
</ul>
<p>As you can see, you should use the format where the amount of color channels
matches the number of components in the shader data type. It is allowed to use
more channels than the number of components in the shader, but they will be
silently discarded. If the number of channels is lower than the number of
components, then the BGA components will use default values of <code>(0, 0, 1)</code>. The
color type (<code>SFLOAT</code>, <code>UINT</code>, <code>SINT</code>) and bit width should also match the type
of the shader input. See the following examples:</p>
<ul>
<li><code>ivec2</code>: <code>VK_FORMAT_R32G32_SINT</code>, a 2-component vector of 32-bit signed
integers</li>
<li><code>uvec4</code>: <code>VK_FORMAT_R32G32B32A32_UINT</code>, a 4-component vector of 32-bit
unsigned integers</li>
<li><code>double</code>: <code>VK_FORMAT_R64_SFLOAT</code>, a double-precision (64-bit) float</li>
</ul>
<p>The <code>format</code> parameter implicitly defines the byte size of attribute data and
the <code>offset</code> parameter specifies the number of bytes since the start of the
per-vertex data to read from. The binding is loading one <code>Vertex</code> at a time and
the position attribute (<code>pos</code>) is at an offset of <code>0</code> bytes from the beginning
of this struct. This is automatically calculated using the <code>offsetof</code> macro.</p>
<pre class="hljs"><code><div>attributeDescriptions[<span class="hljs-number">1</span>].binding = <span class="hljs-number">0</span>;
attributeDescriptions[<span class="hljs-number">1</span>].location = <span class="hljs-number">1</span>;
attributeDescriptions[<span class="hljs-number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;
attributeDescriptions[<span class="hljs-number">1</span>].offset = offsetof(Vertex, color);
</div></code></pre>
<p>The color attribute is described in much the same way.</p>
<h3 id="pipeline-vertex-input">Pipeline vertex input</h3>
<p>We now need to set up the graphics pipeline to accept vertex data in this format
by referencing the structures in <code>createGraphicsPipeline</code>. Find the
<code>vertexInputInfo</code> struct and modify it to reference the two descriptions:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">auto</span> bindingDescription = Vertex::getBindingDescription();
<span class="hljs-keyword">auto</span> attributeDescriptions = Vertex::getAttributeDescriptions();

vertexInputInfo.vertexBindingDescriptionCount = <span class="hljs-number">1</span>;
vertexInputInfo.vertexAttributeDescriptionCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(attributeDescriptions.<span class="hljs-built_in">size</span>());
vertexInputInfo.pVertexBindingDescriptions = &amp;bindingDescription;
vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data();
</div></code></pre>
<p>The pipeline is now ready to accept vertex data in the format of the <code>vertices</code>
container and pass it on to our vertex shader. If you run the program now with
validation layers enabled, you'll see that it complains that there is no vertex
buffer bound to the binding. The next step is to create a vertex buffer and move
the vertex data to it so the GPU is able to access it.</p>
<p><a href="/code/18_vertex_input.cpp">C++ code</a> /
<a href="/code/18_shader_vertexbuffer.vert">Vertex shader</a> /
<a href="/code/18_shader_vertexbuffer.frag">Fragment shader</a></p>
<h2 id="2-vertex-buffer-creation">2. Vertex buffer creation</h2>
<h3 id="introduction">Introduction</h3>
<p>Buffers in Vulkan are regions of memory used for storing arbitrary data that can
be read by the graphics card. They can be used to store vertex data, which we'll
do in this chapter, but they can also be used for many other purposes that we'll
explore in future chapters. Unlike the Vulkan objects we've been dealing with so
far, buffers do not automatically allocate memory for themselves. The work from
the previous chapters has shown that the Vulkan API puts the programmer in
control of almost everything and memory management is one of those things.</p>
<h3 id="buffer-creation">Buffer creation</h3>
<p>Create a new function <code>createVertexBuffer</code> and call it from <code>initVulkan</code> right
before <code>createCommandBuffers</code>.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
    createCommandPool();
    createVertexBuffer();
    createCommandBuffers();
    createSyncObjects();
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>Creating a buffer requires us to fill a <code>VkBufferCreateInfo</code> structure.</p>
<pre class="hljs"><code><div>VkBufferCreateInfo bufferInfo{};
bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
bufferInfo.<span class="hljs-built_in">size</span> = <span class="hljs-keyword">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();
</div></code></pre>
<p>The first field of the struct is <code>size</code>, which specifies the size of the buffer
in bytes. Calculating the byte size of the vertex data is straightforward with
<code>sizeof</code>.</p>
<pre class="hljs"><code><div>bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
</div></code></pre>
<p>The second field is <code>usage</code>, which indicates for which purposes the data in the
buffer is going to be used. It is possible to specify multiple purposes using a
bitwise or. Our use case will be a vertex buffer, we'll look at other types of
usage in future chapters.</p>
<pre class="hljs"><code><div>bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
</div></code></pre>
<p>Just like the images in the swap chain, buffers can also be owned by a specific
queue family or be shared between multiple at the same time. The buffer will
only be used from the graphics queue, so we can stick to exclusive access.</p>
<p>The <code>flags</code> parameter is used to configure sparse buffer memory, which is not
relevant right now. We'll leave it at the default value of <code>0</code>.</p>
<p>We can now create the buffer with <code>vkCreateBuffer</code>. Define a class member to
hold the buffer handle and call it <code>vertexBuffer</code>.</p>
<pre class="hljs"><code><div>VkBuffer vertexBuffer;

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>{
    VkBufferCreateInfo bufferInfo{};
    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    bufferInfo.<span class="hljs-built_in">size</span> = <span class="hljs-keyword">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();
    bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    <span class="hljs-keyword">if</span> (vkCreateBuffer(device, &amp;bufferInfo, <span class="hljs-literal">nullptr</span>, &amp;vertexBuffer) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create vertex buffer!"</span>);
    }
}
</div></code></pre>
<p>The buffer should be available for use in rendering commands until the end of
the program and it does not depend on the swap chain, so we'll clean it up in
the original <code>cleanup</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    cleanupSwapChain();

    vkDestroyBuffer(device, vertexBuffer, <span class="hljs-literal">nullptr</span>);

    ...
}
</div></code></pre>
<h3 id="memory-requirements">Memory requirements</h3>
<p>The buffer has been created, but it doesn't actually have any memory assigned to
it yet. The first step of allocating memory for the buffer is to query its
memory requirements using the aptly named <code>vkGetBufferMemoryRequirements</code>
function.</p>
<pre class="hljs"><code><div>VkMemoryRequirements memRequirements;
vkGetBufferMemoryRequirements(device, vertexBuffer, &amp;memRequirements);
</div></code></pre>
<p>The <code>VkMemoryRequirements</code> struct has three fields:</p>
<ul>
<li><code>size</code>: The size of the required amount of memory in bytes, may differ from
<code>bufferInfo.size</code>.</li>
<li><code>alignment</code>: The offset in bytes where the buffer begins in the allocated
region of memory, depends on <code>bufferInfo.usage</code> and <code>bufferInfo.flags</code>.</li>
<li><code>memoryTypeBits</code>: Bit field of the memory types that are suitable for the
buffer.</li>
</ul>
<p>Graphics cards can offer different types of memory to allocate from. Each type
of memory varies in terms of allowed operations and performance characteristics.
We need to combine the requirements of the buffer and our own application
requirements to find the right type of memory to use. Let's create a new
function <code>findMemoryType</code> for this purpose.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">findMemoryType</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> typeFilter, VkMemoryPropertyFlags properties)</span> </span>{

}
</div></code></pre>
<p>First we need to query info about the available types of memory using
<code>vkGetPhysicalDeviceMemoryProperties</code>.</p>
<pre class="hljs"><code><div>VkPhysicalDeviceMemoryProperties memProperties;
vkGetPhysicalDeviceMemoryProperties(physicalDevice, &amp;memProperties);
</div></code></pre>
<p>The <code>VkPhysicalDeviceMemoryProperties</code> structure has two arrays <code>memoryTypes</code>
and <code>memoryHeaps</code>. Memory heaps are distinct memory resources like dedicated
VRAM and swap space in RAM for when VRAM runs out. The different types of memory
exist within these heaps. Right now we'll only concern ourselves with the type
of memory and not the heap it comes from, but you can imagine that this can
affect performance.</p>
<p>Let's first find a memory type that is suitable for the buffer itself:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; memProperties.memoryTypeCount; i++) {
    <span class="hljs-keyword">if</span> (typeFilter &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) {
        <span class="hljs-keyword">return</span> i;
    }
}

<span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to find suitable memory type!"</span>);
</div></code></pre>
<p>The <code>typeFilter</code> parameter will be used to specify the bit field of memory types
that are suitable. That means that we can find the index of a suitable memory
type by simply iterating over them and checking if the corresponding bit is set
to <code>1</code>.</p>
<p>However, we're not just interested in a memory type that is suitable for the
vertex buffer. We also need to be able to write our vertex data to that memory.
The <code>memoryTypes</code> array consists of <code>VkMemoryType</code> structs that specify the heap
and properties of each type of memory. The properties define special features
of the memory, like being able to map it so we can write to it from the CPU.
This property is indicated with <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, but we
also need to use the <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> property. We'll see
why when we map the memory.</p>
<p>We can now modify the loop to also check for the support of this property:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; memProperties.memoryTypeCount; i++) {
    <span class="hljs-keyword">if</span> ((typeFilter &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &amp;&amp; (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) {
        <span class="hljs-keyword">return</span> i;
    }
}
</div></code></pre>
<p>We may have more than one desirable property, so we should check if the result
of the bitwise AND is not just non-zero, but equal to the desired properties bit
field. If there is a memory type suitable for the buffer that also has all of
the properties we need, then we return its index, otherwise we throw an
exception.</p>
<h3 id="memory-allocation">Memory allocation</h3>
<p>We now have a way to determine the right memory type, so we can actually
allocate the memory by filling in the <code>VkMemoryAllocateInfo</code> structure.</p>
<pre class="hljs"><code><div>VkMemoryAllocateInfo allocInfo{};
allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
allocInfo.allocationSize = memRequirements.<span class="hljs-built_in">size</span>;
allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
</div></code></pre>
<p>Memory allocation is now as simple as specifying the size and type, both of
which are derived from the memory requirements of the vertex buffer and the
desired property. Create a class member to store the handle to the memory and
allocate it with <code>vkAllocateMemory</code>.</p>
<pre class="hljs"><code><div>VkBuffer vertexBuffer;
VkDeviceMemory vertexBufferMemory;

...

<span class="hljs-keyword">if</span> (vkAllocateMemory(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;vertexBufferMemory) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to allocate vertex buffer memory!"</span>);
}
</div></code></pre>
<p>If memory allocation was successful, then we can now associate this memory with
the buffer using <code>vkBindBufferMemory</code>:</p>
<pre class="hljs"><code><div>vkBindBufferMemory(device, vertexBuffer, vertexBufferMemory, <span class="hljs-number">0</span>);
</div></code></pre>
<p>The first three parameters are self-explanatory and the fourth parameter is the
offset within the region of memory. Since this memory is allocated specifically
for this the vertex buffer, the offset is simply <code>0</code>. If the offset is non-zero,
then it is required to be divisible by <code>memRequirements.alignment</code>.</p>
<p>Of course, just like dynamic memory allocation in C++, the memory should be
freed at some point. Memory that is bound to a buffer object may be freed once
the buffer is no longer used, so let's free it after the buffer has been
destroyed:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    cleanupSwapChain();

    vkDestroyBuffer(device, vertexBuffer, <span class="hljs-literal">nullptr</span>);
    vkFreeMemory(device, vertexBufferMemory, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<h3 id="filling-the-vertex-buffer">Filling the vertex buffer</h3>
<p>It is now time to copy the vertex data to the buffer. This is done by <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">mapping
the buffer memory</a> into CPU
accessible memory with <code>vkMapMemory</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">void</span>* data;
vkMapMemory(device, vertexBufferMemory, <span class="hljs-number">0</span>, bufferInfo.<span class="hljs-built_in">size</span>, <span class="hljs-number">0</span>, &amp;data);
</div></code></pre>
<p>This function allows us to access a region of the specified memory resource
defined by an offset and size. The offset and size here are <code>0</code> and
<code>bufferInfo.size</code>, respectively. It is also possible to specify the special
value <code>VK_WHOLE_SIZE</code> to map all of the memory. The second to last parameter can
be used to specify flags, but there aren't any available yet in the current API.
It must be set to the value <code>0</code>. The last parameter specifies the output for the
pointer to the mapped memory.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">void</span>* data;
vkMapMemory(device, vertexBufferMemory, <span class="hljs-number">0</span>, bufferInfo.<span class="hljs-built_in">size</span>, <span class="hljs-number">0</span>, &amp;data);
    <span class="hljs-built_in">memcpy</span>(data, vertices.data(), (<span class="hljs-keyword">size_t</span>) bufferInfo.<span class="hljs-built_in">size</span>);
vkUnmapMemory(device, vertexBufferMemory);
</div></code></pre>
<p>You can now simply <code>memcpy</code> the vertex data to the mapped memory and unmap it
again using <code>vkUnmapMemory</code>. Unfortunately the driver may not immediately copy
the data into the buffer memory, for example because of caching. It is also
possible that writes to the buffer are not visible in the mapped memory yet.
There are two ways to deal with that problem:</p>
<ul>
<li>Use a memory heap that is host coherent, indicated with
<code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code></li>
<li>Call <code>vkFlushMappedMemoryRanges</code> after writing to the mapped memory, and
call <code>vkInvalidateMappedMemoryRanges</code> before reading from the mapped memory</li>
</ul>
<p>We went for the first approach, which ensures that the mapped memory always
matches the contents of the allocated memory. Do keep in mind that this may lead
to slightly worse performance than explicit flushing, but we'll see why that
doesn't matter in the next chapter.</p>
<p>Flushing memory ranges or using a coherent memory heap means that the driver will be aware of our writes to the buffer, but it doesn't mean that they are actually visible on the GPU yet. The transfer of data to the GPU is an operation that happens in the background and the specification simply <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap7.html#synchronization-submission-host-writes">tells us</a> that it is guaranteed to be complete as of the next call to <code>vkQueueSubmit</code>.</p>
<h3 id="binding-the-vertex-buffer">Binding the vertex buffer</h3>
<p>All that remains now is binding the vertex buffer during rendering operations.
We're going to extend the <code>recordCommandBuffer</code> function to do that.</p>
<pre class="hljs"><code><div>vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

VkBuffer vertexBuffers[] = {vertexBuffer};
VkDeviceSize offsets[] = {<span class="hljs-number">0</span>};
vkCmdBindVertexBuffers(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, vertexBuffers, offsets);

vkCmdDraw(commandBuffer, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(vertices.<span class="hljs-built_in">size</span>()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</div></code></pre>
<p>The <code>vkCmdBindVertexBuffers</code> function is used to bind vertex buffers to
bindings, like the one we set up in the previous chapter. The first two
parameters, besides the command buffer, specify the offset and number of
bindings we're going to specify vertex buffers for. The last two parameters
specify the array of vertex buffers to bind and the byte offsets to start
reading vertex data from. You should also change the call to <code>vkCmdDraw</code> to pass
the number of vertices in the buffer as opposed to the hardcoded number <code>3</code>.</p>
<p>Now run the program and you should see the familiar triangle again:</p>
<p><img src="images/triangle.png" alt=""></p>
<p>Try changing the color of the top vertex to white by modifying the <code>vertices</code>
array:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices = {
    {{<span class="hljs-number">0.0f</span>, <span class="hljs-number">-0.5f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}}
};
</div></code></pre>
<p>Run the program again and you should see the following:</p>
<p><img src="images/triangle_white.png" alt=""></p>
<p>In the next chapter we'll look at a different way to copy vertex data to a
vertex buffer that results in better performance, but takes some more work.</p>
<p><a href="/code/19_vertex_buffer.cpp">C++ code</a> /
<a href="/code/18_shader_vertexbuffer.vert">Vertex shader</a> /
<a href="/code/18_shader_vertexbuffer.frag">Fragment shader</a></p>
<h2 id="3-staging-buffer">3. Staging buffer</h2>
<h3 id="introduction">Introduction</h3>
<p>The vertex buffer we have right now works correctly, but the memory type that
allows us to access it from the CPU may not be the most optimal memory type for
the graphics card itself to read from. The most optimal memory has the
<code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> flag and is usually not accessible by the
CPU on dedicated graphics cards. In this chapter we're going to create two
vertex buffers. One <em>staging buffer</em> in CPU accessible memory to upload the data
from the vertex array to, and the final vertex buffer in device local memory.
We'll then use a buffer copy command to move the data from the staging buffer to
the actual vertex buffer.</p>
<h3 id="transfer-queue">Transfer queue</h3>
<p>The buffer copy command requires a queue family that supports transfer
operations, which is indicated using <code>VK_QUEUE_TRANSFER_BIT</code>. The good news is
that any queue family with <code>VK_QUEUE_GRAPHICS_BIT</code> or <code>VK_QUEUE_COMPUTE_BIT</code>
capabilities already implicitly support <code>VK_QUEUE_TRANSFER_BIT</code> operations. The
implementation is not required to explicitly list it in <code>queueFlags</code> in those
cases.</p>
<p>If you like a challenge, then you can still try to use a different queue family
specifically for transfer operations. It will require you to make the following
modifications to your program:</p>
<ul>
<li>Modify <code>QueueFamilyIndices</code> and <code>findQueueFamilies</code> to explicitly look for a
queue family with the <code>VK_QUEUE_TRANSFER_BIT</code> bit, but not the
<code>VK_QUEUE_GRAPHICS_BIT</code>.</li>
<li>Modify <code>createLogicalDevice</code> to request a handle to the transfer queue</li>
<li>Create a second command pool for command buffers that are submitted on the
transfer queue family</li>
<li>Change the <code>sharingMode</code> of resources to be <code>VK_SHARING_MODE_CONCURRENT</code> and
specify both the graphics and transfer queue families</li>
<li>Submit any transfer commands like <code>vkCmdCopyBuffer</code> (which we'll be using in
this chapter) to the transfer queue instead of the graphics queue</li>
</ul>
<p>It's a bit of work, but it'll teach you a lot about how resources are shared
between queue families.</p>
<h3 id="abstracting-buffer-creation">Abstracting buffer creation</h3>
<p>Because we're going to create multiple buffers in this chapter, it's a good idea
to move buffer creation to a helper function. Create a new function
<code>createBuffer</code> and move the code in <code>createVertexBuffer</code> (except mapping) to it.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createBuffer</span><span class="hljs-params">(VkDeviceSize <span class="hljs-built_in">size</span>, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties, VkBuffer&amp; <span class="hljs-built_in">buffer</span>, VkDeviceMemory&amp; bufferMemory)</span> </span>{
    VkBufferCreateInfo bufferInfo{};
    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    bufferInfo.<span class="hljs-built_in">size</span> = <span class="hljs-built_in">size</span>;
    bufferInfo.usage = usage;
    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    <span class="hljs-keyword">if</span> (vkCreateBuffer(device, &amp;bufferInfo, <span class="hljs-literal">nullptr</span>, &amp;<span class="hljs-built_in">buffer</span>) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create buffer!"</span>);
    }

    VkMemoryRequirements memRequirements;
    vkGetBufferMemoryRequirements(device, <span class="hljs-built_in">buffer</span>, &amp;memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.<span class="hljs-built_in">size</span>;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    <span class="hljs-keyword">if</span> (vkAllocateMemory(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;bufferMemory) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to allocate buffer memory!"</span>);
    }

    vkBindBufferMemory(device, <span class="hljs-built_in">buffer</span>, bufferMemory, <span class="hljs-number">0</span>);
}
</div></code></pre>
<p>Make sure to add parameters for the buffer size, memory properties and usage so
that we can use this function to create many different types of buffers. The
last two parameters are output variables to write the handles to.</p>
<p>You can now remove the buffer creation and memory allocation code from
<code>createVertexBuffer</code> and just call <code>createBuffer</code> instead:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>{
    VkDeviceSize bufferSize = <span class="hljs-keyword">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();
    createBuffer(bufferSize, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, vertexBuffer, vertexBufferMemory);

    <span class="hljs-keyword">void</span>* data;
    vkMapMemory(device, vertexBufferMemory, <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;data);
        <span class="hljs-built_in">memcpy</span>(data, vertices.data(), (<span class="hljs-keyword">size_t</span>) bufferSize);
    vkUnmapMemory(device, vertexBufferMemory);
}
</div></code></pre>
<p>Run your program to make sure that the vertex buffer still works properly.</p>
<h3 id="using-a-staging-buffer">Using a staging buffer</h3>
<p>We're now going to change <code>createVertexBuffer</code> to only use a host visible buffer
as temporary buffer and use a device local one as actual vertex buffer.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>{
    VkDeviceSize bufferSize = <span class="hljs-keyword">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

    <span class="hljs-keyword">void</span>* data;
    vkMapMemory(device, stagingBufferMemory, <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;data);
        <span class="hljs-built_in">memcpy</span>(data, vertices.data(), (<span class="hljs-keyword">size_t</span>) bufferSize);
    vkUnmapMemory(device, stagingBufferMemory);

    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, vertexBufferMemory);
}
</div></code></pre>
<p>We're now using a new <code>stagingBuffer</code> with <code>stagingBufferMemory</code> for mapping and
copying the vertex data. In this chapter we're going to use two new buffer usage
flags:</p>
<ul>
<li><code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code>: Buffer can be used as source in a memory
transfer operation.</li>
<li><code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>: Buffer can be used as destination in a
memory transfer operation.</li>
</ul>
<p>The <code>vertexBuffer</code> is now allocated from a memory type that is device local,
which generally means that we're not able to use <code>vkMapMemory</code>. However, we can
copy data from the <code>stagingBuffer</code> to the <code>vertexBuffer</code>. We have to indicate
that we intend to do that by specifying the transfer source flag for the
<code>stagingBuffer</code> and the transfer destination flag for the <code>vertexBuffer</code>, along
with the vertex buffer usage flag.</p>
<p>We're now going to write a function to copy the contents from one buffer to
another, called <code>copyBuffer</code>.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copyBuffer</span><span class="hljs-params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize <span class="hljs-built_in">size</span>)</span> </span>{

}
</div></code></pre>
<p>Memory transfer operations are executed using command buffers, just like drawing
commands. Therefore we must first allocate a temporary command buffer. You may
wish to create a separate command pool for these kinds of short-lived buffers,
because the implementation may be able to apply memory allocation optimizations.
You should use the <code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code> flag during command
pool generation in that case.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copyBuffer</span><span class="hljs-params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize <span class="hljs-built_in">size</span>)</span> </span>{
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandPool = commandPool;
    allocInfo.commandBufferCount = <span class="hljs-number">1</span>;

    VkCommandBuffer commandBuffer;
    vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer);
}
</div></code></pre>
<p>And immediately start recording the command buffer:</p>
<pre class="hljs"><code><div>VkCommandBufferBeginInfo beginInfo{};
beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

vkBeginCommandBuffer(commandBuffer, &amp;beginInfo);
</div></code></pre>
<p>We're only going to use the command buffer once and wait with returning from the function until the copy
operation has finished executing. It's good practice to tell the driver about
our intent using <code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code>.</p>
<pre class="hljs"><code><div>VkBufferCopy copyRegion{};
copyRegion.srcOffset = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span>
copyRegion.dstOffset = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span>
copyRegion.<span class="hljs-built_in">size</span> = <span class="hljs-built_in">size</span>;
vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, <span class="hljs-number">1</span>, &amp;copyRegion);
</div></code></pre>
<p>Contents of buffers are transferred using the <code>vkCmdCopyBuffer</code> command. It
takes the source and destination buffers as arguments, and an array of regions
to copy. The regions are defined in <code>VkBufferCopy</code> structs and consist of a
source buffer offset, destination buffer offset and size. It is not possible to
specify <code>VK_WHOLE_SIZE</code> here, unlike the <code>vkMapMemory</code> command.</p>
<pre class="hljs"><code><div>vkEndCommandBuffer(commandBuffer);
</div></code></pre>
<p>This command buffer only contains the copy command, so we can stop recording
right after that. Now execute the command buffer to complete the transfer:</p>
<pre class="hljs"><code><div>VkSubmitInfo submitInfo{};
submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
submitInfo.commandBufferCount = <span class="hljs-number">1</span>;
submitInfo.pCommandBuffers = &amp;commandBuffer;

vkQueueSubmit(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);
vkQueueWaitIdle(graphicsQueue);
</div></code></pre>
<p>Unlike the draw commands, there are no events we need to wait on this time. We
just want to execute the transfer on the buffers immediately. There are again
two possible ways to wait on this transfer to complete. We could use a fence and
wait with <code>vkWaitForFences</code>, or simply wait for the transfer queue to become
idle with <code>vkQueueWaitIdle</code>. A fence would allow you to schedule multiple
transfers simultaneously and wait for all of them complete, instead of executing
one at a time. That may give the driver more opportunities to optimize.</p>
<pre class="hljs"><code><div>vkFreeCommandBuffers(device, commandPool, <span class="hljs-number">1</span>, &amp;commandBuffer);
</div></code></pre>
<p>Don't forget to clean up the command buffer used for the transfer operation.</p>
<p>We can now call <code>copyBuffer</code> from the <code>createVertexBuffer</code> function to move the
vertex data to the device local buffer:</p>
<pre class="hljs"><code><div>createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, vertexBufferMemory);

copyBuffer(stagingBuffer, vertexBuffer, bufferSize);
</div></code></pre>
<p>After copying the data from the staging buffer to the device buffer, we should
clean it up:</p>
<pre class="hljs"><code><div>    ...

    copyBuffer(stagingBuffer, vertexBuffer, bufferSize);

    vkDestroyBuffer(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);
    vkFreeMemory(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);
}
</div></code></pre>
<p>Run your program to verify that you're seeing the familiar triangle again. The
improvement may not be visible right now, but its vertex data is now being
loaded from high performance memory. This will matter when we're going to start
rendering more complex geometry.</p>
<h3 id="conclusion">Conclusion</h3>
<p>It should be noted that in a real world application, you're not supposed to
actually call <code>vkAllocateMemory</code> for every individual buffer. The maximum number
of simultaneous memory allocations is limited by the <code>maxMemoryAllocationCount</code>
physical device limit, which may be as low as <code>4096</code> even on high end hardware
like an NVIDIA GTX 1080. The right way to allocate memory for a large number of
objects at the same time is to create a custom allocator that splits up a single
allocation among many different objects by using the <code>offset</code> parameters that
we've seen in many functions.</p>
<p>You can either implement such an allocator yourself, or use the
<a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">VulkanMemoryAllocator</a>
library provided by the GPUOpen initiative. However, for this tutorial it's okay
to use a separate allocation for every resource, because we won't come close to
hitting any of these limits for now.</p>
<p><a href="/code/20_staging_buffer.cpp">C++ code</a> /
<a href="/code/18_shader_vertexbuffer.vert">Vertex shader</a> /
<a href="/code/18_shader_vertexbuffer.frag">Fragment shader</a></p>
<h2 id="4-index-buffer">4. Index buffer</h2>
<h3 id="introduction">Introduction</h3>
<p>The 3D meshes you'll be rendering in a real world application will often share
vertices between multiple triangles. This already happens even with something
simple like drawing a rectangle:</p>
<p><img src="images/vertex_vs_index.svg" alt=""></p>
<p>Drawing a rectangle takes two triangles, which means that we need a vertex
buffer with 6 vertices. The problem is that the data of two vertices needs to be
duplicated resulting in 50% redundancy. It only gets worse with more complex
meshes, where vertices are reused in an average number of 3 triangles. The
solution to this problem is to use an <em>index buffer</em>.</p>
<p>An index buffer is essentially an array of pointers into the vertex buffer. It
allows you to reorder the vertex data, and reuse existing data for multiple
vertices. The illustration above demonstrates what the index buffer would look
like for the rectangle if we have a vertex buffer containing each of the four
unique vertices. The first three indices define the upper-right triangle and the
last three indices define the vertices for the bottom-left triangle.</p>
<h3 id="index-buffer-creation">Index buffer creation</h3>
<p>In this chapter we're going to modify the vertex data and add index data to
draw a rectangle like the one in the illustration. Modify the vertex data to
represent the four corners:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices = {
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}},
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>}}
};
</div></code></pre>
<p>The top-left corner is red, top-right is green, bottom-right is blue and the
bottom-left is white. We'll add a new array <code>indices</code> to represent the contents
of the index buffer. It should match the indices in the illustration to draw the
upper-right triangle and bottom-left triangle.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint16_t</span>&gt; indices = {
    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>
};
</div></code></pre>
<p>It is possible to use either <code>uint16_t</code> or <code>uint32_t</code> for your index buffer
depending on the number of entries in <code>vertices</code>. We can stick to <code>uint16_t</code> for
now because we're using less than 65535 unique vertices.</p>
<p>Just like the vertex data, the indices need to be uploaded into a <code>VkBuffer</code> for
the GPU to be able to access them. Define two new class members to hold the
resources for the index buffer:</p>
<pre class="hljs"><code><div>VkBuffer vertexBuffer;
VkDeviceMemory vertexBufferMemory;
VkBuffer indexBuffer;
VkDeviceMemory indexBufferMemory;
</div></code></pre>
<p>The <code>createIndexBuffer</code> function that we'll add now is almost identical to
<code>createVertexBuffer</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createVertexBuffer();
    createIndexBuffer();
    ...
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createIndexBuffer</span><span class="hljs-params">()</span> </span>{
    VkDeviceSize bufferSize = <span class="hljs-keyword">sizeof</span>(indices[<span class="hljs-number">0</span>]) * indices.<span class="hljs-built_in">size</span>();

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

    <span class="hljs-keyword">void</span>* data;
    vkMapMemory(device, stagingBufferMemory, <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;data);
    <span class="hljs-built_in">memcpy</span>(data, indices.data(), (<span class="hljs-keyword">size_t</span>) bufferSize);
    vkUnmapMemory(device, stagingBufferMemory);

    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer, indexBufferMemory);

    copyBuffer(stagingBuffer, indexBuffer, bufferSize);

    vkDestroyBuffer(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);
    vkFreeMemory(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);
}
</div></code></pre>
<p>There are only two notable differences. The <code>bufferSize</code> is now equal to the
number of indices times the size of the index type, either <code>uint16_t</code> or
<code>uint32_t</code>. The usage of the <code>indexBuffer</code> should be
<code>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</code> instead of
<code>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</code>, which makes sense. Other than that, the
process is exactly the same. We create a staging buffer to copy the contents of
<code>indices</code> to and then copy it to the final device local index buffer.</p>
<p>The index buffer should be cleaned up at the end of the program, just like the
vertex buffer:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    cleanupSwapChain();

    vkDestroyBuffer(device, indexBuffer, <span class="hljs-literal">nullptr</span>);
    vkFreeMemory(device, indexBufferMemory, <span class="hljs-literal">nullptr</span>);

    vkDestroyBuffer(device, vertexBuffer, <span class="hljs-literal">nullptr</span>);
    vkFreeMemory(device, vertexBufferMemory, <span class="hljs-literal">nullptr</span>);

    ...
}
</div></code></pre>
<h3 id="using-an-index-buffer">Using an index buffer</h3>
<p>Using an index buffer for drawing involves two changes to
<code>recordCommandBuffer</code>. We first need to bind the index buffer, just like we did
for the vertex buffer. The difference is that you can only have a single index
buffer. It's unfortunately not possible to use different indices for each vertex
attribute, so we do still have to completely duplicate vertex data even if just
one attribute varies.</p>
<pre class="hljs"><code><div>vkCmdBindVertexBuffers(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, vertexBuffers, offsets);

vkCmdBindIndexBuffer(commandBuffer, indexBuffer, <span class="hljs-number">0</span>, VK_INDEX_TYPE_UINT16);
</div></code></pre>
<p>An index buffer is bound with <code>vkCmdBindIndexBuffer</code> which has the index buffer,
a byte offset into it, and the type of index data as parameters. As mentioned
before, the possible types are <code>VK_INDEX_TYPE_UINT16</code> and
<code>VK_INDEX_TYPE_UINT32</code>.</p>
<p>Just binding an index buffer doesn't change anything yet, we also need to change
the drawing command to tell Vulkan to use the index buffer. Remove the
<code>vkCmdDraw</code> line and replace it with <code>vkCmdDrawIndexed</code>:</p>
<pre class="hljs"><code><div>vkCmdDrawIndexed(commandBuffer, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(indices.<span class="hljs-built_in">size</span>()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</div></code></pre>
<p>A call to this function is very similar to <code>vkCmdDraw</code>. The first two parameters
specify the number of indices and the number of instances. We're not using
instancing, so just specify <code>1</code> instance. The number of indices represents the
number of vertices that will be passed to the vertex buffer. The next parameter
specifies an offset into the index buffer, using a value of <code>1</code> would cause the
graphics card to start reading at the second index. The second to last parameter
specifies an offset to add to the indices in the index buffer. The final
parameter specifies an offset for instancing, which we're not using.</p>
<p>Now run your program and you should see the following:</p>
<p><img src="images/indexed_rectangle.png" alt=""></p>
<p>You now know how to save memory by reusing vertices with index buffers. This
will become especially important in a future chapter where we're going to load
complex 3D models.</p>
<p>The previous chapter already mentioned that you should allocate multiple
resources like buffers from a single memory allocation, but in fact you should
go a step further. <a href="https://developer.nvidia.com/vulkan-memory-management">Driver developers recommend</a>
that you also store multiple buffers, like the vertex and index buffer, into a
single <code>VkBuffer</code> and use offsets in commands like <code>vkCmdBindVertexBuffers</code>. The
advantage is that your data is more cache friendly in that case, because it's
closer together. It is even possible to reuse the same chunk of memory for
multiple resources if they are not used during the same render operations,
provided that their data is refreshed, of course. This is known as <em>aliasing</em>
and some Vulkan functions have explicit flags to specify that you want to do
this.</p>
<p><a href="/code/21_index_buffer.cpp">C++ code</a> /
<a href="/code/18_shader_vertexbuffer.vert">Vertex shader</a> /
<a href="/code/18_shader_vertexbuffer.frag">Fragment shader</a></p>
<h1 id="6---uniform-buffers">6 - Uniform buffers</h1>
<h2 id="1-descriptor-layout-and-buffer">1. Descriptor layout and buffer</h2>
<h3 id="introduction">Introduction</h3>
<p>We're now able to pass arbitrary attributes to the vertex shader for each
vertex, but what about global variables? We're going to move on to 3D graphics
from this chapter on and that requires a model-view-projection matrix. We could
include it as vertex data, but that's a waste of memory and it would require us
to update the vertex buffer whenever the transformation changes. The
transformation could easily change every single frame.</p>
<p>The right way to tackle this in Vulkan is to use <em>resource descriptors</em>. A
descriptor is a way for shaders to freely access resources like buffers and
images. We're going to set up a buffer that contains the transformation matrices
and have the vertex shader access them through a descriptor. Usage of
descriptors consists of three parts:</p>
<ul>
<li>Specify a descriptor layout during pipeline creation</li>
<li>Allocate a descriptor set from a descriptor pool</li>
<li>Bind the descriptor set during rendering</li>
</ul>
<p>The <em>descriptor layout</em> specifies the types of resources that are going to be
accessed by the pipeline, just like a render pass specifies the types of
attachments that will be accessed. A <em>descriptor set</em> specifies the actual
buffer or image resources that will be bound to the descriptors, just like a
framebuffer specifies the actual image views to bind to render pass attachments.
The descriptor set is then bound for the drawing commands just like the vertex
buffers and framebuffer.</p>
<p>There are many types of descriptors, but in this chapter we'll work with uniform
buffer objects (UBO). We'll look at other types of descriptors in future
chapters, but the basic process is the same. Let's say we have the data we want
the vertex shader to have in a C struct like this:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UniformBufferObject</span> {</span>
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
};
</div></code></pre>
<p>Then we can copy the data to a <code>VkBuffer</code> and access it through a uniform buffer
object descriptor from the vertex shader like this:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject {
    <span class="hljs-type">mat4</span> model;
    <span class="hljs-type">mat4</span> view;
    <span class="hljs-type">mat4</span> proj;
} ubo;

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
    fragColor = inColor;
}
</div></code></pre>
<p>We're going to update the model, view and projection matrices every frame to
make the rectangle from the previous chapter spin around in 3D.</p>
<h3 id="vertex-shader">Vertex shader</h3>
<p>Modify the vertex shader to include the uniform buffer object like it was
specified above. I will assume that you are familiar with MVP transformations.
If you're not, see <a href="https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/">the resource</a>
mentioned in the first chapter.</p>
<pre class="hljs"><code><div><span class="hljs-meta">##version 450</span>

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject {
    <span class="hljs-type">mat4</span> model;
    <span class="hljs-type">mat4</span> view;
    <span class="hljs-type">mat4</span> proj;
} ubo;

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
    fragColor = inColor;
}
</div></code></pre>
<p>Note that the order of the <code>uniform</code>, <code>in</code> and <code>out</code> declarations doesn't
matter. The <code>binding</code> directive is similar to the <code>location</code> directive for
attributes. We're going to reference this binding in the descriptor layout. The
line with <code>gl_Position</code> is changed to use the transformations to compute the
final position in clip coordinates. Unlike the 2D triangles, the last component
of the clip coordinates may not be <code>1</code>, which will result in a division when
converted to the final normalized device coordinates on the screen. This is used
in perspective projection as the <em>perspective division</em> and is essential for
making closer objects look larger than objects that are further away.</p>
<h3 id="descriptor-set-layout">Descriptor set layout</h3>
<p>The next step is to define the UBO on the C++ side and to tell Vulkan about this
descriptor in the vertex shader.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UniformBufferObject</span> {</span>
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
};
</div></code></pre>
<p>We can exactly match the definition in the shader using data types in GLM. The
data in the matrices is binary compatible with the way the shader expects it, so
we can later just <code>memcpy</code> a <code>UniformBufferObject</code> to a <code>VkBuffer</code>.</p>
<p>We need to provide details about every descriptor binding used in the shaders
for pipeline creation, just like we had to do for every vertex attribute and its
<code>location</code> index. We'll set up a new function to define all of this information
called <code>createDescriptorSetLayout</code>. It should be called right before pipeline
creation, because we're going to need it there.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createDescriptorSetLayout();
    createGraphicsPipeline();
    ...
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createDescriptorSetLayout</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>Every binding needs to be described through a <code>VkDescriptorSetLayoutBinding</code>
struct.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createDescriptorSetLayout</span><span class="hljs-params">()</span> </span>{
    VkDescriptorSetLayoutBinding uboLayoutBinding{};
    uboLayoutBinding.binding = <span class="hljs-number">0</span>;
    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    uboLayoutBinding.descriptorCount = <span class="hljs-number">1</span>;
}
</div></code></pre>
<p>The first two fields specify the <code>binding</code> used in the shader and the type of
descriptor, which is a uniform buffer object. It is possible for the shader
variable to represent an array of uniform buffer objects, and <code>descriptorCount</code>
specifies the number of values in the array. This could be used to specify a
transformation for each of the bones in a skeleton for skeletal animation, for
example. Our MVP transformation is in a single uniform buffer object, so we're
using a <code>descriptorCount</code> of <code>1</code>.</p>
<pre class="hljs"><code><div>uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
</div></code></pre>
<p>We also need to specify in which shader stages the descriptor is going to be
referenced. The <code>stageFlags</code> field can be a combination of <code>VkShaderStageFlagBits</code> values
or the value <code>VK_SHADER_STAGE_ALL_GRAPHICS</code>. In our case, we're only referencing
the descriptor from the vertex shader.</p>
<pre class="hljs"><code><div>uboLayoutBinding.pImmutableSamplers = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>The <code>pImmutableSamplers</code> field is only relevant for image sampling related
descriptors, which we'll look at later. You can leave this to its default value.</p>
<p>All of the descriptor bindings are combined into a single
<code>VkDescriptorSetLayout</code> object. Define a new class member above
<code>pipelineLayout</code>:</p>
<pre class="hljs"><code><div>VkDescriptorSetLayout descriptorSetLayout;
VkPipelineLayout pipelineLayout;
</div></code></pre>
<p>We can then create it using <code>vkCreateDescriptorSetLayout</code>. This function accepts
a simple <code>VkDescriptorSetLayoutCreateInfo</code> with the array of bindings:</p>
<pre class="hljs"><code><div>VkDescriptorSetLayoutCreateInfo layoutInfo{};
layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
layoutInfo.bindingCount = <span class="hljs-number">1</span>;
layoutInfo.pBindings = &amp;uboLayoutBinding;

<span class="hljs-keyword">if</span> (vkCreateDescriptorSetLayout(device, &amp;layoutInfo, <span class="hljs-literal">nullptr</span>, &amp;descriptorSetLayout) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create descriptor set layout!"</span>);
}
</div></code></pre>
<p>We need to specify the descriptor set layout during pipeline creation to tell
Vulkan which descriptors the shaders will be using. Descriptor set layouts are
specified in the pipeline layout object. Modify the <code>VkPipelineLayoutCreateInfo</code>
to reference the layout object:</p>
<pre class="hljs"><code><div>VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
pipelineLayoutInfo.setLayoutCount = <span class="hljs-number">1</span>;
pipelineLayoutInfo.pSetLayouts = &amp;descriptorSetLayout;
</div></code></pre>
<p>You may be wondering why it's possible to specify multiple descriptor set
layouts here, because a single one already includes all of the bindings. We'll
get back to that in the next chapter, where we'll look into descriptor pools and
descriptor sets.</p>
<p>The descriptor layout should stick around while we may create new graphics
pipelines i.e. until the program ends:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    cleanupSwapChain();

    vkDestroyDescriptorSetLayout(device, descriptorSetLayout, <span class="hljs-literal">nullptr</span>);

    ...
}
</div></code></pre>
<h3 id="uniform-buffer">Uniform buffer</h3>
<p>In the next chapter we'll specify the buffer that contains the UBO data for the
shader, but we need to create this buffer first. We're going to copy new data to
the uniform buffer every frame, so it doesn't really make any sense to have a
staging buffer. It would just add extra overhead in this case and likely degrade
performance instead of improving it.</p>
<p>We should have multiple buffers, because multiple frames may be in flight at the same
time and we don't want to update the buffer in preparation of the next frame while a
previous one is still reading from it! Thus, we need to have as many uniform buffers
as we have frames in flight, and write to a uniform buffer that is not currently
being read by the GPU</p>
<p>To that end, add new class members for <code>uniformBuffers</code>, and <code>uniformBuffersMemory</code>:</p>
<pre class="hljs"><code><div>VkBuffer indexBuffer;
VkDeviceMemory indexBufferMemory;

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkBuffer&gt; uniformBuffers;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkDeviceMemory&gt; uniformBuffersMemory;
</div></code></pre>
<p>Similarly, create a new function <code>createUniformBuffers</code> that is called after
<code>createIndexBuffer</code> and allocates the buffers:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createVertexBuffer();
    createIndexBuffer();
    createUniformBuffers();
    ...
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createUniformBuffers</span><span class="hljs-params">()</span> </span>{
    VkDeviceSize bufferSize = <span class="hljs-keyword">sizeof</span>(UniformBufferObject);

    uniformBuffers.resize(MAX_FRAMES_IN_FLIGHT);
    uniformBuffersMemory.resize(MAX_FRAMES_IN_FLIGHT);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
        createBuffer(bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, uniformBuffers[i], uniformBuffersMemory[i]);
    }
}
</div></code></pre>
<p>We're going to write a separate function that updates the uniform buffer with a
new transformation every frame, so there will be no <code>vkMapMemory</code> here. The
uniform data will be used for all draw calls, so the buffer containing it should only be destroyed when we stop rendering.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    ...

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
        vkDestroyBuffer(device, uniformBuffers[i], <span class="hljs-literal">nullptr</span>);
        vkFreeMemory(device, uniformBuffersMemory[i], <span class="hljs-literal">nullptr</span>);
    }

    vkDestroyDescriptorSetLayout(device, descriptorSetLayout, <span class="hljs-literal">nullptr</span>);

    ...

}
</div></code></pre>
<h3 id="updating-uniform-data">Updating uniform data</h3>
<p>Create a new function <code>updateUniformBuffer</code> and add a call to it from the <code>drawFrame</code> function right after we know which swap chain image we're going to acquire:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>{
    ...

    <span class="hljs-keyword">uint32_t</span> imageIndex;
    VkResult result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);

    ...

    updateUniformBuffer(imageIndex);

    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    ...
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUniformBuffer</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> currentImage)</span> </span>{

}
</div></code></pre>
<p>This function will generate a new transformation every frame to make the
geometry spin around. We need to include two new headers to implement this
functionality:</p>
<pre class="hljs"><code><div>#<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_RADIANS</span>
#<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/glm.hpp&gt;</span></span>
#<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span>

#<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
</div></code></pre>
<p>The <code>glm/gtc/matrix_transform.hpp</code> header exposes functions that can be used to
generate model transformations like <code>glm::rotate</code>, view transformations like
<code>glm::lookAt</code> and projection transformations like <code>glm::perspective</code>. The
<code>GLM_FORCE_RADIANS</code> definition is necessary to make sure that functions like
<code>glm::rotate</code> use radians as arguments, to avoid any possible confusion.</p>
<p>The <code>chrono</code> standard library header exposes functions to do precise
timekeeping. We'll use this to make sure that the geometry rotates 90 degrees
per second regardless of frame rate.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUniformBuffer</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> currentImage)</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> startTime = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();

    <span class="hljs-keyword">auto</span> currentTime = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
    <span class="hljs-keyword">float</span> time = <span class="hljs-built_in">std</span>::chrono::duration&lt;<span class="hljs-keyword">float</span>, <span class="hljs-built_in">std</span>::chrono::seconds::period&gt;(currentTime - startTime).count();
}
</div></code></pre>
<p>The <code>updateUniformBuffer</code> function will start out with some logic to calculate
the time in seconds since rendering has started with floating point accuracy.</p>
<p>We will now define the model, view and projection transformations in the
uniform buffer object. The model rotation will be a simple rotation around the
Z-axis using the <code>time</code> variable:</p>
<pre class="hljs"><code><div>UniformBufferObject ubo{};
ubo.model = glm::rotate(glm::mat4(<span class="hljs-number">1.0f</span>), time * glm::radians(<span class="hljs-number">90.0f</span>), glm::vec3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>));
</div></code></pre>
<p>The <code>glm::rotate</code> function takes an existing transformation, rotation angle and
rotation axis as parameters. The <code>glm::mat4(1.0f)</code> constructor returns an
identity matrix. Using a rotation angle of <code>time * glm::radians(90.0f)</code>
accomplishes the purpose of rotation 90 degrees per second.</p>
<pre class="hljs"><code><div>ubo.view = glm::lookAt(glm::vec3(<span class="hljs-number">2.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">2.0f</span>), glm::vec3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), glm::vec3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>));
</div></code></pre>
<p>For the view transformation I've decided to look at the geometry from above at a
45 degree angle. The <code>glm::lookAt</code> function takes the eye position, center
position and up axis as parameters.</p>
<pre class="hljs"><code><div>ubo.proj = glm::perspective(glm::radians(<span class="hljs-number">45.0f</span>), swapChainExtent.<span class="hljs-built_in">width</span> / (<span class="hljs-keyword">float</span>) swapChainExtent.<span class="hljs-built_in">height</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">10.0f</span>);
</div></code></pre>
<p>I've chosen to use a perspective projection with a 45 degree vertical
field-of-view. The other parameters are the aspect ratio, near and far
view planes. It is important to use the current swap chain extent to calculate
the aspect ratio to take into account the new width and height of the window
after a resize.</p>
<pre class="hljs"><code><div>ubo.proj[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>;
</div></code></pre>
<p>GLM was originally designed for OpenGL, where the Y coordinate of the clip
coordinates is inverted. The easiest way to compensate for that is to flip the
sign on the scaling factor of the Y axis in the projection matrix. If you don't
do this, then the image will be rendered upside down.</p>
<p>All of the transformations are defined now, so we can copy the data in the
uniform buffer object to the current uniform buffer. This happens in exactly the same
way as we did for vertex buffers, except without a staging buffer:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">void</span>* data;
vkMapMemory(device, uniformBuffersMemory[currentImage], <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ubo), <span class="hljs-number">0</span>, &amp;data);
    <span class="hljs-built_in">memcpy</span>(data, &amp;ubo, <span class="hljs-keyword">sizeof</span>(ubo));
vkUnmapMemory(device, uniformBuffersMemory[currentImage]);
</div></code></pre>
<p>Using a UBO this way is not the most efficient way to pass frequently changing
values to the shader. A more efficient way to pass a small buffer of data to
shaders are <em>push constants</em>. We may look at these in a future chapter.</p>
<p>In the next chapter we'll look at descriptor sets, which will actually bind the
<code>VkBuffer</code>s to the uniform buffer descriptors so that the shader can access this
transformation data.</p>
<p><a href="/code/22_descriptor_layout.cpp">C++ code</a> /
<a href="/code/22_shader_ubo.vert">Vertex shader</a> /
<a href="/code/22_shader_ubo.frag">Fragment shader</a></p>
<h2 id="2-descriptor-pool-and-sets">2. Descriptor pool and sets</h2>
<h3 id="introduction">Introduction</h3>
<p>The descriptor layout from the previous chapter describes the type of
descriptors that can be bound. In this chapter we're going to create
a descriptor set for each <code>VkBuffer</code> resource to bind it to the
uniform buffer descriptor.</p>
<h3 id="descriptor-pool">Descriptor pool</h3>
<p>Descriptor sets can't be created directly, they must be allocated from a pool
like command buffers. The equivalent for descriptor sets is unsurprisingly
called a <em>descriptor pool</em>. We'll write a new function <code>createDescriptorPool</code>
to set it up.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createUniformBuffers();
    createDescriptorPool();
    ...
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createDescriptorPool</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>We first need to describe which descriptor types our descriptor sets are going
to contain and how many of them, using <code>VkDescriptorPoolSize</code> structures.</p>
<pre class="hljs"><code><div>VkDescriptorPoolSize poolSize{};
poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
poolSize.descriptorCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);
</div></code></pre>
<p>We will allocate one of these descriptors for every frame. This
pool size structure is referenced by the main <code>VkDescriptorPoolCreateInfo</code>:</p>
<pre class="hljs"><code><div>VkDescriptorPoolCreateInfo poolInfo{};
poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
poolInfo.poolSizeCount = <span class="hljs-number">1</span>;
poolInfo.pPoolSizes = &amp;poolSize;
</div></code></pre>
<p>Aside from the maximum number of individual descriptors that are available, we
also need to specify the maximum number of descriptor sets that may be
allocated:</p>
<pre class="hljs"><code><div>poolInfo.maxSets = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);
</div></code></pre>
<p>The structure has an optional flag similar to command pools that determines if
individual descriptor sets can be freed or not:
<code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code>. We're not going to touch
the descriptor set after creating it, so we don't need this flag. You can leave
<code>flags</code> to its default value of <code>0</code>.</p>
<pre class="hljs"><code><div>VkDescriptorPool descriptorPool;

...

<span class="hljs-keyword">if</span> (vkCreateDescriptorPool(device, &amp;poolInfo, <span class="hljs-literal">nullptr</span>, &amp;descriptorPool) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create descriptor pool!"</span>);
}
</div></code></pre>
<p>Add a new class member to store the handle of the descriptor pool and call
<code>vkCreateDescriptorPool</code> to create it.</p>
<h3 id="descriptor-set">Descriptor set</h3>
<p>We can now allocate the descriptor sets themselves. Add a <code>createDescriptorSets</code>
function for that purpose:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createDescriptorPool();
    createDescriptorSets();
    ...
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createDescriptorSets</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>A descriptor set allocation is described with a <code>VkDescriptorSetAllocateInfo</code>
struct. You need to specify the descriptor pool to allocate from, the number of
descriptor sets to allocate, and the descriptor layout to base them on:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkDescriptorSetLayout&gt; <span class="hljs-title">layouts</span><span class="hljs-params">(MAX_FRAMES_IN_FLIGHT, descriptorSetLayout)</span></span>;
VkDescriptorSetAllocateInfo allocInfo{};
allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
allocInfo.descriptorPool = descriptorPool;
allocInfo.descriptorSetCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);
allocInfo.pSetLayouts = layouts.data();
</div></code></pre>
<p>In our case we will create one descriptor set for each frame in flight, all with the same layout.
Unfortunately we do need all the copies of the layout because the next function expects an array matching the number of sets.</p>
<p>Add a class member to hold the descriptor set handles and allocate them with
<code>vkAllocateDescriptorSets</code>:</p>
<pre class="hljs"><code><div>VkDescriptorPool descriptorPool;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkDescriptorSet&gt; descriptorSets;

...

descriptorSets.resize(MAX_FRAMES_IN_FLIGHT);
<span class="hljs-keyword">if</span> (vkAllocateDescriptorSets(device, &amp;allocInfo, descriptorSets.data()) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to allocate descriptor sets!"</span>);
}
</div></code></pre>
<p>You don't need to explicitly clean up descriptor sets, because they will be
automatically freed when the descriptor pool is destroyed. The call to
<code>vkAllocateDescriptorSets</code> will allocate descriptor sets, each with one uniform
buffer descriptor.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    ...
    vkDestroyDescriptorPool(device, descriptorPool, <span class="hljs-literal">nullptr</span>);

    vkDestroyDescriptorSetLayout(device, descriptorSetLayout, <span class="hljs-literal">nullptr</span>);
    ...
}
</div></code></pre>
<p>The descriptor sets have been allocated now, but the descriptors within still need
to be configured. We'll now add a loop to populate every descriptor:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {

}
</div></code></pre>
<p>Descriptors that refer to buffers, like our uniform buffer
descriptor, are configured with a <code>VkDescriptorBufferInfo</code> struct. This
structure specifies the buffer and the region within it that contains the data
for the descriptor.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
    VkDescriptorBufferInfo bufferInfo{};
    bufferInfo.<span class="hljs-built_in">buffer</span> = uniformBuffers[i];
    bufferInfo.offset = <span class="hljs-number">0</span>;
    bufferInfo.range = <span class="hljs-keyword">sizeof</span>(UniformBufferObject);
}
</div></code></pre>
<p>If you're overwriting the whole buffer, like we are in this case, then it is is also possible to use the <code>VK_WHOLE_SIZE</code> value for the range. The configuration of descriptors is updated using the <code>vkUpdateDescriptorSets</code>
function, which takes an array of <code>VkWriteDescriptorSet</code> structs as parameter.</p>
<pre class="hljs"><code><div>VkWriteDescriptorSet descriptorWrite{};
descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
descriptorWrite.dstSet = descriptorSets[i];
descriptorWrite.dstBinding = <span class="hljs-number">0</span>;
descriptorWrite.dstArrayElement = <span class="hljs-number">0</span>;
</div></code></pre>
<p>The first two fields specify the descriptor set to update and the binding. We
gave our uniform buffer binding index <code>0</code>. Remember that descriptors can be
arrays, so we also need to specify the first index in the array that we want to
update. We're not using an array, so the index is simply <code>0</code>.</p>
<pre class="hljs"><code><div>descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
descriptorWrite.descriptorCount = <span class="hljs-number">1</span>;
</div></code></pre>
<p>We need to specify the type of descriptor again. It's possible to update
multiple descriptors at once in an array, starting at index <code>dstArrayElement</code>.
The <code>descriptorCount</code> field specifies how many array elements you want to
update.</p>
<pre class="hljs"><code><div>descriptorWrite.pBufferInfo = &amp;bufferInfo;
descriptorWrite.pImageInfo = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
descriptorWrite.pTexelBufferView = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>The last field references an array with <code>descriptorCount</code> structs that actually
configure the descriptors. It depends on the type of descriptor which one of the
three you actually need to use. The <code>pBufferInfo</code> field is used for descriptors
that refer to buffer data, <code>pImageInfo</code> is used for descriptors that refer to
image data, and <code>pTexelBufferView</code> is used for descriptors that refer to buffer
views. Our descriptor is based on buffers, so we're using <code>pBufferInfo</code>.</p>
<pre class="hljs"><code><div>vkUpdateDescriptorSets(device, <span class="hljs-number">1</span>, &amp;descriptorWrite, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<p>The updates are applied using <code>vkUpdateDescriptorSets</code>. It accepts two kinds of
arrays as parameters: an array of <code>VkWriteDescriptorSet</code> and an array of
<code>VkCopyDescriptorSet</code>. The latter can be used to copy descriptors to each other,
as its name implies.</p>
<h3 id="using-descriptor-sets">Using descriptor sets</h3>
<p>We now need to update the <code>recordCommandBuffer</code> function to actually bind the
right descriptor set for each frame to the descriptors in the shader with <code>vkCmdBindDescriptorSets</code>. This needs to be done before the <code>vkCmdDrawIndexed</code> call:</p>
<pre class="hljs"><code><div>vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptorSets[currentFrame], <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);
vkCmdDrawIndexed(commandBuffer, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(indices.<span class="hljs-built_in">size</span>()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</div></code></pre>
<p>Unlike vertex and index buffers, descriptor sets are not unique to graphics
pipelines. Therefore we need to specify if we want to bind descriptor sets to
the graphics or compute pipeline. The next parameter is the layout that the
descriptors are based on. The next three parameters specify the index of the
first descriptor set, the number of sets to bind, and the array of sets to bind.
We'll get back to this in a moment. The last two parameters specify an array of
offsets that are used for dynamic descriptors. We'll look at these in a future
chapter.</p>
<p>If you run your program now, then you'll notice that unfortunately nothing is
visible. The problem is that because of the Y-flip we did in the projection
matrix, the vertices are now being drawn in counter-clockwise order instead of
clockwise order. This causes backface culling to kick in and prevents
any geometry from being drawn. Go to the <code>createGraphicsPipeline</code> function and
modify the <code>frontFace</code> in <code>VkPipelineRasterizationStateCreateInfo</code> to correct
this:</p>
<pre class="hljs"><code><div>rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
</div></code></pre>
<p>Run your program again and you should now see the following:</p>
<p><img src="images/spinning_quad.png" alt=""></p>
<p>The rectangle has changed into a square because the projection matrix now
corrects for aspect ratio. The <code>updateUniformBuffer</code> takes care of screen
resizing, so we don't need to recreate the descriptor set in
<code>recreateSwapChain</code>.</p>
<h3 id="alignment-requirements">Alignment requirements</h3>
<p>One thing we've glossed over so far is how exactly the data in the C++ structure should match with the uniform definition in the shader. It seems obvious enough to simply use the same types in both:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UniformBufferObject</span> {</span>
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
};

layout(binding = <span class="hljs-number">0</span>) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;
</div></code></pre>
<p>However, that's not all there is to it. For example, try modifying the struct and shader to look like this:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UniformBufferObject</span> {</span>
    glm::vec2 foo;
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
};

layout(binding = <span class="hljs-number">0</span>) uniform UniformBufferObject {
    vec2 foo;
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;
</div></code></pre>
<p>Recompile your shader and your program and run it and you'll find that the colorful square you worked so far has disappeared! That's because we haven't taken into account the <em>alignment requirements</em>.</p>
<p>Vulkan expects the data in your structure to be aligned in memory in a specific way, for example:</p>
<ul>
<li>Scalars have to be aligned by N (= 4 bytes given 32 bit floats).</li>
<li>A <code>vec2</code> must be aligned by 2N (= 8 bytes)</li>
<li>A <code>vec3</code> or <code>vec4</code> must be aligned by 4N (= 16 bytes)</li>
<li>A nested structure must be aligned by the base alignment of its members rounded up to a multiple of 16.</li>
<li>A <code>mat4</code> matrix must have the same alignment as a <code>vec4</code>.</li>
</ul>
<p>You can find the full list of alignment requirements in <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-resources-layout">the specification</a>.</p>
<p>Our original shader with just three <code>mat4</code> fields already met the alignment requirements. As each <code>mat4</code> is 4 x 4 x 4 = 64 bytes in size, <code>model</code> has an offset of <code>0</code>, <code>view</code> has an offset of 64 and <code>proj</code> has an offset of 128. All of these are multiples of 16 and that's why it worked fine.</p>
<p>The new structure starts with a <code>vec2</code> which is only 8 bytes in size and therefore throws off all of the offsets. Now <code>model</code> has an offset of <code>8</code>, <code>view</code> an offset of <code>72</code> and <code>proj</code> an offset of <code>136</code>, none of which are multiples of 16. To fix this problem we can use the <a href="https://en.cppreference.com/w/cpp/language/alignas"><code>alignas</code></a> specifier introduced in C++11:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UniformBufferObject</span> {</span>
    glm::vec2 foo;
    <span class="hljs-keyword">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
};
</div></code></pre>
<p>If you now compile and run your program again you should see that the shader correctly receives its matrix values once again.</p>
<p>Luckily there is a way to not have to think about these alignment requirements <em>most</em> of the time. We can define <code>GLM_FORCE_DEFAULT_ALIGNED_GENTYPES</code> right before including GLM:</p>
<pre class="hljs"><code><div>#<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_RADIANS</span>
#<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_DEFAULT_ALIGNED_GENTYPES</span>
#<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/glm.hpp&gt;</span></span>
</div></code></pre>
<p>This will force GLM to use a version of <code>vec2</code> and <code>mat4</code> that has the alignment requirements already specified for us. If you add this definition then you can remove the <code>alignas</code> specifier and your program should still work.</p>
<p>Unfortunately this method can break down if you start using nested structures. Consider the following definition in the C++ code:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span> {</span>
    glm::vec2 v;
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UniformBufferObject</span> {</span>
    Foo f1;
    Foo f2;
};
</div></code></pre>
<p>And the following shader definition:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span> {</span>
    vec2 v;
};

layout(binding = <span class="hljs-number">0</span>) uniform UniformBufferObject {
    Foo f1;
    Foo f2;
} ubo;
</div></code></pre>
<p>In this case <code>f2</code> will have an offset of <code>8</code> whereas it should have an offset of <code>16</code> since it is a nested structure. In this case you must specify the alignment yourself:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UniformBufferObject</span> {</span>
    Foo f1;
    <span class="hljs-keyword">alignas</span>(<span class="hljs-number">16</span>) Foo f2;
};
</div></code></pre>
<p>These gotchas are a good reason to always be explicit about alignment. That way you won't be caught offguard by the strange symptoms of alignment errors.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UniformBufferObject</span> {</span>
    <span class="hljs-keyword">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 model;
    <span class="hljs-keyword">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 view;
    <span class="hljs-keyword">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 proj;
};
</div></code></pre>
<p>Don't forget to recompile your shader after removing the <code>foo</code> field.</p>
<h3 id="multiple-descriptor-sets">Multiple descriptor sets</h3>
<p>As some of the structures and function calls hinted at, it is actually possible
to bind multiple descriptor sets simultaneously. You need to specify a descriptor layout for
each descriptor set when creating the pipeline layout. Shaders can then
reference specific descriptor sets like this:</p>
<pre class="hljs"><code><div>layout(<span class="hljs-built_in">set</span> = <span class="hljs-number">0</span>, binding = <span class="hljs-number">0</span>) uniform UniformBufferObject { ... }
</div></code></pre>
<p>You can use this feature to put descriptors that vary per-object and descriptors
that are shared into separate descriptor sets. In that case you avoid rebinding
most of the descriptors across draw calls which is potentially more efficient.</p>
<p><a href="/code/23_descriptor_sets.cpp">C++ code</a> /
<a href="/code/22_shader_ubo.vert">Vertex shader</a> /
<a href="/code/22_shader_ubo.frag">Fragment shader</a></p>
<h1 id="7---texture-mapping">7 - Texture mapping</h1>
<h2 id="1-images">1. Images</h2>
<h3 id="introduction">Introduction</h3>
<p>The geometry has been colored using per-vertex colors so far, which is a rather
limited approach. In this part of the tutorial we're going to implement texture
mapping to make the geometry look more interesting. This will also allow us to
load and draw basic 3D models in a future chapter.</p>
<p>Adding a texture to our application will involve the following steps:</p>
<ul>
<li>Create an image object backed by device memory</li>
<li>Fill it with pixels from an image file</li>
<li>Create an image sampler</li>
<li>Add a combined image sampler descriptor to sample colors from the texture</li>
</ul>
<p>We've already worked with image objects before, but those were automatically
created by the swap chain extension. This time we'll have to create one by
ourselves. Creating an image and filling it with data is similar to vertex
buffer creation. We'll start by creating a staging resource and filling it with
pixel data and then we copy this to the final image object that we'll use for
rendering. Although it is possible to create a staging image for this purpose,
Vulkan also allows you to copy pixels from a <code>VkBuffer</code> to an image and the API
for this is actually <a href="https://developer.nvidia.com/vulkan-memory-management">faster on some hardware</a>.
We'll first create this buffer and fill it with pixel values, and then we'll
create an image to copy the pixels to. Creating an image is not very different
from creating buffers. It involves querying the memory requirements, allocating
device memory and binding it, just like we've seen before.</p>
<p>However, there is something extra that we'll have to take care of when working
with images. Images can have different <em>layouts</em> that affect how the pixels are
organized in memory. Due to the way graphics hardware works, simply storing the
pixels row by row may not lead to the best performance, for example. When
performing any operation on images, you must make sure that they have the layout
that is optimal for use in that operation. We've actually already seen some of
these layouts when we specified the render pass:</p>
<ul>
<li><code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code>: Optimal for presentation</li>
<li><code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code>: Optimal as attachment for writing
colors from the fragment shader</li>
<li><code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code>: Optimal as source in a transfer
operation, like <code>vkCmdCopyImageToBuffer</code></li>
<li><code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>: Optimal as destination in a transfer
operation, like <code>vkCmdCopyBufferToImage</code></li>
<li><code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>: Optimal for sampling from a shader</li>
</ul>
<p>One of the most common ways to transition the layout of an image is a <em>pipeline
barrier</em>. Pipeline barriers are primarily used for synchronizing access to
resources, like making sure that an image was written to before it is read, but
they can also be used to transition layouts. In this chapter we'll see how
pipeline barriers are used for this purpose. Barriers can additionally be used
to transfer queue family ownership when using <code>VK_SHARING_MODE_EXCLUSIVE</code>.</p>
<h3 id="image-library">Image library</h3>
<p>There are many libraries available for loading images, and you can even write
your own code to load simple formats like BMP and PPM. In this tutorial we'll be
using the stb_image library from the <a href="https://github.com/nothings/stb">stb collection</a>.
The advantage of it is that all of the code is in a single file, so it doesn't
require any tricky build configuration. Download <code>stb_image.h</code> and store it in a
convenient location, like the directory where you saved GLFW and GLM. Add the
location to your include path.</p>
<p><strong>Visual Studio</strong></p>
<p>Add the directory with <code>stb_image.h</code> in it to the <code>Additional Include Directories</code> paths.</p>
<p><img src="images/include_dirs_stb.png" alt=""></p>
<p><strong>Makefile</strong></p>
<p>Add the directory with <code>stb_image.h</code> to the include directories for GCC:</p>
<pre class="hljs"><code><div>VULKAN_SDK_PATH = /home/user/VulkanSDK/x.x.x.x/x86_64
STB_INCLUDE_PATH = /home/user/libraries/stb

...

CFLAGS = -std=c++17 -I$(VULKAN_SDK_PATH)/include -I$(STB_INCLUDE_PATH)
</div></code></pre>
<h3 id="loading-an-image">Loading an image</h3>
<p>Include the image library like this:</p>
<pre class="hljs"><code><div>#<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span>
#<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stb_image.h&gt;</span></span>
</div></code></pre>
<p>The header only defines the prototypes of the functions by default. One code
file needs to include the header with the <code>STB_IMAGE_IMPLEMENTATION</code> definition
to include the function bodies, otherwise we'll get linking errors.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createCommandPool();
    createTextureImage();
    createVertexBuffer();
    ...
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>Create a new function <code>createTextureImage</code> where we'll load an image and upload
it into a Vulkan image object. We're going to use command buffers, so it should
be called after <code>createCommandPool</code>.</p>
<p>Create a new directory <code>textures</code> next to the <code>shaders</code> directory to store
texture images in. We're going to load an image called <code>texture.jpg</code> from that
directory. I've chosen to use the following
<a href="https://pixabay.com/en/statue-sculpture-fig-historically-1275469/">CC0 licensed image</a>
resized to 512 x 512 pixels, but feel free to pick any image you want. The
library supports most common image file formats, like JPEG, PNG, BMP and GIF.</p>
<p><img src="images/texture.jpg" alt=""></p>
<p>Loading an image with this library is really easy:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> texWidth, texHeight, texChannels;
    stbi_uc* pixels = stbi_load(<span class="hljs-string">"textures/texture.jpg"</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);
    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;

    <span class="hljs-keyword">if</span> (!pixels) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to load texture image!"</span>);
    }
}
</div></code></pre>
<p>The <code>stbi_load</code> function takes the file path and number of channels to load as
arguments. The <code>STBI_rgb_alpha</code> value forces the image to be loaded with an
alpha channel, even if it doesn't have one, which is nice for consistency with
other textures in the future. The middle three parameters are outputs for the
width, height and actual number of channels in the image. The pointer that is
returned is the first element in an array of pixel values. The pixels are laid
out row by row with 4 bytes per pixel in the case of <code>STBI_rgb_alpha</code> for a
total of <code>texWidth * texHeight * 4</code> values.</p>
<h3 id="staging-buffer">Staging buffer</h3>
<p>We're now going to create a buffer in host visible memory so that we can use
<code>vkMapMemory</code> and copy the pixels to it. Add variables for this temporary buffer
to the <code>createTextureImage</code> function:</p>
<pre class="hljs"><code><div>VkBuffer stagingBuffer;
VkDeviceMemory stagingBufferMemory;
</div></code></pre>
<p>The buffer should be in host visible memory so that we can map it and it should
be usable as a transfer source so that we can copy it to an image later on:</p>
<pre class="hljs"><code><div>createBuffer(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);
</div></code></pre>
<p>We can then directly copy the pixel values that we got from the image loading
library to the buffer:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">void</span>* data;
vkMapMemory(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);
    <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(imageSize));
vkUnmapMemory(device, stagingBufferMemory);
</div></code></pre>
<p>Don't forget to clean up the original pixel array now:</p>
<pre class="hljs"><code><div>stbi_image_free(pixels);
</div></code></pre>
<h3 id="texture-image">Texture Image</h3>
<p>Although we could set up the shader to access the pixel values in the buffer,
it's better to use image objects in Vulkan for this purpose. Image objects will
make it easier and faster to retrieve colors by allowing us to use 2D
coordinates, for one. Pixels within an image object are known as texels and
we'll use that name from this point on. Add the following new class members:</p>
<pre class="hljs"><code><div>VkImage textureImage;
VkDeviceMemory textureImageMemory;
</div></code></pre>
<p>The parameters for an image are specified in a <code>VkImageCreateInfo</code> struct:</p>
<pre class="hljs"><code><div>VkImageCreateInfo imageInfo{};
imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
imageInfo.imageType = VK_IMAGE_TYPE_2D;
imageInfo.extent.<span class="hljs-built_in">width</span> = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(texWidth);
imageInfo.extent.<span class="hljs-built_in">height</span> = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(texHeight);
imageInfo.extent.depth = <span class="hljs-number">1</span>;
imageInfo.mipLevels = <span class="hljs-number">1</span>;
imageInfo.arrayLayers = <span class="hljs-number">1</span>;
</div></code></pre>
<p>The image type, specified in the <code>imageType</code> field, tells Vulkan with what kind
of coordinate system the texels in the image are going to be addressed. It is
possible to create 1D, 2D and 3D images. One dimensional images can be used to
store an array of data or gradient, two dimensional images are mainly used for
textures, and three dimensional images can be used to store voxel volumes, for
example. The <code>extent</code> field specifies the dimensions of the image, basically how
many texels there are on each axis. That's why <code>depth</code> must be <code>1</code> instead of
<code>0</code>. Our texture will not be an array and we won't be using mipmapping for now.</p>
<pre class="hljs"><code><div>imageInfo.format = VK_FORMAT_R8G8B8A8_SRGB;
</div></code></pre>
<p>Vulkan supports many possible image formats, but we should use the same format
for the texels as the pixels in the buffer, otherwise the copy operation will
fail.</p>
<pre class="hljs"><code><div>imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
</div></code></pre>
<p>The <code>tiling</code> field can have one of two values:</p>
<ul>
<li><code>VK_IMAGE_TILING_LINEAR</code>: Texels are laid out in row-major order like our
<code>pixels</code> array</li>
<li><code>VK_IMAGE_TILING_OPTIMAL</code>: Texels are laid out in an implementation defined
order for optimal access</li>
</ul>
<p>Unlike the layout of an image, the tiling mode cannot be changed at a later
time. If you want to be able to directly access texels in the memory of the
image, then you must use <code>VK_IMAGE_TILING_LINEAR</code>. We will be using a staging
buffer instead of a staging image, so this won't be necessary. We will be using
<code>VK_IMAGE_TILING_OPTIMAL</code> for efficient access from the shader.</p>
<pre class="hljs"><code><div>imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
</div></code></pre>
<p>There are only two possible values for the <code>initialLayout</code> of an image:</p>
<ul>
<li><code>VK_IMAGE_LAYOUT_UNDEFINED</code>: Not usable by the GPU and the very first
transition will discard the texels.</li>
<li><code>VK_IMAGE_LAYOUT_PREINITIALIZED</code>: Not usable by the GPU, but the first
transition will preserve the texels.</li>
</ul>
<p>There are few situations where it is necessary for the texels to be preserved
during the first transition. One example, however, would be if you wanted to use
an image as a staging image in combination with the <code>VK_IMAGE_TILING_LINEAR</code>
layout. In that case, you'd want to upload the texel data to it and then
transition the image to be a transfer source without losing the data. In our
case, however, we're first going to transition the image to be a transfer
destination and then copy texel data to it from a buffer object, so we don't
need this property and can safely use <code>VK_IMAGE_LAYOUT_UNDEFINED</code>.</p>
<pre class="hljs"><code><div>imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
</div></code></pre>
<p>The <code>usage</code> field has the same semantics as the one during buffer creation. The
image is going to be used as destination for the buffer copy, so it should be
set up as a transfer destination. We also want to be able to access the image
from the shader to color our mesh, so the usage should include
<code>VK_IMAGE_USAGE_SAMPLED_BIT</code>.</p>
<pre class="hljs"><code><div>imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
</div></code></pre>
<p>The image will only be used by one queue family: the one that supports graphics
(and therefore also) transfer operations.</p>
<pre class="hljs"><code><div>imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
imageInfo.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>The <code>samples</code> flag is related to multisampling. This is only relevant for images
that will be used as attachments, so stick to one sample. There are some
optional flags for images that are related to sparse images. Sparse images are
images where only certain regions are actually backed by memory. If you were
using a 3D texture for a voxel terrain, for example, then you could use this to
avoid allocating memory to store large volumes of &quot;air&quot; values. We won't be
using it in this tutorial, so leave it to its default value of <code>0</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkCreateImage(device, &amp;imageInfo, <span class="hljs-literal">nullptr</span>, &amp;textureImage) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create image!"</span>);
}
</div></code></pre>
<p>The image is created using <code>vkCreateImage</code>, which doesn't have any particularly
noteworthy parameters. It is possible that the <code>VK_FORMAT_R8G8B8A8_SRGB</code> format
is not supported by the graphics hardware. You should have a list of acceptable
alternatives and go with the best one that is supported. However, support for
this particular format is so widespread that we'll skip this step. Using
different formats would also require annoying conversions. We will get back to
this in the depth buffer chapter, where we'll implement such a system.</p>
<pre class="hljs"><code><div>VkMemoryRequirements memRequirements;
vkGetImageMemoryRequirements(device, textureImage, &amp;memRequirements);

VkMemoryAllocateInfo allocInfo{};
allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
allocInfo.allocationSize = memRequirements.<span class="hljs-built_in">size</span>;
allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

<span class="hljs-keyword">if</span> (vkAllocateMemory(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;textureImageMemory) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to allocate image memory!"</span>);
}

vkBindImageMemory(device, textureImage, textureImageMemory, <span class="hljs-number">0</span>);
</div></code></pre>
<p>Allocating memory for an image works in exactly the same way as allocating
memory for a buffer. Use <code>vkGetImageMemoryRequirements</code> instead of
<code>vkGetBufferMemoryRequirements</code>, and use <code>vkBindImageMemory</code> instead of
<code>vkBindBufferMemory</code>.</p>
<p>This function is already getting quite large and there'll be a need to create
more images in later chapters, so we should abstract image creation into a
<code>createImage</code> function, like we did for buffers. Create the function and move
the image object creation and memory allocation to it:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createImage</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">width</span>, <span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">height</span>, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; <span class="hljs-built_in">image</span>, VkDeviceMemory&amp; imageMemory)</span> </span>{
    VkImageCreateInfo imageInfo{};
    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageInfo.imageType = VK_IMAGE_TYPE_2D;
    imageInfo.extent.<span class="hljs-built_in">width</span> = <span class="hljs-built_in">width</span>;
    imageInfo.extent.<span class="hljs-built_in">height</span> = <span class="hljs-built_in">height</span>;
    imageInfo.extent.depth = <span class="hljs-number">1</span>;
    imageInfo.mipLevels = <span class="hljs-number">1</span>;
    imageInfo.arrayLayers = <span class="hljs-number">1</span>;
    imageInfo.format = format;
    imageInfo.tiling = tiling;
    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    imageInfo.usage = usage;
    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    <span class="hljs-keyword">if</span> (vkCreateImage(device, &amp;imageInfo, <span class="hljs-literal">nullptr</span>, &amp;<span class="hljs-built_in">image</span>) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create image!"</span>);
    }

    VkMemoryRequirements memRequirements;
    vkGetImageMemoryRequirements(device, <span class="hljs-built_in">image</span>, &amp;memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.<span class="hljs-built_in">size</span>;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    <span class="hljs-keyword">if</span> (vkAllocateMemory(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;imageMemory) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to allocate image memory!"</span>);
    }

    vkBindImageMemory(device, <span class="hljs-built_in">image</span>, imageMemory, <span class="hljs-number">0</span>);
}
</div></code></pre>
<p>I've made the width, height, format, tiling mode, usage, and memory properties
parameters, because these will all vary between the images we'll be creating
throughout this tutorial.</p>
<p>The <code>createTextureImage</code> function can now be simplified to:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> texWidth, texHeight, texChannels;
    stbi_uc* pixels = stbi_load(<span class="hljs-string">"textures/texture.jpg"</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);
    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;

    <span class="hljs-keyword">if</span> (!pixels) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to load texture image!"</span>);
    }

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    createBuffer(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

    <span class="hljs-keyword">void</span>* data;
    vkMapMemory(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);
        <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(imageSize));
    vkUnmapMemory(device, stagingBufferMemory);

    stbi_image_free(pixels);

    createImage(texWidth, texHeight, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);
}
</div></code></pre>
<h3 id="layout-transitions">Layout transitions</h3>
<p>The function we're going to write now involves recording and executing a command
buffer again, so now's a good time to move that logic into a helper function or
two:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkCommandBuffer <span class="hljs-title">beginSingleTimeCommands</span><span class="hljs-params">()</span> </span>{
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandPool = commandPool;
    allocInfo.commandBufferCount = <span class="hljs-number">1</span>;

    VkCommandBuffer commandBuffer;
    vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer);

    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

    vkBeginCommandBuffer(commandBuffer, &amp;beginInfo);

    <span class="hljs-keyword">return</span> commandBuffer;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">endSingleTimeCommands</span><span class="hljs-params">(VkCommandBuffer commandBuffer)</span> </span>{
    vkEndCommandBuffer(commandBuffer);

    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = <span class="hljs-number">1</span>;
    submitInfo.pCommandBuffers = &amp;commandBuffer;

    vkQueueSubmit(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(graphicsQueue);

    vkFreeCommandBuffers(device, commandPool, <span class="hljs-number">1</span>, &amp;commandBuffer);
}
</div></code></pre>
<p>The code for these functions is based on the existing code in <code>copyBuffer</code>. You
can now simplify that function to:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copyBuffer</span><span class="hljs-params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize <span class="hljs-built_in">size</span>)</span> </span>{
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkBufferCopy copyRegion{};
    copyRegion.<span class="hljs-built_in">size</span> = <span class="hljs-built_in">size</span>;
    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, <span class="hljs-number">1</span>, &amp;copyRegion);

    endSingleTimeCommands(commandBuffer);
}
</div></code></pre>
<p>If we were still using buffers, then we could now write a function to record and
execute <code>vkCmdCopyBufferToImage</code> to finish the job, but this command requires
the image to be in the right layout first. Create a new function to handle
layout transitions:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transitionImageLayout</span><span class="hljs-params">(VkImage <span class="hljs-built_in">image</span>, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</span> </span>{
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    endSingleTimeCommands(commandBuffer);
}
</div></code></pre>
<p>One of the most common ways to perform layout transitions is using an <em>image
memory barrier</em>. A pipeline barrier like that is generally used to synchronize
access to resources, like ensuring that a write to a buffer completes before
reading from it, but it can also be used to transition image layouts and
transfer queue family ownership when <code>VK_SHARING_MODE_EXCLUSIVE</code> is used. There
is an equivalent <em>buffer memory barrier</em> to do this for buffers.</p>
<pre class="hljs"><code><div>VkImageMemoryBarrier barrier{};
barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
barrier.oldLayout = oldLayout;
barrier.newLayout = newLayout;
</div></code></pre>
<p>The first two fields specify layout transition. It is possible to use
<code>VK_IMAGE_LAYOUT_UNDEFINED</code> as <code>oldLayout</code> if you don't care about the existing
contents of the image.</p>
<pre class="hljs"><code><div>barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
</div></code></pre>
<p>If you are using the barrier to transfer queue family ownership, then these two
fields should be the indices of the queue families. They must be set to
<code>VK_QUEUE_FAMILY_IGNORED</code> if you don't want to do this (not the default value!).</p>
<pre class="hljs"><code><div>barrier.<span class="hljs-built_in">image</span> = <span class="hljs-built_in">image</span>;
barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
barrier.subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;
barrier.subresourceRange.levelCount = <span class="hljs-number">1</span>;
barrier.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;
barrier.subresourceRange.layerCount = <span class="hljs-number">1</span>;
</div></code></pre>
<p>The <code>image</code> and <code>subresourceRange</code> specify the image that is affected and the
specific part of the image. Our image is not an array and does not have mipmapping
levels, so only one level and layer are specified.</p>
<pre class="hljs"><code><div>barrier.srcAccessMask = <span class="hljs-number">0</span>; <span class="hljs-comment">// TODO</span>
barrier.dstAccessMask = <span class="hljs-number">0</span>; <span class="hljs-comment">// TODO</span>
</div></code></pre>
<p>Barriers are primarily used for synchronization purposes, so you must specify
which types of operations that involve the resource must happen before the
barrier, and which operations that involve the resource must wait on the
barrier. We need to do that despite already using <code>vkQueueWaitIdle</code> to manually
synchronize. The right values depend on the old and new layout, so we'll get
back to this once we've figured out which transitions we're going to use.</p>
<pre class="hljs"><code><div>vkCmdPipelineBarrier(
    commandBuffer,
    <span class="hljs-number">0</span> <span class="hljs-comment">/* TODO */</span>, <span class="hljs-number">0</span> <span class="hljs-comment">/* TODO */</span>,
    <span class="hljs-number">0</span>,
    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,
    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,
    <span class="hljs-number">1</span>, &amp;barrier
);
</div></code></pre>
<p>All types of pipeline barriers are submitted using the same function. The first
parameter after the command buffer specifies in which pipeline stage the
operations occur that should happen before the barrier. The second parameter
specifies the pipeline stage in which operations will wait on the barrier. The
pipeline stages that you are allowed to specify before and after the barrier
depend on how you use the resource before and after the barrier. The allowed
values are listed in <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap7.html#synchronization-access-types-supported">this table</a>
of the specification. For example, if you're going to read from a uniform after
the barrier, you would specify a usage of <code>VK_ACCESS_UNIFORM_READ_BIT</code> and the
earliest shader that will read from the uniform as pipeline stage, for example
<code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code>. It would not make sense to specify
a non-shader pipeline stage for this type of usage and the validation layers
will warn you when you specify a pipeline stage that does not match the type of
usage.</p>
<p>The third parameter is either <code>0</code> or <code>VK_DEPENDENCY_BY_REGION_BIT</code>. The latter
turns the barrier into a per-region condition. That means that the
implementation is allowed to already begin reading from the parts of a resource
that were written so far, for example.</p>
<p>The last three pairs of parameters reference arrays of pipeline barriers of the
three available types: memory barriers, buffer memory barriers, and image memory
barriers like the one we're using here. Note that we're not using the <code>VkFormat</code>
parameter yet, but we'll be using that one for special transitions in the depth
buffer chapter.</p>
<h3 id="copying-buffer-to-image">Copying buffer to image</h3>
<p>Before we get back to <code>createTextureImage</code>, we're going to write one more helper
function: <code>copyBufferToImage</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copyBufferToImage</span><span class="hljs-params">(VkBuffer <span class="hljs-built_in">buffer</span>, VkImage <span class="hljs-built_in">image</span>, <span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">width</span>, <span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">height</span>)</span> </span>{
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    endSingleTimeCommands(commandBuffer);
}
</div></code></pre>
<p>Just like with buffer copies, you need to specify which part of the buffer is
going to be copied to which part of the image. This happens through
<code>VkBufferImageCopy</code> structs:</p>
<pre class="hljs"><code><div>VkBufferImageCopy region{};
region.bufferOffset = <span class="hljs-number">0</span>;
region.bufferRowLength = <span class="hljs-number">0</span>;
region.bufferImageHeight = <span class="hljs-number">0</span>;

region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
region.imageSubresource.mipLevel = <span class="hljs-number">0</span>;
region.imageSubresource.baseArrayLayer = <span class="hljs-number">0</span>;
region.imageSubresource.layerCount = <span class="hljs-number">1</span>;

region.imageOffset = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>};
region.imageExtent = {
    <span class="hljs-built_in">width</span>,
    <span class="hljs-built_in">height</span>,
    <span class="hljs-number">1</span>
};
</div></code></pre>
<p>Most of these fields are self-explanatory. The <code>bufferOffset</code> specifies the byte
offset in the buffer at which the pixel values start. The <code>bufferRowLength</code> and
<code>bufferImageHeight</code> fields specify how the pixels are laid out in memory. For
example, you could have some padding bytes between rows of the image. Specifying
<code>0</code> for both indicates that the pixels are simply tightly packed like they are
in our case. The <code>imageSubresource</code>, <code>imageOffset</code> and <code>imageExtent</code> fields
indicate to which part of the image we want to copy the pixels.</p>
<p>Buffer to image copy operations are enqueued using the <code>vkCmdCopyBufferToImage</code>
function:</p>
<pre class="hljs"><code><div>vkCmdCopyBufferToImage(
    commandBuffer,
    <span class="hljs-built_in">buffer</span>,
    <span class="hljs-built_in">image</span>,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    <span class="hljs-number">1</span>,
    &amp;region
);
</div></code></pre>
<p>The fourth parameter indicates which layout the image is currently using. I'm
assuming here that the image has already been transitioned to the layout that is
optimal for copying pixels to. Right now we're only copying one chunk of pixels
to the whole image, but it's possible to specify an array of <code>VkBufferImageCopy</code></p>
<h2 id="2-image-view-and-sampler">2. Image view and sampler</h2>
<p>In this chapter we're going to create two more resources that are needed for the
graphics pipeline to sample an image. The first resource is one that we've
already seen before while working with the swap chain images, but the second one
is new - it relates to how the shader will read texels from the image.</p>
<h3 id="texture-image-view">Texture image view</h3>
<p>We've seen before, with the swap chain images and the framebuffer, that images
are accessed through image views rather than directly. We will also need to
create such an image view for the texture image.</p>
<p>Add a class member to hold a <code>VkImageView</code> for the texture image and create a
new function <code>createTextureImageView</code> where we'll create it:</p>
<pre class="hljs"><code><div>VkImageView textureImageView;

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createTextureImage();
    createTextureImageView();
    createVertexBuffer();
    ...
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createTextureImageView</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>The code for this function can be based directly on <code>createImageViews</code>. The only
two changes you have to make are the <code>format</code> and the <code>image</code>:</p>
<pre class="hljs"><code><div>VkImageViewCreateInfo viewInfo{};
viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
viewInfo.<span class="hljs-built_in">image</span> = textureImage;
viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
viewInfo.format = VK_FORMAT_R8G8B8A8_SRGB;
viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
viewInfo.subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;
viewInfo.subresourceRange.levelCount = <span class="hljs-number">1</span>;
viewInfo.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;
viewInfo.subresourceRange.layerCount = <span class="hljs-number">1</span>;
</div></code></pre>
<p>I've left out the explicit <code>viewInfo.components</code> initialization, because
<code>VK_COMPONENT_SWIZZLE_IDENTITY</code> is defined as <code>0</code> anyway. Finish creating the
image view by calling <code>vkCreateImageView</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (vkCreateImageView(device, &amp;viewInfo, <span class="hljs-literal">nullptr</span>, &amp;textureImageView) != VK_SUCCESS) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create texture image view!"</span>);
}
</div></code></pre>
<p>Because so much of the logic is duplicated from <code>createImageViews</code>, you may wish
to abstract it into a new <code>createImageView</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkImageView <span class="hljs-title">createImageView</span><span class="hljs-params">(VkImage <span class="hljs-built_in">image</span>, VkFormat format)</span> </span>{
    VkImageViewCreateInfo viewInfo{};
    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    viewInfo.<span class="hljs-built_in">image</span> = <span class="hljs-built_in">image</span>;
    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    viewInfo.format = format;
    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    viewInfo.subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;
    viewInfo.subresourceRange.levelCount = <span class="hljs-number">1</span>;
    viewInfo.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;
    viewInfo.subresourceRange.layerCount = <span class="hljs-number">1</span>;

    VkImageView imageView;
    <span class="hljs-keyword">if</span> (vkCreateImageView(device, &amp;viewInfo, <span class="hljs-literal">nullptr</span>, &amp;imageView) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create texture image view!"</span>);
    }

    <span class="hljs-keyword">return</span> imageView;
}
</div></code></pre>
<p>The <code>createTextureImageView</code> function can now be simplified to:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createTextureImageView</span><span class="hljs-params">()</span> </span>{
    textureImageView = createImageView(textureImage, VK_FORMAT_R8G8B8A8_SRGB);
}
</div></code></pre>
<p>And <code>createImageViews</code> can be simplified to:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createImageViews</span><span class="hljs-params">()</span> </span>{
    swapChainImageViews.resize(swapChainImages.<span class="hljs-built_in">size</span>());

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImages.<span class="hljs-built_in">size</span>(); i++) {
        swapChainImageViews[i] = createImageView(swapChainImages[i], swapChainImageFormat);
    }
}
</div></code></pre>
<p>Make sure to destroy the image view at the end of the program, right before
destroying the image itself:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    cleanupSwapChain();

    vkDestroyImageView(device, textureImageView, <span class="hljs-literal">nullptr</span>);

    vkDestroyImage(device, textureImage, <span class="hljs-literal">nullptr</span>);
    vkFreeMemory(device, textureImageMemory, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<h3 id="samplers">Samplers</h3>
<p>It is possible for shaders to read texels directly from images, but that is not
very common when they are used as textures. Textures are usually accessed
through samplers, which will apply filtering and transformations to compute the
final color that is retrieved.</p>
<p>These filters are helpful to deal with problems like oversampling. Consider a
texture that is mapped to geometry with more fragments than texels. If you
simply took the closest texel for the texture coordinate in each fragment, then
you would get a result like the first image:</p>
<p><img src="images/texture_filtering.png" alt=""></p>
<p>If you combined the 4 closest texels through linear interpolation, then you
would get a smoother result like the one on the right. Of course your
application may have art style requirements that fit the left style more (think
Minecraft), but the right is preferred in conventional graphics applications. A
sampler object automatically applies this filtering for you when reading a color
from the texture.</p>
<p>Undersampling is the opposite problem, where you have more texels than
fragments. This will lead to artifacts when sampling high frequency patterns
like a checkerboard texture at a sharp angle:</p>
<p><img src="images/anisotropic_filtering.png" alt=""></p>
<p>As shown in the left image, the texture turns into a blurry mess in the
distance. The solution to this is <a href="https://en.wikipedia.org/wiki/Anisotropic_filtering">anisotropic filtering</a>,
which can also be applied automatically by a sampler.</p>
<p>Aside from these filters, a sampler can also take care of transformations. It
determines what happens when you try to read texels outside the image through
its <em>addressing mode</em>. The image below displays some of the possibilities:</p>
<p><img src="images/texture_addressing.png" alt=""></p>
<p>We will now create a function <code>createTextureSampler</code> to set up such a sampler
object. We'll be using that sampler to read colors from the texture in the
shader later on.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createTextureImage();
    createTextureImageView();
    createTextureSampler();
    ...
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createTextureSampler</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>Samplers are configured through a <code>VkSamplerCreateInfo</code> structure, which
specifies all filters and transformations that it should apply.</p>
<pre class="hljs"><code><div>VkSamplerCreateInfo samplerInfo{};
samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
samplerInfo.magFilter = VK_FILTER_LINEAR;
samplerInfo.minFilter = VK_FILTER_LINEAR;
</div></code></pre>
<p>The <code>magFilter</code> and <code>minFilter</code> fields specify how to interpolate texels that
are magnified or minified. Magnification concerns the oversampling problem
describes above, and minification concerns undersampling. The choices are
<code>VK_FILTER_NEAREST</code> and <code>VK_FILTER_LINEAR</code>, corresponding to the modes
demonstrated in the images above.</p>
<pre class="hljs"><code><div>samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
</div></code></pre>
<p>The addressing mode can be specified per axis using the <code>addressMode</code> fields.
The available values are listed below. Most of these are demonstrated in the
image above. Note that the axes are called U, V and W instead of X, Y and Z.
This is a convention for texture space coordinates.</p>
<ul>
<li><code>VK_SAMPLER_ADDRESS_MODE_REPEAT</code>: Repeat the texture when going beyond the
image dimensions.</li>
<li><code>VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT</code>: Like repeat, but inverts the
coordinates to mirror the image when going beyond the dimensions.</li>
<li><code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</code>: Take the color of the edge closest to
the coordinate beyond the image dimensions.</li>
<li><code>VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE</code>: Like clamp to edge, but
instead uses the edge opposite to the closest edge.</li>
<li><code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</code>: Return a solid color when sampling
beyond the dimensions of the image.</li>
</ul>
<p>It doesn't really matter which addressing mode we use here, because we're not
going to sample outside of the image in this tutorial. However, the repeat mode
is probably the most common mode, because it can be used to tile textures like
floors and walls.</p>
<pre class="hljs"><code><div>samplerInfo.anisotropyEnable = VK_TRUE;
samplerInfo.maxAnisotropy = ???;
</div></code></pre>
<p>These two fields specify if anisotropic filtering should be used. There is no
reason not to use this unless performance is a concern. The <code>maxAnisotropy</code>
field limits the amount of texel samples that can be used to calculate the final
color. A lower value results in better performance, but lower quality results.
To figure out which value we can use, we need to retrieve the properties of the physical device like so:</p>
<pre class="hljs"><code><div>VkPhysicalDeviceProperties properties{};
vkGetPhysicalDeviceProperties(physicalDevice, &amp;properties);
</div></code></pre>
<p>If you look at the documentation for the <code>VkPhysicalDeviceProperties</code> structure, you'll see that it contains a <code>VkPhysicalDeviceLimits</code> member named <code>limits</code>. This struct in turn has a member called <code>maxSamplerAnisotropy</code> and this is the maximum value we can specify for <code>maxAnisotropy</code>. If we want to go for maximum quality, we can simply use that value directly:</p>
<pre class="hljs"><code><div>samplerInfo.maxAnisotropy = properties.limits.maxSamplerAnisotropy;
</div></code></pre>
<p>You can either query the properties at the beginning of your program and pass them around to the functions that need them, or query them in the <code>createTextureSampler</code> function itself.</p>
<pre class="hljs"><code><div>samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
</div></code></pre>
<p>The <code>borderColor</code> field specifies which color is returned when sampling beyond
the image with clamp to border addressing mode. It is possible to return black,
white or transparent in either float or int formats. You cannot specify an
arbitrary color.</p>
<pre class="hljs"><code><div>samplerInfo.unnormalizedCoordinates = VK_FALSE;
</div></code></pre>
<p>The <code>unnormalizedCoordinates</code> field specifies which coordinate system you want
to use to address texels in an image. If this field is <code>VK_TRUE</code>, then you can
simply use coordinates within the <code>[0, texWidth)</code> and <code>[0, texHeight)</code> range. If
it is <code>VK_FALSE</code>, then the texels are addressed using the <code>[0, 1)</code> range on all
axes. Real-world applications almost always use normalized coordinates, because
then it's possible to use textures of varying resolutions with the exact same
coordinates.</p>
<pre class="hljs"><code><div>samplerInfo.compareEnable = VK_FALSE;
samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;
</div></code></pre>
<p>If a comparison function is enabled, then texels will first be compared to a
value, and the result of that comparison is used in filtering operations. This
is mainly used for <a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html">percentage-closer filtering</a>
on shadow maps. We'll look at this in a future chapter.</p>
<pre class="hljs"><code><div>samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
samplerInfo.mipLodBias = <span class="hljs-number">0.0f</span>;
samplerInfo.minLod = <span class="hljs-number">0.0f</span>;
samplerInfo.maxLod = <span class="hljs-number">0.0f</span>;
</div></code></pre>
<p>All of these fields apply to mipmapping. We will look at mipmapping in a <a href="/Generating_Mipmaps">later
chapter</a>, but basically it's another type of filter that can be applied.</p>
<p>The functioning of the sampler is now fully defined. Add a class member to
hold the handle of the sampler object and create the sampler with
<code>vkCreateSampler</code>:</p>
<pre class="hljs"><code><div>VkImageView textureImageView;
VkSampler textureSampler;

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createTextureSampler</span><span class="hljs-params">()</span> </span>{
    ...

    <span class="hljs-keyword">if</span> (vkCreateSampler(device, &amp;samplerInfo, <span class="hljs-literal">nullptr</span>, &amp;textureSampler) != VK_SUCCESS) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create texture sampler!"</span>);
    }
}
</div></code></pre>
<p>Note the sampler does not reference a <code>VkImage</code> anywhere. The sampler is a
distinct object that provides an interface to extract colors from a texture. It
can be applied to any image you want, whether it is 1D, 2D or 3D. This is
different from many older APIs, which combined texture images and filtering into
a single state.</p>
<p>Destroy the sampler at the end of the program when we'll no longer be accessing
the image:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
    cleanupSwapChain();

    vkDestroySampler(device, textureSampler, <span class="hljs-literal">nullptr</span>);
    vkDestroyImageView(device, textureImageView, <span class="hljs-literal">nullptr</span>);

    ...
}
</div></code></pre>
<h3 id="anisotropy-device-feature">Anisotropy device feature</h3>
<p>If you run your program right now, you'll see a validation layer message like
this:</p>
<p><img src="images/validation_layer_anisotropy.png" alt=""></p>
<p>That's because anisotropic filtering is actually an optional device feature. We
need to update the <code>createLogicalDevice</code> function to request it:</p>
<pre class="hljs"><code><div>VkPhysicalDeviceFeatures deviceFeatures{};
deviceFeatures.samplerAnisotropy = VK_TRUE;
</div></code></pre>
<p>And even though it is very unlikely that a modern graphics card will not support
it, we should update <code>isDeviceSuitable</code> to check if it is available:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
    ...

    VkPhysicalDeviceFeatures supportedFeatures;
    vkGetPhysicalDeviceFeatures(device, &amp;supportedFeatures);

    <span class="hljs-keyword">return</span> indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate &amp;&amp; supportedFeatures.samplerAnisotropy;
}
</div></code></pre>
<p>The <code>vkGetPhysicalDeviceFeatures</code> repurposes the <code>VkPhysicalDeviceFeatures</code>
struct to indicate which features are supported rather than requested by setting
the boolean values.</p>
<p>Instead of enforcing the availability of anisotropic filtering, it's also
possible to simply not use it by conditionally setting:</p>
<pre class="hljs"><code><div>samplerInfo.anisotropyEnable = VK_FALSE;
samplerInfo.maxAnisotropy = <span class="hljs-number">1.0f</span>;
</div></code></pre>
<p>In the next chapter we will expose the image and sampler objects to the shaders
to draw the texture onto the square.</p>
<p><a href="/code/25_sampler.cpp">C++ code</a> /
<a href="/code/22_shader_ubo.vert">Vertex shader</a> /
<a href="/code/22_shader_ubo.frag">Fragment shader</a></p>
<h2 id="3-combined-image-sampler">3. Combined image sampler</h2>
<h3 id="introduction">Introduction</h3>
<p>We looked at descriptors for the first time in the uniform buffers part of the
tutorial. In this chapter we will look at a new type of descriptor: <em>combined
image sampler</em>. This descriptor makes it possible for shaders to access an image
resource through a sampler object like the one we created in the previous
chapter.</p>
<p>We'll start by modifying the descriptor layout, descriptor pool and descriptor
set to include such a combined image sampler descriptor. After that, we're going
to add texture coordinates to <code>Vertex</code> and modify the fragment shader to read
colors from the texture instead of just interpolating the vertex colors.</p>
<h3 id="updating-the-descriptors">Updating the descriptors</h3>
<p>Browse to the <code>createDescriptorSetLayout</code> function and add a
<code>VkDescriptorSetLayoutBinding</code> for a combined image sampler descriptor. We'll
simply put it in the binding after the uniform buffer:</p>
<pre class="hljs"><code><div>VkDescriptorSetLayoutBinding samplerLayoutBinding{};
samplerLayoutBinding.binding = <span class="hljs-number">1</span>;
samplerLayoutBinding.descriptorCount = <span class="hljs-number">1</span>;
samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
samplerLayoutBinding.pImmutableSamplers = <span class="hljs-literal">nullptr</span>;
samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkDescriptorSetLayoutBinding, 2&gt; bindings = {uboLayoutBinding, samplerLayoutBinding};
VkDescriptorSetLayoutCreateInfo layoutInfo{};
layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
layoutInfo.bindingCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(bindings.<span class="hljs-built_in">size</span>());
layoutInfo.pBindings = bindings.data();
</div></code></pre>
<p>Make sure to set the <code>stageFlags</code> to indicate that we intend to use the combined
image sampler descriptor in the fragment shader. That's where the color of the
fragment is going to be determined. It is possible to use texture sampling in
the vertex shader, for example to dynamically deform a grid of vertices by a
<a href="https://en.wikipedia.org/wiki/Heightmap">heightmap</a>.</p>
<p>We must also create a larger descriptor pool to make room for the allocation
of the combined image sampler by adding another <code>VkPoolSize</code> of type
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> to the
<code>VkDescriptorPoolCreateInfo</code>. Go to the <code>createDescriptorPool</code> function and
modify it to include a <code>VkDescriptorPoolSize</code> for this descriptor:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkDescriptorPoolSize, 2&gt; poolSizes{};
poolSizes[<span class="hljs-number">0</span>].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
poolSizes[<span class="hljs-number">0</span>].descriptorCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);
poolSizes[<span class="hljs-number">1</span>].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
poolSizes[<span class="hljs-number">1</span>].descriptorCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);

VkDescriptorPoolCreateInfo poolInfo{};
poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
poolInfo.poolSizeCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(poolSizes.<span class="hljs-built_in">size</span>());
poolInfo.pPoolSizes = poolSizes.data();
poolInfo.maxSets = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);
</div></code></pre>
<p>Inadequate descriptor pools are a good example of a problem that the validation
layers will not catch: As of Vulkan 1.1, <code>vkAllocateDescriptorSets</code> may fail
with the error code <code>VK_ERROR_POOL_OUT_OF_MEMORY</code> if the pool is not
sufficiently large, but the driver may also try to solve the problem internally.
This means that sometimes (depending on hardware, pool size and allocation size)
the driver will let us get away with an allocation that exceeds the limits of
our descriptor pool. Other times, <code>vkAllocateDescriptorSets</code> will fail and
return <code>VK_ERROR_POOL_OUT_OF_MEMORY</code>. This can be particularly frustrating if
the allocation succeeds on some machines, but fails on others.</p>
<p>Since Vulkan shifts the responsiblity for the allocation to the driver, it is no
longer a strict requirement to only allocate as many descriptors of a certain
type (<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, etc.) as specified by the
corresponding <code>descriptorCount</code> members for the creation of the descriptor pool.
However, it remains best practise to do so, and in the future,
<code>VK_LAYER_KHRONOS_validation</code> will warn about this type of problem if you enable
<a href="https://vulkan.lunarg.com/doc/view/1.1.126.0/windows/best_practices.html">Best Practice Validation</a>.</p>
<p>The final step is to bind the actual image and sampler resources to the
descriptors in the descriptor set. Go to the <code>createDescriptorSets</code> function.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
    VkDescriptorBufferInfo bufferInfo{};
    bufferInfo.<span class="hljs-built_in">buffer</span> = uniformBuffers[i];
    bufferInfo.offset = <span class="hljs-number">0</span>;
    bufferInfo.range = <span class="hljs-keyword">sizeof</span>(UniformBufferObject);

    VkDescriptorImageInfo imageInfo{};
    imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo.imageView = textureImageView;
    imageInfo.sampler = textureSampler;

    ...
}
</div></code></pre>
<p>The resources for a combined image sampler structure must be specified in a
<code>VkDescriptorImageInfo</code> struct, just like the buffer resource for a uniform
buffer descriptor is specified in a <code>VkDescriptorBufferInfo</code> struct. This is
where the objects from the previous chapter come together.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkWriteDescriptorSet, 2&gt; descriptorWrites{};

descriptorWrites[<span class="hljs-number">0</span>].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
descriptorWrites[<span class="hljs-number">0</span>].dstSet = descriptorSets[i];
descriptorWrites[<span class="hljs-number">0</span>].dstBinding = <span class="hljs-number">0</span>;
descriptorWrites[<span class="hljs-number">0</span>].dstArrayElement = <span class="hljs-number">0</span>;
descriptorWrites[<span class="hljs-number">0</span>].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
descriptorWrites[<span class="hljs-number">0</span>].descriptorCount = <span class="hljs-number">1</span>;
descriptorWrites[<span class="hljs-number">0</span>].pBufferInfo = &amp;bufferInfo;

descriptorWrites[<span class="hljs-number">1</span>].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
descriptorWrites[<span class="hljs-number">1</span>].dstSet = descriptorSets[i];
descriptorWrites[<span class="hljs-number">1</span>].dstBinding = <span class="hljs-number">1</span>;
descriptorWrites[<span class="hljs-number">1</span>].dstArrayElement = <span class="hljs-number">0</span>;
descriptorWrites[<span class="hljs-number">1</span>].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
descriptorWrites[<span class="hljs-number">1</span>].descriptorCount = <span class="hljs-number">1</span>;
descriptorWrites[<span class="hljs-number">1</span>].pImageInfo = &amp;imageInfo;

vkUpdateDescriptorSets(device, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(descriptorWrites.<span class="hljs-built_in">size</span>()), descriptorWrites.data(), <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<p>The descriptors must be updated with this image info, just like the buffer. This
time we're using the <code>pImageInfo</code> array instead of <code>pBufferInfo</code>. The descriptors
are now ready to be used by the shaders!</p>
<h3 id="texture-coordinates">Texture coordinates</h3>
<p>There is one important ingredient for texture mapping that is still missing, and
that's the actual coordinates for each vertex. The coordinates determine how the
image is actually mapped to the geometry.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span> {</span>
    glm::vec2 pos;
    glm::vec3 color;
    glm::vec2 texCoord;

    <span class="hljs-function"><span class="hljs-keyword">static</span> VkVertexInputBindingDescription <span class="hljs-title">getBindingDescription</span><span class="hljs-params">()</span> </span>{
        VkVertexInputBindingDescription bindingDescription{};
        bindingDescription.binding = <span class="hljs-number">0</span>;
        bindingDescription.stride = <span class="hljs-keyword">sizeof</span>(Vertex);
        bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

        <span class="hljs-keyword">return</span> bindingDescription;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkVertexInputAttributeDescription, 3&gt; <span class="hljs-title">getAttributeDescriptions</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions{};

        attributeDescriptions[<span class="hljs-number">0</span>].binding = <span class="hljs-number">0</span>;
        attributeDescriptions[<span class="hljs-number">0</span>].location = <span class="hljs-number">0</span>;
        attributeDescriptions[<span class="hljs-number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[<span class="hljs-number">0</span>].offset = offsetof(Vertex, pos);

        attributeDescriptions[<span class="hljs-number">1</span>].binding = <span class="hljs-number">0</span>;
        attributeDescriptions[<span class="hljs-number">1</span>].location = <span class="hljs-number">1</span>;
        attributeDescriptions[<span class="hljs-number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[<span class="hljs-number">1</span>].offset = offsetof(Vertex, color);

        attributeDescriptions[<span class="hljs-number">2</span>].binding = <span class="hljs-number">0</span>;
        attributeDescriptions[<span class="hljs-number">2</span>].location = <span class="hljs-number">2</span>;
        attributeDescriptions[<span class="hljs-number">2</span>].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[<span class="hljs-number">2</span>].offset = offsetof(Vertex, texCoord);

        <span class="hljs-keyword">return</span> attributeDescriptions;
    }
};
</div></code></pre>
<p>Modify the <code>Vertex</code> struct to include a <code>vec2</code> for texture coordinates. Make
sure to also add a <code>VkVertexInputAttributeDescription</code> so that we can use access
texture coordinates as input in the vertex shader. That is necessary to be able
to pass them to the fragment shader for interpolation across the surface of the
square.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices = {
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}},
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>}}
};
</div></code></pre>
<p>In this tutorial, I will simply fill the square with the texture by using
coordinates from <code>0, 0</code> in the top-left corner to <code>1, 1</code> in the bottom-right
corner. Feel free to experiment with different coordinates. Try using
coordinates below <code>0</code> or above <code>1</code> to see the addressing modes in action!</p>
<h3 id="shaders">Shaders</h3>
<p>The final step is modifying the shaders to sample colors from the texture. We
first need to modify the vertex shader to pass through the texture coordinates
to the fragment shader:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inTexCoord;

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> fragTexCoord;

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
    fragColor = inColor;
    fragTexCoord = inTexCoord;
}
</div></code></pre>
<p>Just like the per vertex colors, the <code>fragTexCoord</code> values will be smoothly
interpolated across the area of the square by the rasterizer. We can visualize
this by having the fragment shader output the texture coordinates as colors:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#version 450</span>

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> fragColor;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> fragTexCoord;

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;

<span class="hljs-type">void</span> main() {
    outColor = <span class="hljs-type">vec4</span>(fragTexCoord, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
}
</div></code></pre>
<p>You should see something like the image below. Don't forget to recompile the
shaders!</p>
<p><img src="images/texcoord_visualization.png" alt=""></p>
<p>The green channel represents the horizontal coordinates and the red channel the
vertical coordinates. The black and yellow corners confirm that the texture
coordinates are correctly interpolated from <code>0, 0</code> to <code>1, 1</code> across the square.
Visualizing data using colors is the shader programming equivalent of <code>printf</code>
debugging, for lack of a better option!</p>
<p>A combined image sampler descriptor is represented in GLSL by a sampler uniform.
Add a reference to it in the fragment shader:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texSampler;
</div></code></pre>
<p>There are equivalent <code>sampler1D</code> and <code>sampler3D</code> types for other types of
images. Make sure to use the correct binding here.</p>
<pre class="hljs"><code><div><span class="hljs-type">void</span> main() {
    outColor = <span class="hljs-built_in">texture</span>(texSampler, fragTexCoord);
}
</div></code></pre>
<p>Textures are sampled using the built-in <code>texture</code> function. It takes a <code>sampler</code>
and coordinate as arguments. The sampler automatically takes care of the
filtering and transformations in the background. You should now see the texture
on the square when you run the application:</p>
<p><img src="images/texture_on_square.png" alt=""></p>
<p>Try experimenting with the addressing modes by scaling the texture coordinates
to values higher than <code>1</code>. For example, the following fragment shader produces
the result in the image below when using <code>VK_SAMPLER_ADDRESS_MODE_REPEAT</code>:</p>
<pre class="hljs"><code><div><span class="hljs-type">void</span> main() {
    outColor = <span class="hljs-built_in">texture</span>(texSampler, fragTexCoord * <span class="hljs-number">2.0</span>);
}
</div></code></pre>
<p><img src="images/texture_on_square_repeated.png" alt=""></p>
<p>You can also manipulate the texture colors using the vertex colors:</p>
<pre class="hljs"><code><div><span class="hljs-type">void</span> main() {
    outColor = <span class="hljs-type">vec4</span>(fragColor * <span class="hljs-built_in">texture</span>(texSampler, fragTexCoord).rgb, <span class="hljs-number">1.0</span>);
}
</div></code></pre>
<p>I've separated the RGB and alpha channels here to not scale the alpha channel.</p>
<p><img src="images/texture_on_square_colorized.png" alt=""></p>
<p>You now know how to access images in shaders! This is a very powerful technique
when combined with images that are also written to in framebuffers. You can use
these images as inputs to implement cool effects like post-processing and camera
displays within the 3D world.</p>
<p><a href="/code/26_texture_mapping.cpp">C++ code</a> /
<a href="/code/26_shader_textures.vert">Vertex shader</a> /
<a href="/code/26_shader_textures.frag">Fragment shader</a></p>
<h1 id="8---depth-buffering">8 - Depth buffering</h1>
<h2 id="introduction">Introduction</h2>
<p>The geometry we've worked with so far is projected into 3D, but it's still
completely flat. In this chapter we're going to add a Z coordinate to the
position to prepare for 3D meshes. We'll use this third coordinate to place a
square over the current square to see a problem that arises when geometry is not
sorted by depth.</p>
<h2 id="3d-geometry">3D geometry</h2>
<p>Change the <code>Vertex</code> struct to use a 3D vector for the position, and update the
<code>format</code> in the corresponding <code>VkVertexInputAttributeDescription</code>:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span> {</span>
    glm::vec3 pos;
    glm::vec3 color;
    glm::vec2 texCoord;

    ...

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkVertexInputAttributeDescription, 3&gt; <span class="hljs-title">getAttributeDescriptions</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions{};

        attributeDescriptions[<span class="hljs-number">0</span>].binding = <span class="hljs-number">0</span>;
        attributeDescriptions[<span class="hljs-number">0</span>].location = <span class="hljs-number">0</span>;
        attributeDescriptions[<span class="hljs-number">0</span>].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[<span class="hljs-number">0</span>].offset = offsetof(Vertex, pos);

        ...
    }
};
</div></code></pre>
<p>Next, update the vertex shader to accept and transform 3D coordinates as input.
Don't forget to recompile it afterwards!</p>
<pre class="hljs"><code><div><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inPosition;

...

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">1.0</span>);
    fragColor = inColor;
    fragTexCoord = inTexCoord;
}
</div></code></pre>
<p>Lastly, update the <code>vertices</code> container to include Z coordinates:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices = {
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>}},
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}}
};
</div></code></pre>
<p>If you run your application now, then you should see exactly the same result as
before. It's time to add some extra geometry to make the scene more interesting,
and to demonstrate the problem that we're going to tackle in this chapter.
Duplicate the vertices to define positions for a square right under the current
one like this:</p>
<p><img src="images/extra_square.svg" alt=""></p>
<p>Use Z coordinates of <code>-0.5f</code> and add the appropriate indices for the extra
square:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices = {
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>}},
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}},

    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>}},
    {{<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>}},
    {{<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>}, {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>}, {<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}}
};

<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint16_t</span>&gt; indices = {
    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>,
    <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>
};
</div></code></pre>
<p>Run your program now and you'll see something resembling an Escher illustration:</p>
<p><img src="images/depth_issues.png" alt=""></p>
<p>The problem is that the fragments of the lower square are drawn over the
fragments of the upper square, simply because it comes later in the index array.
There are two ways to solve this:</p>
<ul>
<li>Sort all of the draw calls by depth from back to front</li>
<li>Use depth testing with a depth buffer</li>
</ul>
<p>The first approach is commonly used for drawing transparent objects, because
order-independent transparency is a difficult challenge to solve. However, the
problem of ordering fragments by depth is much more commonly solved using a
<em>depth buffer</em>. A depth buffer is an additional attachment that stores the depth
for every position, just like the color attachment stores the color of every
position. Every time the rasterizer produces a fragment, the depth test will
check if the new fragment is closer than the previous one. If it isn't, then the
new fragment is discarded. A fragment that passes the depth test writes its own
depth to the depth buffer. It is possible to manipulate this value from the
fragment shader, just like you can manipulate the color output.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_RADIANS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_FORCE_DEPTH_ZERO_TO_ONE</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/glm.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span>
</div></code></pre>
<p>The perspective projection matrix generated by GLM will use the OpenGL depth
range of <code>-1.0</code> to <code>1.0</code> by default. We need to configure it to use the Vulkan
range of <code>0.0</code> to <code>1.0</code> using the <code>GLM_FORCE_DEPTH_ZERO_TO_ONE</code> definition.</p>
<h2 id="depth-image-and-view">Depth image and view</h2>
<p>A depth attachment is based on an image, just like the color attachment. The
difference is that the swap chain will not automatically create depth images for us. We only need a single depth image, because only one draw operation is
running at once. The depth image will again require the trifecta of resources:
image, memory and image view.</p>
<pre class="hljs"><code><div>VkImage depthImage;
VkDeviceMemory depthImageMemory;
VkImageView depthImageView;
</div></code></pre>
<p>Create a new function <code>createDepthResources</code> to set up these resources:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createCommandPool();
    createDepthResources();
    createTextureImage();
    ...
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createDepthResources</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>Creating a depth image is fairly straightforward. It should have the same
resolution as the color attachment, defined by the swap chain extent, an image
usage appropriate for a depth attachment, optimal tiling and device local
memory. The only question is: what is the right format for a depth image? The
format must contain a depth component, indicated by <code>_D??_</code> in the <code>VK_FORMAT_</code>.</p>
<p>Unlike the texture image, we don't necessarily need a specific format, because
we won't be directly accessing the texels from the program. It just needs to
have a reasonable accuracy, at least 24 bits is common in real-world
applications. There are several formats that fit this requirement:</p>
<ul>
<li><code>VK_FORMAT_D32_SFLOAT</code>: 32-bit float for depth</li>
<li><code>VK_FORMAT_D32_SFLOAT_S8_UINT</code>: 32-bit signed float for depth and 8 bit
stencil component</li>
<li><code>VK_FORMAT_D24_UNORM_S8_UINT</code>: 24-bit float for depth and 8 bit stencil
component</li>
</ul>
<p>The stencil component is used for <a href="https://en.wikipedia.org/wiki/Stencil_buffer">stencil tests</a>,
which is an additional test that can be combined with depth testing. We'll look
at this in a future chapter.</p>
<p>We could simply go for the <code>VK_FORMAT_D32_SFLOAT</code> format, because support for it
is extremely common (see the hardware database), but it's nice to add some extra
flexibility to our application where possible. We're going to write a function
<code>findSupportedFormat</code> that takes a list of candidate formats in order from most
desirable to least desirable, and checks which is the first one that is
supported:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkFormat <span class="hljs-title">findSupportedFormat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkFormat&gt;&amp; candidates, VkImageTiling tiling, VkFormatFeatureFlags features)</span> </span>{

}
</div></code></pre>
<p>The support of a format depends on the tiling mode and usage, so we must also
include these as parameters. The support of a format can be queried using
the <code>vkGetPhysicalDeviceFormatProperties</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (VkFormat format : candidates) {
    VkFormatProperties props;
    vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &amp;props);
}
</div></code></pre>
<p>The <code>VkFormatProperties</code> struct contains three fields:</p>
<ul>
<li><code>linearTilingFeatures</code>: Use cases that are supported with linear tiling</li>
<li><code>optimalTilingFeatures</code>: Use cases that are supported with optimal tiling</li>
<li><code>bufferFeatures</code>: Use cases that are supported for buffers</li>
</ul>
<p>Only the first two are relevant here, and the one we check depends on the
<code>tiling</code> parameter of the function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (tiling == VK_IMAGE_TILING_LINEAR &amp;&amp; (props.linearTilingFeatures &amp; features) == features) {
    <span class="hljs-keyword">return</span> format;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tiling == VK_IMAGE_TILING_OPTIMAL &amp;&amp; (props.optimalTilingFeatures &amp; features) == features) {
    <span class="hljs-keyword">return</span> format;
}
</div></code></pre>
<p>If none of the candidate formats support the desired usage, then we can either
return a special value or simply throw an exception:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkFormat <span class="hljs-title">findSupportedFormat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkFormat&gt;&amp; candidates, VkImageTiling tiling, VkFormatFeatureFlags features)</span> </span>{
    <span class="hljs-keyword">for</span> (VkFormat format : candidates) {
        VkFormatProperties props;
        vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &amp;props);

        <span class="hljs-keyword">if</span> (tiling == VK_IMAGE_TILING_LINEAR &amp;&amp; (props.linearTilingFeatures &amp; features) == features) {
            <span class="hljs-keyword">return</span> format;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tiling == VK_IMAGE_TILING_OPTIMAL &amp;&amp; (props.optimalTilingFeatures &amp; features) == features) {
            <span class="hljs-keyword">return</span> format;
        }
    }

    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to find supported format!"</span>);
}
</div></code></pre>
<p>We'll use this function now to create a <code>findDepthFormat</code> helper function to
select a format with a depth component that supports usage as depth attachment:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkFormat <span class="hljs-title">findDepthFormat</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> findSupportedFormat(
        {VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT},
        VK_IMAGE_TILING_OPTIMAL,
        VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
    );
}
</div></code></pre>
<p>Make sure to use the <code>VK_FORMAT_FEATURE_</code> flag instead of <code>VK_IMAGE_USAGE_</code> in
this case. All of these candidate formats contain a depth component, but the
latter two also contain a stencil component. We won't be using that yet, but we
do need to take that into account when performing layout transitions on images
with these formats. Add a simple helper function that tells us if the chosen
depth format contains a stencil component:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasStencilComponent</span><span class="hljs-params">(VkFormat format)</span> </span>{
    <span class="hljs-keyword">return</span> format == VK_FORMAT_D32_SFLOAT_S8_UINT || format == VK_FORMAT_D24_UNORM_S8_UINT;
}
</div></code></pre>
<p>Call the function to find a depth format from <code>createDepthResources</code>:</p>
<pre class="hljs"><code><div>VkFormat depthFormat = findDepthFormat();
</div></code></pre>
<p>We now have all the required information to invoke our <code>createImage</code> and
<code>createImageView</code> helper functions:</p>
<pre class="hljs"><code><div>createImage(swapChainExtent.<span class="hljs-built_in">width</span>, swapChainExtent.<span class="hljs-built_in">height</span>, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);
depthImageView = createImageView(depthImage, depthFormat);
</div></code></pre>
<p>However, the <code>createImageView</code> function currently assumes that the subresource
is always the <code>VK_IMAGE_ASPECT_COLOR_BIT</code>, so we will need to turn that field
into a parameter:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkImageView <span class="hljs-title">createImageView</span><span class="hljs-params">(VkImage <span class="hljs-built_in">image</span>, VkFormat format, VkImageAspectFlags aspectFlags)</span> </span>{
    ...
    viewInfo.subresourceRange.aspectMask = aspectFlags;
    ...
}
</div></code></pre>
<p>Update all calls to this function to use the right aspect:</p>
<pre class="hljs"><code><div>swapChainImageViews[i] = createImageView(swapChainImages[i], swapChainImageFormat, VK_IMAGE_ASPECT_COLOR_BIT);
...
depthImageView = createImageView(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT);
...
textureImageView = createImageView(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT);
</div></code></pre>
<p>That's it for creating the depth image. We don't need to map it or copy another
image to it, because we're going to clear it at the start of the render pass
like the color attachment.</p>
<h3 id="explicitly-transitioning-the-depth-image">Explicitly transitioning the depth image</h3>
<p>We don't need to explicitly transition the layout of the image to a depth
attachment because we'll take care of this in the render pass. However, for
completeness I'll still describe the process in this section. You may skip it if
you like.</p>
<p>Make a call to <code>transitionImageLayout</code> at the end of the <code>createDepthResources</code>
function like so:</p>
<pre class="hljs"><code><div>transitionImageLayout(depthImage, depthFormat, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL);
</div></code></pre>
<p>The undefined layout can be used as initial layout, because there are no
existing depth image contents that matter. We need to update some of the logic
in <code>transitionImageLayout</code> to use the right subresource aspect:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) {
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;

    <span class="hljs-keyword">if</span> (hasStencilComponent(format)) {
        barrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT;
    }
} <span class="hljs-keyword">else</span> {
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
}
</div></code></pre>
<p>Although we're not using the stencil component, we do need to include it in the
layout transitions of the depth image.</p>
<p>Finally, add the correct access masks and pipeline stages:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
    barrier.srcAccessMask = <span class="hljs-number">0</span>;
    barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

    sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

    sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) {
    barrier.srcAccessMask = <span class="hljs-number">0</span>;
    barrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

    sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    destinationStage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
} <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::invalid_argument(<span class="hljs-string">"unsupported layout transition!"</span>);
}
</div></code></pre>
<p>The depth buffer will be read from to perform depth tests to see if a fragment
is visible, and will be written to when a new fragment is drawn. The reading
happens in the <code>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code> stage and the
writing in the <code>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</code>. You should pick the
earliest pipeline stage that matches the specified operations, so that it is
ready for usage as depth attachment when it needs to be.</p>
<h2 id="render-pass">Render pass</h2>
<p>We're now going to modify <code>createRenderPass</code> to include a depth attachment.
First specify the <code>VkAttachmentDescription</code>:</p>
<pre class="hljs"><code><div>VkAttachmentDescription depthAttachment{};
depthAttachment.format = findDepthFormat();
depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
depthAttachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
</div></code></pre>
<p>The <code>format</code> should be the same as the depth image itself. This time we don't
care about storing the depth data (<code>storeOp</code>), because it will not be used after
drawing has finished. This may allow the hardware to perform additional
optimizations. Just like the color buffer, we don't care about the previous
depth contents, so we can use <code>VK_IMAGE_LAYOUT_UNDEFINED</code> as <code>initialLayout</code>.</p>
<pre class="hljs"><code><div>VkAttachmentReference depthAttachmentRef{};
depthAttachmentRef.attachment = <span class="hljs-number">1</span>;
depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
</div></code></pre>
<p>Add a reference to the attachment for the first (and only) subpass:</p>
<pre class="hljs"><code><div>VkSubpassDescription subpass{};
subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
subpass.colorAttachmentCount = <span class="hljs-number">1</span>;
subpass.pColorAttachments = &amp;colorAttachmentRef;
subpass.pDepthStencilAttachment = &amp;depthAttachmentRef;
</div></code></pre>
<p>Unlike color attachments, a subpass can only use a single depth (+stencil)
attachment. It wouldn't really make any sense to do depth tests on multiple
buffers.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkAttachmentDescription, 2&gt; attachments = {colorAttachment, depthAttachment};
VkRenderPassCreateInfo renderPassInfo{};
renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
renderPassInfo.attachmentCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());
renderPassInfo.pAttachments = attachments.data();
renderPassInfo.subpassCount = <span class="hljs-number">1</span>;
renderPassInfo.pSubpasses = &amp;subpass;
renderPassInfo.dependencyCount = <span class="hljs-number">1</span>;
renderPassInfo.pDependencies = &amp;dependency;
</div></code></pre>
<p>Next, update the <code>VkRenderPassCreateInfo</code> struct to refer to both
attachments.</p>
<pre class="hljs"><code><div>dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
</div></code></pre>
<p>Finally, we need to extend our subpass dependencies to make sure that there is no conflict between the transitioning of the depth image and it being cleared as part of its load operation. The depth image is first accessed in the early fragment test pipeline stage and because we have a load operation that <em>clears</em>, we should specify the access mask for writes.</p>
<h2 id="framebuffer">Framebuffer</h2>
<p>The next step is to modify the framebuffer creation to bind the depth image to
the depth attachment. Go to <code>createFramebuffers</code> and specify the depth image
view as second attachment:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkImageView, 2&gt; attachments = {
    swapChainImageViews[i],
    depthImageView
};

VkFramebufferCreateInfo framebufferInfo{};
framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
framebufferInfo.renderPass = renderPass;
framebufferInfo.attachmentCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());
framebufferInfo.pAttachments = attachments.data();
framebufferInfo.<span class="hljs-built_in">width</span> = swapChainExtent.<span class="hljs-built_in">width</span>;
framebufferInfo.<span class="hljs-built_in">height</span> = swapChainExtent.<span class="hljs-built_in">height</span>;
framebufferInfo.layers = <span class="hljs-number">1</span>;
</div></code></pre>
<p>The color attachment differs for every swap chain image, but the same depth
image can be used by all of them because only a single subpass is running at the
same time due to our semaphores.</p>
<p>You'll also need to move the call to <code>createFramebuffers</code> to make sure that it
is called after the depth image view has actually been created:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createDepthResources();
    createFramebuffers();
    ...
}
</div></code></pre>
<h2 id="clear-values">Clear values</h2>
<p>Because we now have multiple attachments with <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>, we
also need to specify multiple clear values. Go to <code>recordCommandBuffer</code> and
create an array of <code>VkClearValue</code> structs:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkClearValue, 2&gt; clearValues{};
clearValues[<span class="hljs-number">0</span>].color = {{<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>}};
clearValues[<span class="hljs-number">1</span>].depthStencil = {<span class="hljs-number">1.0f</span>, <span class="hljs-number">0</span>};

renderPassInfo.clearValueCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(clearValues.<span class="hljs-built_in">size</span>());
renderPassInfo.pClearValues = clearValues.data();
</div></code></pre>
<p>The range of depths in the depth buffer is <code>0.0</code> to <code>1.0</code> in Vulkan, where <code>1.0</code>
lies at the far view plane and <code>0.0</code> at the near view plane. The initial value
at each point in the depth buffer should be the furthest possible depth, which
is <code>1.0</code>.</p>
<p>Note that the order of <code>clearValues</code> should be identical to the order of your attachments.</p>
<h2 id="depth-and-stencil-state">Depth and stencil state</h2>
<p>The depth attachment is ready to be used now, but depth testing still needs to
be enabled in the graphics pipeline. It is configured through the
<code>VkPipelineDepthStencilStateCreateInfo</code> struct:</p>
<pre class="hljs"><code><div>VkPipelineDepthStencilStateCreateInfo depthStencil{};
depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
depthStencil.depthTestEnable = VK_TRUE;
depthStencil.depthWriteEnable = VK_TRUE;
</div></code></pre>
<p>The <code>depthTestEnable</code> field specifies if the depth of new fragments should be
compared to the depth buffer to see if they should be discarded. The
<code>depthWriteEnable</code> field specifies if the new depth of fragments that pass the
depth test should actually be written to the depth buffer.</p>
<pre class="hljs"><code><div>depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;
</div></code></pre>
<p>The <code>depthCompareOp</code> field specifies the comparison that is performed to keep or
discard fragments. We're sticking to the convention of lower depth = closer, so
the depth of new fragments should be <em>less</em>.</p>
<pre class="hljs"><code><div>depthStencil.depthBoundsTestEnable = VK_FALSE;
depthStencil.minDepthBounds = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span>
depthStencil.maxDepthBounds = <span class="hljs-number">1.0f</span>; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>The <code>depthBoundsTestEnable</code>, <code>minDepthBounds</code> and <code>maxDepthBounds</code> fields are
used for the optional depth bound test. Basically, this allows you to only keep
fragments that fall within the specified depth range. We won't be using this
functionality.</p>
<pre class="hljs"><code><div>depthStencil.stencilTestEnable = VK_FALSE;
depthStencil.front = {}; <span class="hljs-comment">// Optional</span>
depthStencil.back = {}; <span class="hljs-comment">// Optional</span>
</div></code></pre>
<p>The last three fields configure stencil buffer operations, which we also won't
be using in this tutorial. If you want to use these operations, then you will
have to make sure that the format of the depth/stencil image contains a stencil
component.</p>
<pre class="hljs"><code><div>pipelineInfo.pDepthStencilState = &amp;depthStencil;
</div></code></pre>
<p>Update the <code>VkGraphicsPipelineCreateInfo</code> struct to reference the depth stencil
state we just filled in. A depth stencil state must always be specified if the
render pass contains a depth stencil attachment.</p>
<p>If you run your program now, then you should see that the fragments of the
geometry are now correctly ordered:</p>
<p><img src="images/depth_correct.png" alt=""></p>
<h2 id="handling-window-resize">Handling window resize</h2>
<p>The resolution of the depth buffer should change when the window is resized to
match the new color attachment resolution. Extend the <code>recreateSwapChain</code>
function to recreate the depth resources in that case:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">height</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">width</span> == <span class="hljs-number">0</span> || <span class="hljs-built_in">height</span> == <span class="hljs-number">0</span>) {
        glfwGetFramebufferSize(window, &amp;<span class="hljs-built_in">width</span>, &amp;<span class="hljs-built_in">height</span>);
        glfwWaitEvents();
    }

    vkDeviceWaitIdle(device);

    cleanupSwapChain();

    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createDepthResources();
    createFramebuffers();
}
</div></code></pre>
<p>The cleanup operations should happen in the swap chain cleanup function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanupSwapChain</span><span class="hljs-params">()</span> </span>{
    vkDestroyImageView(device, depthImageView, <span class="hljs-literal">nullptr</span>);
    vkDestroyImage(device, depthImage, <span class="hljs-literal">nullptr</span>);
    vkFreeMemory(device, depthImageMemory, <span class="hljs-literal">nullptr</span>);

    ...
}
</div></code></pre>
<p>Congratulations, your application is now finally ready to render arbitrary 3D
geometry and have it look right. We're going to try this out in the next chapter
by drawing a textured model!</p>
<p><a href="/code/27_depth_buffering.cpp">C++ code</a> /
<a href="/code/27_shader_depth.vert">Vertex shader</a> /
<a href="/code/27_shader_depth.frag">Fragment shader</a></p>
<h1 id="9---loading-models">9 - Loading models</h1>
<h2 id="introduction">Introduction</h2>
<p>Your program is now ready to render textured 3D meshes, but the current geometry
in the <code>vertices</code> and <code>indices</code> arrays is not very interesting yet. In this
chapter we're going to extend the program to load the vertices and indices from
an actual model file to make the graphics card actually do some work.</p>
<p>Many graphics API tutorials have the reader write their own OBJ loader in a
chapter like this. The problem with this is that any remotely interesting 3D
application will soon require features that are not supported by this file
format, like skeletal animation. We <em>will</em> load mesh data from an OBJ model in
this chapter, but we'll focus more on integrating the mesh data with the program
itself rather than the details of loading it from a file.</p>
<h2 id="library">Library</h2>
<p>We will use the <a href="https://github.com/syoyo/tinyobjloader">tinyobjloader</a> library
to load vertices and faces from an OBJ file. It's fast and it's easy to
integrate because it's a single file library like stb_image. Go to the
repository linked above and download the <code>tiny_obj_loader.h</code> file to a folder in
your library directory. Make sure to use the version of the file from the <code>master</code> branch because the latest official release is outdated.</p>
<p><strong>Visual Studio</strong></p>
<p>Add the directory with <code>tiny_obj_loader.h</code> in it to the <code>Additional Include Directories</code> paths.</p>
<p><img src="images/include_dirs_tinyobjloader.png" alt=""></p>
<p><strong>Makefile</strong></p>
<p>Add the directory with <code>tiny_obj_loader.h</code> to the include directories for GCC:</p>
<pre class="hljs"><code><div>VULKAN_SDK_PATH = /home/user/VulkanSDK/x.x.x.x/x86_64
STB_INCLUDE_PATH = /home/user/libraries/stb
TINYOBJ_INCLUDE_PATH = /home/user/libraries/tinyobjloader

...

CFLAGS = -std=c++17 -I$(VULKAN_SDK_PATH)/include -I$(STB_INCLUDE_PATH) -I$(TINYOBJ_INCLUDE_PATH)
</div></code></pre>
<h2 id="sample-mesh">Sample mesh</h2>
<p>In this chapter we won't be enabling lighting yet, so it helps to use a sample
model that has lighting baked into the texture. An easy way to find such models
is to look for 3D scans on <a href="https://sketchfab.com/">Sketchfab</a>. Many of the
models on that site are available in OBJ format with a permissive license.</p>
<p>For this tutorial I've decided to go with the <a href="https://sketchfab.com/3d-models/viking-room-a49f1b8e4f5c4ecf9e1fe7d81915ad38">Viking room</a>
model by <a href="https://sketchfab.com/nigelgoh">nigelgoh</a> (<a href="https://web.archive.org/web/20200428202538/https://sketchfab.com/3d-models/viking-room-a49f1b8e4f5c4ecf9e1fe7d81915ad38">CC BY 4.0</a>). I tweaked the size and orientation of the model to use it
as a drop in replacement for the current geometry:</p>
<ul>
<li><a href="/resources/viking_room.obj">viking_room.obj</a></li>
<li><a href="/resources/viking_room.png">viking_room.png</a></li>
</ul>
<p>Feel free to use your own model, but make sure that it only consists of one
material and that is has dimensions of about 1.5 x 1.5 x 1.5 units. If it is
larger than that, then you'll have to change the view matrix. Put the model file
in a new <code>models</code> directory next to <code>shaders</code> and <code>textures</code>, and put the
texture image in the <code>textures</code> directory.</p>
<p>Put two new configuration variables in your program to define the model and
texture paths:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> WIDTH = <span class="hljs-number">800</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> HEIGHT = <span class="hljs-number">600</span>;

<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> MODEL_PATH = <span class="hljs-string">"models/viking_room.obj"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> TEXTURE_PATH = <span class="hljs-string">"textures/viking_room.png"</span>;
</div></code></pre>
<p>And update <code>createTextureImage</code> to use this path variable:</p>
<pre class="hljs"><code><div>stbi_uc* pixels = stbi_load(TEXTURE_PATH.c_str(), &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);
</div></code></pre>
<h2 id="loading-vertices-and-indices">Loading vertices and indices</h2>
<p>We're going to load the vertices and indices from the model file now, so you
should remove the global <code>vertices</code> and <code>indices</code> arrays now. Replace them with
non-const containers as class members:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; indices;
VkBuffer vertexBuffer;
VkDeviceMemory vertexBufferMemory;
</div></code></pre>
<p>You should change the type of the indices from <code>uint16_t</code> to <code>uint32_t</code>, because
there are going to be a lot more vertices than 65535. Remember to also change
the <code>vkCmdBindIndexBuffer</code> parameter:</p>
<pre class="hljs"><code><div>vkCmdBindIndexBuffer(commandBuffer, indexBuffer, <span class="hljs-number">0</span>, VK_INDEX_TYPE_UINT32);
</div></code></pre>
<p>The tinyobjloader library is included in the same way as STB libraries. Include
the <code>tiny_obj_loader.h</code> file and make sure to define
<code>TINYOBJLOADER_IMPLEMENTATION</code> in one source file to include the function
bodies and avoid linker errors:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TINYOBJLOADER_IMPLEMENTATION</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;tiny_obj_loader.h&gt;</span></span>
</div></code></pre>
<p>We're now going to write a <code>loadModel</code> function that uses this library to
populate the <code>vertices</code> and <code>indices</code> containers with the vertex data from the
mesh. It should be called somewhere before the vertex and index buffers are
created:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    loadModel();
    createVertexBuffer();
    createIndexBuffer();
    ...
}

...

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadModel</span><span class="hljs-params">()</span> </span>{

}
</div></code></pre>
<p>A model is loaded into the library's data structures by calling the
<code>tinyobj::LoadObj</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadModel</span><span class="hljs-params">()</span> </span>{
    tinyobj::<span class="hljs-keyword">attrib_t</span> attrib;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;tinyobj::<span class="hljs-keyword">shape_t</span>&gt; shapes;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;tinyobj::<span class="hljs-keyword">material_t</span>&gt; materials;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> warn, err;

    <span class="hljs-keyword">if</span> (!tinyobj::LoadObj(&amp;attrib, &amp;shapes, &amp;materials, &amp;warn, &amp;err, MODEL_PATH.c_str())) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(warn + err);
    }
}
</div></code></pre>
<p>An OBJ file consists of positions, normals, texture coordinates and faces. Faces
consist of an arbitrary amount of vertices, where each vertex refers to a
position, normal and/or texture coordinate by index. This makes it possible to
not just reuse entire vertices, but also individual attributes.</p>
<p>The <code>attrib</code> container holds all of the positions, normals and texture
coordinates in its <code>attrib.vertices</code>, <code>attrib.normals</code> and <code>attrib.texcoords</code>
vectors. The <code>shapes</code> container contains all of the separate objects and their
faces. Each face consists of an array of vertices, and each vertex contains the
indices of the position, normal and texture coordinate attributes. OBJ models
can also define a material and texture per face, but we will be ignoring those.</p>
<p>The <code>err</code> string contains errors and the <code>warn</code> string contains warnings that occurred while loading the
file, like a missing material definition. Loading only really failed if the
<code>LoadObj</code> function returns <code>false</code>. As mentioned above, faces in OBJ files can
actually contain an arbitrary number of vertices, whereas our application can
only render triangles. Luckily the <code>LoadObj</code> has an optional parameter to
automatically triangulate such faces, which is enabled by default.</p>
<p>We're going to combine all of the faces in the file into a single model, so just
iterate over all of the shapes:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; shape : shapes) {

}
</div></code></pre>
<p>The triangulation feature has already made sure that there are three vertices
per face, so we can now directly iterate over the vertices and dump them
straight into our <code>vertices</code> vector:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; shape : shapes) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; index : shape.mesh.indices) {
        Vertex vertex{};

        vertices.push_back(vertex);
        indices.push_back(indices.<span class="hljs-built_in">size</span>());
    }
}
</div></code></pre>
<p>For simplicity, we will assume that every vertex is unique for now, hence the
simple auto-increment indices. The <code>index</code> variable is of type
<code>tinyobj::index_t</code>, which contains the <code>vertex_index</code>, <code>normal_index</code> and
<code>texcoord_index</code> members. We need to use these indices to look up the actual
vertex attributes in the <code>attrib</code> arrays:</p>
<pre class="hljs"><code><div>vertex.pos = {
    attrib.vertices[<span class="hljs-number">3</span> * index.vertex_index + <span class="hljs-number">0</span>],
    attrib.vertices[<span class="hljs-number">3</span> * index.vertex_index + <span class="hljs-number">1</span>],
    attrib.vertices[<span class="hljs-number">3</span> * index.vertex_index + <span class="hljs-number">2</span>]
};

vertex.texCoord = {
    attrib.texcoords[<span class="hljs-number">2</span> * index.texcoord_index + <span class="hljs-number">0</span>],
    attrib.texcoords[<span class="hljs-number">2</span> * index.texcoord_index + <span class="hljs-number">1</span>]
};

vertex.color = {<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>};
</div></code></pre>
<p>Unfortunately the <code>attrib.vertices</code> array is an array of <code>float</code> values instead
of something like <code>glm::vec3</code>, so you need to multiply the index by <code>3</code>.
Similarly, there are two texture coordinate components per entry. The offsets of
<code>0</code>, <code>1</code> and <code>2</code> are used to access the X, Y and Z components, or the U and V
components in the case of texture coordinates.</p>
<p>Run your program now with optimization enabled (e.g. <code>Release</code> mode in Visual
Studio and with the <code>-O3</code> compiler flag for GCC`). This is necessary, because
otherwise loading the model will be very slow. You should see something like the
following:</p>
<p><img src="images/inverted_texture_coordinates.png" alt=""></p>
<p>Great, the geometry looks correct, but what's going on with the texture? The OBJ format assumes a coordinate system where a vertical coordinate of <code>0</code> means the bottom of the image, however we've uploaded our image into Vulkan in a top to bottom orientation where <code>0</code> means the top of the image. Solve this by
flipping the vertical component of the texture coordinates:</p>
<pre class="hljs"><code><div>vertex.texCoord = {
    attrib.texcoords[<span class="hljs-number">2</span> * index.texcoord_index + <span class="hljs-number">0</span>],
    <span class="hljs-number">1.0f</span> - attrib.texcoords[<span class="hljs-number">2</span> * index.texcoord_index + <span class="hljs-number">1</span>]
};
</div></code></pre>
<p>When you run your program again, you should now see the correct result:</p>
<p><img src="images/drawing_model.png" alt=""></p>
<p>All that hard work is finally beginning to pay off with a demo like this!</p>
<blockquote>
<p>As the model rotates you may notice that the rear (backside of the walls) looks a bit funny. This is normal and is simply because the model is not really designed to be viewed from that side.</p>
</blockquote>
<h2 id="vertex-deduplication">Vertex deduplication</h2>
<p>Unfortunately we're not really taking advantage of the index buffer yet. The
<code>vertices</code> vector contains a lot of duplicated vertex data, because many
vertices are included in multiple triangles. We should keep only the unique
vertices and use the index buffer to reuse them whenever they come up. A
straightforward way to implement this is to use a <code>map</code> or <code>unordered_map</code> to
keep track of the unique vertices and respective indices:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>

...

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;Vertex, <span class="hljs-keyword">uint32_t</span>&gt; uniqueVertices{};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; shape : shapes) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; index : shape.mesh.indices) {
        Vertex vertex{};

        ...

        <span class="hljs-keyword">if</span> (uniqueVertices.count(vertex) == <span class="hljs-number">0</span>) {
            uniqueVertices[vertex] = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(vertices.<span class="hljs-built_in">size</span>());
            vertices.push_back(vertex);
        }

        indices.push_back(uniqueVertices[vertex]);
    }
}
</div></code></pre>
<p>Every time we read a vertex from the OBJ file, we check if we've already seen a
vertex with the exact same position and texture coordinates before. If not, we
add it to <code>vertices</code> and store its index in the <code>uniqueVertices</code> container.
After that we add the index of the new vertex to <code>indices</code>. If we've seen the
exact same vertex before, then we look up its index in <code>uniqueVertices</code> and
store that index in <code>indices</code>.</p>
<p>The program will fail to compile right now, because using a user-defined type
like our <code>Vertex</code> struct as key in a hash table requires us to implement two
functions: equality test and hash calculation. The former is easy to implement
by overriding the <code>==</code> operator in the <code>Vertex</code> struct:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Vertex&amp; other) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> pos == other.pos &amp;&amp; color == other.color &amp;&amp; texCoord == other.texCoord;
}
</div></code></pre>
<p>A hash function for <code>Vertex</code> is implemented by specifying a template
specialization for <code>std::hash&lt;T&gt;</code>. Hash functions are a complex topic, but
<a href="http://en.cppreference.com/w/cpp/utility/hash">cppreference.com recommends</a> the
following approach combining the fields of a struct to create a decent quality
hash function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span> {
    <span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;Vertex&gt; {</span>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Vertex <span class="hljs-keyword">const</span>&amp; vertex)</span> <span class="hljs-keyword">const</span> </span>{
            <span class="hljs-keyword">return</span> ((hash&lt;glm::vec3&gt;()(vertex.pos) ^
                   (hash&lt;glm::vec3&gt;()(vertex.color) &lt;&lt; <span class="hljs-number">1</span>)) &gt;&gt; <span class="hljs-number">1</span>) ^
                   (hash&lt;glm::vec2&gt;()(vertex.texCoord) &lt;&lt; <span class="hljs-number">1</span>);
        }
    };
}
</div></code></pre>
<p>This code should be placed outside the <code>Vertex</code> struct. The hash functions for
the GLM types need to be included using the following header:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLM_ENABLE_EXPERIMENTAL</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glm/gtx/hash.hpp&gt;</span></span>
</div></code></pre>
<p>The hash functions are defined in the <code>gtx</code> folder, which means that it is
technically still an experimental extension to GLM. Therefore you need to define
<code>GLM_ENABLE_EXPERIMENTAL</code> to use it. It means that the API could change with a
new version of GLM in the future, but in practice the API is very stable.</p>
<p>You should now be able to successfully compile and run your program. If you
check the size of <code>vertices</code>, then you'll see that it has shrunk down from
1,500,000 to 265,645! That means that each vertex is reused in an average number
of ~6 triangles. This definitely saves us a lot of GPU memory.</p>
<p><a href="/code/28_model_loading.cpp">C++ code</a> /
<a href="/code/27_shader_depth.vert">Vertex shader</a> /
<a href="/code/27_shader_depth.frag">Fragment shader</a></p>
<h1 id="10---generating-mipmaps">10 - Generating Mipmaps</h1>
<h2 id="introduction">Introduction</h2>
<p>Our program can now load and render 3D models. In this chapter, we will add one more feature, mipmap generation. Mipmaps are widely used in games and rendering software, and Vulkan gives us complete control over how they are created.</p>
<p>Mipmaps are precalculated, downscaled versions of an image. Each new image is half the width and height of the previous one.  Mipmaps are used as a form of <em>Level of Detail</em> or <em>LOD.</em> Objects that are far away from the camera will sample their textures from the smaller mip images. Using smaller images increases the rendering speed and avoids artifacts such as <a href="https://en.wikipedia.org/wiki/Moir%C3%A9_pattern">Moir patterns</a>. An example of what mipmaps look like:</p>
<p><img src="images/mipmaps_example.jpg" alt=""></p>
<h2 id="image-creation">Image creation</h2>
<p>In Vulkan, each of the mip images is stored in different <em>mip levels</em> of a <code>VkImage</code>. Mip level 0 is the original image, and the mip levels after level 0 are commonly referred to as the <em>mip chain.</em></p>
<p>The number of mip levels is specified when the <code>VkImage</code> is created. Up until now, we have always set this value to one. We need to calculate the number of mip levels from the dimensions of the image. First, add a class member to store this number:</p>
<pre class="hljs"><code><div>...
<span class="hljs-keyword">uint32_t</span> mipLevels;
VkImage textureImage;
...
</div></code></pre>
<p>The value for <code>mipLevels</code> can be found once we've loaded the texture in <code>createTextureImage</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> texWidth, texHeight, texChannels;
stbi_uc* pixels = stbi_load(TEXTURE_PATH.c_str(), &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);
...
mipLevels = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">std</span>::log2(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">max</span>(texWidth, texHeight)))) + <span class="hljs-number">1</span>;

</div></code></pre>
<p>This calculates the number of levels in the mip chain. The <code>max</code> function selects the largest dimension. The <code>log2</code> function calculates how many times that dimension can be divided by 2. The <code>floor</code> function handles cases where the largest dimension is not a power of 2.  <code>1</code> is added so that the original image has a mip level.</p>
<p>To use this value, we need to change the <code>createImage</code>, <code>createImageView</code>, and <code>transitionImageLayout</code> functions to allow us to specify the number of mip levels. Add a <code>mipLevels</code> parameter to the functions:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createImage</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">width</span>, <span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">height</span>, <span class="hljs-keyword">uint32_t</span> mipLevels, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; <span class="hljs-built_in">image</span>, VkDeviceMemory&amp; imageMemory)</span> </span>{
    ...
    imageInfo.mipLevels = mipLevels;
    ...
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function">VkImageView <span class="hljs-title">createImageView</span><span class="hljs-params">(VkImage <span class="hljs-built_in">image</span>, VkFormat format, VkImageAspectFlags aspectFlags, <span class="hljs-keyword">uint32_t</span> mipLevels)</span> </span>{
    ...
    viewInfo.subresourceRange.levelCount = mipLevels;
    ...
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transitionImageLayout</span><span class="hljs-params">(VkImage <span class="hljs-built_in">image</span>, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout, <span class="hljs-keyword">uint32_t</span> mipLevels)</span> </span>{
    ...
    barrier.subresourceRange.levelCount = mipLevels;
    ...
</div></code></pre>
<p>Update all calls to these functions to use the right values:</p>
<pre class="hljs"><code><div>createImage(swapChainExtent.<span class="hljs-built_in">width</span>, swapChainExtent.<span class="hljs-built_in">height</span>, <span class="hljs-number">1</span>, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);
...
createImage(texWidth, texHeight, mipLevels, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);
</div></code></pre>
<pre class="hljs"><code><div>swapChainImageViews[i] = createImageView(swapChainImages[i], swapChainImageFormat, VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">1</span>);
...
depthImageView = createImageView(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT, <span class="hljs-number">1</span>);
...
textureImageView = createImageView(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT, mipLevels);
</div></code></pre>
<pre class="hljs"><code><div>transitionImageLayout(depthImage, depthFormat, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, <span class="hljs-number">1</span>);
...
transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels);
</div></code></pre>
<h2 id="generating-mipmaps">Generating Mipmaps</h2>
<p>Our texture image now has multiple mip levels, but the staging buffer can only be used to fill mip level 0. The other levels are still undefined. To fill these levels we need to generate the data from the single level that we have. We will use the <code>vkCmdBlitImage</code> command. This command performs copying, scaling, and filtering operations. We will call this multiple times to <em>blit</em> data to each level of our texture image.</p>
<p><code>vkCmdBlitImage</code> is considered a transfer operation, so we must inform Vulkan that we intend to use the texture image as both the source and destination of a transfer. Add <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> to the texture image's usage flags in <code>createTextureImage</code>:</p>
<pre class="hljs"><code><div>...
createImage(texWidth, texHeight, mipLevels, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);
...
</div></code></pre>
<p>Like other image operations, <code>vkCmdBlitImage</code> depends on the layout of the image it operates on. We could transition the entire image to <code>VK_IMAGE_LAYOUT_GENERAL</code>, but this will most likely be slow. For optimal performance, the source image should be in <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> and the destination image should be in <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>. Vulkan allows us to transition each mip level of an image independently. Each blit will only deal with two mip levels at a time, so we can transition each level into the optimal layout between blits commands.</p>
<p><code>transitionImageLayout</code> only performs layout transitions on the entire image, so we'll need to write a few more pipeline barrier commands. Remove the existing transition to <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code> in <code>createTextureImage</code>:</p>
<pre class="hljs"><code><div>...
transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels);
    copyBufferToImage(stagingBuffer, textureImage, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(texWidth), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(texHeight));
<span class="hljs-comment">//transitioned to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL while generating mipmaps</span>
...
</div></code></pre>
<p>This will leave each level of the texture image in <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>. Each level will be transitioned to <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code> after the blit command reading from it is finished.</p>
<p>We're now going to write the function that generates the mipmaps:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateMipmaps</span><span class="hljs-params">(VkImage <span class="hljs-built_in">image</span>, <span class="hljs-keyword">int32_t</span> texWidth, <span class="hljs-keyword">int32_t</span> texHeight, <span class="hljs-keyword">uint32_t</span> mipLevels)</span> </span>{
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkImageMemoryBarrier barrier{};
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    barrier.<span class="hljs-built_in">image</span> = <span class="hljs-built_in">image</span>;
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;
    barrier.subresourceRange.layerCount = <span class="hljs-number">1</span>;
    barrier.subresourceRange.levelCount = <span class="hljs-number">1</span>;

    endSingleTimeCommands(commandBuffer);
}
</div></code></pre>
<p>We're going to make several transitions, so we'll reuse this <code>VkImageMemoryBarrier</code>. The fields set above will remain the same for all barriers. <code>subresourceRange.miplevel</code>, <code>oldLayout</code>, <code>newLayout</code>, <code>srcAccessMask</code>, and <code>dstAccessMask</code> will be changed for each transition.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int32_t</span> mipWidth = texWidth;
<span class="hljs-keyword">int32_t</span> mipHeight = texHeight;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">1</span>; i &lt; mipLevels; i++) {

}
</div></code></pre>
<p>This loop will record each of the <code>VkCmdBlitImage</code> commands. Note that the loop variable starts at 1, not 0.</p>
<pre class="hljs"><code><div>barrier.subresourceRange.baseMipLevel = i - <span class="hljs-number">1</span>;
barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;

vkCmdPipelineBarrier(commandBuffer,
    VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, <span class="hljs-number">0</span>,
    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,
    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,
    <span class="hljs-number">1</span>, &amp;barrier);
</div></code></pre>
<p>First, we transition level <code>i - 1</code> to <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code>. This transition will wait for level <code>i - 1</code> to be filled, either from the previous blit command, or from <code>vkCmdCopyBufferToImage</code>. The current blit command will wait on this transition.</p>
<pre class="hljs"><code><div>VkImageBlit blit{};
blit.srcOffsets[<span class="hljs-number">0</span>] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };
blit.srcOffsets[<span class="hljs-number">1</span>] = { mipWidth, mipHeight, <span class="hljs-number">1</span> };
blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
blit.srcSubresource.mipLevel = i - <span class="hljs-number">1</span>;
blit.srcSubresource.baseArrayLayer = <span class="hljs-number">0</span>;
blit.srcSubresource.layerCount = <span class="hljs-number">1</span>;
blit.dstOffsets[<span class="hljs-number">0</span>] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };
blit.dstOffsets[<span class="hljs-number">1</span>] = { mipWidth &gt; <span class="hljs-number">1</span> ? mipWidth / <span class="hljs-number">2</span> : <span class="hljs-number">1</span>, mipHeight &gt; <span class="hljs-number">1</span> ? mipHeight / <span class="hljs-number">2</span> : <span class="hljs-number">1</span>, <span class="hljs-number">1</span> };
blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
blit.dstSubresource.mipLevel = i;
blit.dstSubresource.baseArrayLayer = <span class="hljs-number">0</span>;
blit.dstSubresource.layerCount = <span class="hljs-number">1</span>;
</div></code></pre>
<p>Next, we specify the regions that will be used in the blit operation. The source mip level is <code>i - 1</code> and the destination mip level is <code>i</code>. The two elements of the <code>srcOffsets</code> array determine the 3D region that data will be blitted from. <code>dstOffsets</code> determines the region that data will be blitted to. The X and Y dimensions of the <code>dstOffsets[1]</code> are divided by two since each mip level is half the size of the previous level. The Z dimension of <code>srcOffsets[1]</code> and <code>dstOffsets[1]</code> must be 1, since a 2D image has a depth of 1.</p>
<pre class="hljs"><code><div>vkCmdBlitImage(commandBuffer,
    <span class="hljs-built_in">image</span>, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
    <span class="hljs-built_in">image</span>, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    <span class="hljs-number">1</span>, &amp;blit,
    VK_FILTER_LINEAR);
</div></code></pre>
<p>Now, we record the blit command. Note that <code>textureImage</code> is used for both the <code>srcImage</code> and <code>dstImage</code> parameter. This is because we're blitting between different levels of the same image. The source mip level was just transitioned to <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> and the destination level is still in <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> from <code>createTextureImage</code>.</p>
<p>Beware if you are using a dedicated transfer queue (as suggested in <a href="!en/Vertex_buffers/Staging_buffer">Vertex buffers</a>): <code>vkCmdBlitImage</code> must be submitted to a queue with graphics capability.</p>
<p>The last parameter allows us to specify a <code>VkFilter</code> to use in the blit. We have the same filtering options here that we had when making the <code>VkSampler</code>. We use the <code>VK_FILTER_LINEAR</code> to enable interpolation.</p>
<pre class="hljs"><code><div>barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

vkCmdPipelineBarrier(commandBuffer,
    VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, <span class="hljs-number">0</span>,
    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,
    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,
    <span class="hljs-number">1</span>, &amp;barrier);
</div></code></pre>
<p>This barrier transitions mip level <code>i - 1</code> to <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>. This transition waits on the current blit command to finish. All sampling operations will wait on this transition to finish.</p>
<pre class="hljs"><code><div>    ...
    <span class="hljs-keyword">if</span> (mipWidth &gt; <span class="hljs-number">1</span>) mipWidth /= <span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span> (mipHeight &gt; <span class="hljs-number">1</span>) mipHeight /= <span class="hljs-number">2</span>;
}
</div></code></pre>
<p>At the end of the loop, we divide the current mip dimensions by two. We check each dimension before the division to ensure that dimension never becomes 0. This handles cases where the image is not square, since one of the mip dimensions would reach 1 before the other dimension. When this happens, that dimension should remain 1 for all remaining levels.</p>
<pre class="hljs"><code><div>    barrier.subresourceRange.baseMipLevel = mipLevels - <span class="hljs-number">1</span>;
    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

    vkCmdPipelineBarrier(commandBuffer,
        VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,
        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,
        <span class="hljs-number">1</span>, &amp;barrier);

    endSingleTimeCommands(commandBuffer);
}
</div></code></pre>
<p>Before we end the command buffer, we insert one more pipeline barrier. This barrier transitions the last mip level from <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> to <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>. This wasn't handled by the loop, since the last mip level is never blitted from.</p>
<p>Finally, add the call to <code>generateMipmaps</code> in <code>createTextureImage</code>:</p>
<pre class="hljs"><code><div>transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels);
    copyBufferToImage(stagingBuffer, textureImage, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(texWidth), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(texHeight));
<span class="hljs-comment">//transitioned to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL while generating mipmaps</span>
...
generateMipmaps(textureImage, texWidth, texHeight, mipLevels);
</div></code></pre>
<p>Our texture image's mipmaps are now completely filled.</p>
<h2 id="linear-filtering-support">Linear filtering support</h2>
<p>It is very convenient to use a built-in function like <code>vkCmdBlitImage</code> to generate all the mip levels, but unfortunately it is not guaranteed to be supported on all platforms. It requires the texture image format we use to support linear filtering, which can be checked with the <code>vkGetPhysicalDeviceFormatProperties</code> function. We will add a check to the <code>generateMipmaps</code> function for this.</p>
<p>First add an additional parameter that specifies the image format:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>{
    ...

    generateMipmaps(textureImage, VK_FORMAT_R8G8B8A8_SRGB, texWidth, texHeight, mipLevels);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateMipmaps</span><span class="hljs-params">(VkImage <span class="hljs-built_in">image</span>, VkFormat imageFormat, <span class="hljs-keyword">int32_t</span> texWidth, <span class="hljs-keyword">int32_t</span> texHeight, <span class="hljs-keyword">uint32_t</span> mipLevels)</span> </span>{

    ...
}
</div></code></pre>
<p>In the <code>generateMipmaps</code> function, use <code>vkGetPhysicalDeviceFormatProperties</code> to request the properties of the texture image format:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateMipmaps</span><span class="hljs-params">(VkImage <span class="hljs-built_in">image</span>, VkFormat imageFormat, <span class="hljs-keyword">int32_t</span> texWidth, <span class="hljs-keyword">int32_t</span> texHeight, <span class="hljs-keyword">uint32_t</span> mipLevels)</span> </span>{

    <span class="hljs-comment">// Check if image format supports linear blitting</span>
    VkFormatProperties formatProperties;
    vkGetPhysicalDeviceFormatProperties(physicalDevice, imageFormat, &amp;formatProperties);

    ...
</div></code></pre>
<p>The <code>VkFormatProperties</code> struct has three fields named <code>linearTilingFeatures</code>, <code>optimalTilingFeatures</code> and <code>bufferFeatures</code> that each describe how the format can be used depending on the way it is used. We create a texture image with the optimal tiling format, so we need to check <code>optimalTilingFeatures</code>. Support for the linear filtering feature can be checked with the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (!(formatProperties.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"texture image format does not support linear blitting!"</span>);
}
</div></code></pre>
<p>There are two alternatives in this case. You could implement a function that searches common texture image formats for one that <em>does</em> support linear blitting, or you could implement the mipmap generation in software with a library like <a href="https://github.com/nothings/stb/blob/master/stb_image_resize.h">stb_image_resize</a>. Each mip level can then be loaded into the image in the same way that you loaded the original image.</p>
<p>It should be noted that it is uncommon in practice to generate the mipmap levels at runtime anyway. Usually they are pregenerated and stored in the texture file alongside the base level to improve loading speed. Implementing resizing in software and loading multiple levels from a file is left as an exercise to the reader.</p>
<h2 id="sampler">Sampler</h2>
<p>While the <code>VkImage</code> holds the mipmap data, <code>VkSampler</code> controls how that data is read while rendering. Vulkan allows us to specify <code>minLod</code>, <code>maxLod</code>, <code>mipLodBias</code>, and <code>mipmapMode</code> (&quot;Lod&quot; means &quot;Level of Detail&quot;). When a texture is sampled, the sampler selects a mip level according to the following pseudocode:</p>
<pre class="hljs"><code><div>lod = getLodLevelFromScreenSize(); <span class="hljs-comment">//smaller when the object is close, may be negative</span>
lod = clamp(lod + mipLodBias, minLod, maxLod);

level = clamp(<span class="hljs-built_in">floor</span>(lod), <span class="hljs-number">0</span>, texture.mipLevels - <span class="hljs-number">1</span>);  <span class="hljs-comment">//clamped to the number of mip levels in the texture</span>

<span class="hljs-keyword">if</span> (mipmapMode == VK_SAMPLER_MIPMAP_MODE_NEAREST) {
    color = sample(level);
} <span class="hljs-keyword">else</span> {
    color = blend(sample(level), sample(level + <span class="hljs-number">1</span>));
}
</div></code></pre>
<p>If <code>samplerInfo.mipmapMode</code> is <code>VK_SAMPLER_MIPMAP_MODE_NEAREST</code>, <code>lod</code> selects the mip level to sample from. If the mipmap mode is <code>VK_SAMPLER_MIPMAP_MODE_LINEAR</code>, <code>lod</code> is used to select two mip levels to be sampled. Those levels are sampled and the results are linearly blended.</p>
<p>The sample operation is also affected by <code>lod</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (lod &lt;= <span class="hljs-number">0</span>) {
    color = readTexture(uv, magFilter);
} <span class="hljs-keyword">else</span> {
    color = readTexture(uv, minFilter);
}
</div></code></pre>
<p>If the object is close to the camera, <code>magFilter</code> is used as the filter. If the object is further from the camera, <code>minFilter</code> is used. Normally, <code>lod</code> is non-negative, and is only 0 when close the camera. <code>mipLodBias</code> lets us force Vulkan to use lower <code>lod</code> and <code>level</code> than it would normally use.</p>
<p>To see the results of this chapter, we need to choose values for our <code>textureSampler</code>. We've already set the <code>minFilter</code> and <code>magFilter</code> to use <code>VK_FILTER_LINEAR</code>. We just need to choose values for <code>minLod</code>, <code>maxLod</code>, <code>mipLodBias</code>, and <code>mipmapMode</code>.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createTextureSampler</span><span class="hljs-params">()</span> </span>{
    ...
    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
    samplerInfo.minLod = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span>
    samplerInfo.maxLod = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(mipLevels);
    samplerInfo.mipLodBias = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span>
    ...
}
</div></code></pre>
<p>To allow the full range of mip levels to be used, we set <code>minLod</code> to 0.0f, and <code>maxLod</code> to the number of mip levels. We have no reason to change the <code>lod</code> value , so we set <code>mipLodBias</code> to 0.0f.</p>
<p>Now run your program and you should see the following:</p>
<p><img src="images/mipmaps.png" alt=""></p>
<p>It's not a dramatic difference, since our scene is so simple. There are subtle differences if you look closely.</p>
<p><img src="images/mipmaps_comparison.png" alt=""></p>
<p>The most noticeable difference is the writing on the papers. With mipmaps, the writing has been smoothed. Without mipmaps, the writing has harsh edges and gaps from Moir artifacts.</p>
<p>You can play around with the sampler settings to see how they affect mipmapping. For example, by changing <code>minLod</code>, you can force the sampler to not use the lowest mip levels:</p>
<pre class="hljs"><code><div>samplerInfo.minLod = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(mipLevels / <span class="hljs-number">2</span>);
</div></code></pre>
<p>These settings will produce this image:</p>
<p><img src="images/highmipmaps.png" alt=""></p>
<p>This is how higher mip levels will be used when objects are further away from the camera.</p>
<p><a href="/code/29_mipmapping.cpp">C++ code</a> /
<a href="/code/27_shader_depth.vert">Vertex shader</a> /
<a href="/code/27_shader_depth.frag">Fragment shader</a></p>
<h1 id="11---multisampling">11 - Multisampling</h1>
<h2 id="introduction">Introduction</h2>
<p>Our program can now load multiple levels of detail for textures which fixes artifacts when rendering objects far away from the viewer. The image is now a lot smoother, however on closer inspection you will notice jagged saw-like patterns along the edges of drawn geometric shapes. This is especially visible in one of our early programs when we rendered a quad:</p>
<p><img src="images/texcoord_visualization.png" alt=""></p>
<p>This undesired effect is called &quot;aliasing&quot; and it's a result of a limited numbers of pixels that are available for rendering. Since there are no displays out there with unlimited resolution, it will be always visible to some extent. There's a number of ways to fix this and in this chapter we'll focus on one of the more popular ones: <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">Multisample anti-aliasing</a> (MSAA).</p>
<p>In ordinary rendering, the pixel color is determined based on a single sample point which in most cases is the center of the target pixel on screen. If part of the drawn line passes through a certain pixel but doesn't cover the sample point, that pixel will be left blank, leading to the jagged &quot;staircase&quot; effect.</p>
<p><img src="images/aliasing.png" alt=""></p>
<p>What MSAA does is it uses multiple sample points per pixel (hence the name) to determine its final color. As one might expect, more samples lead to better results, however it is also more computationally expensive.</p>
<p><img src="images/antialiasing.png" alt=""></p>
<p>In our implementation, we will focus on using the maximum available sample count. Depending on your application this may not always be the best approach and it might be better to use less samples for the sake of higher performance if the final result meets your quality demands.</p>
<h2 id="getting-available-sample-count">Getting available sample count</h2>
<p>Let's start off by determining how many samples our hardware can use. Most modern GPUs support at least 8 samples but this number is not guaranteed to be the same everywhere. We'll keep track of it by adding a new class member:</p>
<pre class="hljs"><code><div>...
VkSampleCountFlagBits msaaSamples = VK_SAMPLE_COUNT_1_BIT;
...
</div></code></pre>
<p>By default we'll be using only one sample per pixel which is equivalent to no multisampling, in which case the final image will remain unchanged. The exact maximum number of samples can be extracted from <code>VkPhysicalDeviceProperties</code> associated with our selected physical device. We're using a depth buffer, so we have to take into account the sample count for both color and depth. The highest sample count that is supported by both (&amp;) will be the maximum we can support. Add a function that will fetch this information for us:</p>
<pre class="hljs"><code><div><span class="hljs-function">VkSampleCountFlagBits <span class="hljs-title">getMaxUsableSampleCount</span><span class="hljs-params">()</span> </span>{
    VkPhysicalDeviceProperties physicalDeviceProperties;
    vkGetPhysicalDeviceProperties(physicalDevice, &amp;physicalDeviceProperties);

    VkSampleCountFlags counts = physicalDeviceProperties.limits.framebufferColorSampleCounts &amp; physicalDeviceProperties.limits.framebufferDepthSampleCounts;
    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_64_BIT) { <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_64_BIT; }
    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_32_BIT) { <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_32_BIT; }
    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_16_BIT) { <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_16_BIT; }
    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_8_BIT) { <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_8_BIT; }
    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_4_BIT) { <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_4_BIT; }
    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_2_BIT) { <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_2_BIT; }

    <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_1_BIT;
}
</div></code></pre>
<p>We will now use this function to set the <code>msaaSamples</code> variable during the physical device selection process. For this, we have to slightly modify the <code>pickPhysicalDevice</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pickPhysicalDevice</span><span class="hljs-params">()</span> </span>{
    ...
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; device : devices) {
        <span class="hljs-keyword">if</span> (isDeviceSuitable(device)) {
            physicalDevice = device;
            msaaSamples = getMaxUsableSampleCount();
            <span class="hljs-keyword">break</span>;
        }
    }
    ...
}
</div></code></pre>
<h2 id="setting-up-a-render-target">Setting up a render target</h2>
<p>In MSAA, each pixel is sampled in an offscreen buffer which is then rendered to the screen. This new buffer is slightly different from regular images we've been rendering to - they have to be able to store more than one sample per pixel. Once a multisampled buffer is created, it has to be resolved to the default framebuffer (which stores only a single sample per pixel). This is why we have to create an additional render target and modify our current drawing process. We only need one render target since only one drawing operation is active at a time, just like with the depth buffer. Add the following class members:</p>
<pre class="hljs"><code><div>...
VkImage colorImage;
VkDeviceMemory colorImageMemory;
VkImageView colorImageView;
...
</div></code></pre>
<p>This new image will have to store the desired number of samples per pixel, so we need to pass this number to <code>VkImageCreateInfo</code> during the image creation process. Modify the <code>createImage</code> function by adding a <code>numSamples</code> parameter:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createImage</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">width</span>, <span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">height</span>, <span class="hljs-keyword">uint32_t</span> mipLevels, VkSampleCountFlagBits numSamples, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; <span class="hljs-built_in">image</span>, VkDeviceMemory&amp; imageMemory)</span> </span>{
    ...
    imageInfo.samples = numSamples;
    ...
</div></code></pre>
<p>For now, update all calls to this function using <code>VK_SAMPLE_COUNT_1_BIT</code> - we will be replacing this with proper values as we progress with implementation:</p>
<pre class="hljs"><code><div>createImage(swapChainExtent.<span class="hljs-built_in">width</span>, swapChainExtent.<span class="hljs-built_in">height</span>, <span class="hljs-number">1</span>, VK_SAMPLE_COUNT_1_BIT, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);
...
createImage(texWidth, texHeight, mipLevels, VK_SAMPLE_COUNT_1_BIT, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);
</div></code></pre>
<p>We will now create a multisampled color buffer. Add a <code>createColorResources</code> function and note that we're using <code>msaaSamples</code> here as a function parameter to <code>createImage</code>. We're also using only one mip level, since this is enforced by the Vulkan specification in case of images with more than one sample per pixel. Also, this color buffer doesn't need mipmaps since it's not going to be used as a texture:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createColorResources</span><span class="hljs-params">()</span> </span>{
    VkFormat colorFormat = swapChainImageFormat;

    createImage(swapChainExtent.<span class="hljs-built_in">width</span>, swapChainExtent.<span class="hljs-built_in">height</span>, <span class="hljs-number">1</span>, msaaSamples, colorFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, colorImage, colorImageMemory);
    colorImageView = createImageView(colorImage, colorFormat, VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">1</span>);
}
</div></code></pre>
<p>For consistency, call the function right before <code>createDepthResources</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
    ...
    createColorResources();
    createDepthResources();
    ...
}
</div></code></pre>
<p>Now that we have a multisampled color buffer in place it's time to take care of depth. Modify <code>createDepthResources</code> and update the number of samples used by the depth buffer:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createDepthResources</span><span class="hljs-params">()</span> </span>{
    ...
    createImage(swapChainExtent.<span class="hljs-built_in">width</span>, swapChainExtent.<span class="hljs-built_in">height</span>, <span class="hljs-number">1</span>, msaaSamples, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);
    ...
}
</div></code></pre>
<p>We have now created a couple of new Vulkan resources, so let's not forget to release them when necessary:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanupSwapChain</span><span class="hljs-params">()</span> </span>{
    vkDestroyImageView(device, colorImageView, <span class="hljs-literal">nullptr</span>);
    vkDestroyImage(device, colorImage, <span class="hljs-literal">nullptr</span>);
    vkFreeMemory(device, colorImageMemory, <span class="hljs-literal">nullptr</span>);
    ...
}
</div></code></pre>
<p>And update the <code>recreateSwapChain</code> so that the new color image can be recreated in the correct resolution when the window is resized:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>{
    ...
    createGraphicsPipeline();
    createColorResources();
    createDepthResources();
    ...
}
</div></code></pre>
<p>We made it past the initial MSAA setup, now we need to start using this new resource in our graphics pipeline, framebuffer, render pass and see the results!</p>
<h2 id="adding-new-attachments">Adding new attachments</h2>
<p>Let's take care of the render pass first. Modify <code>createRenderPass</code> and update color and depth attachment creation info structs:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createRenderPass</span><span class="hljs-params">()</span> </span>{
    ...
    colorAttachment.samples = msaaSamples;
    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    ...
    depthAttachment.samples = msaaSamples;
    ...
</div></code></pre>
<p>You'll notice that we have changed the finalLayout from <code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code> to <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code>. That's because multisampled images cannot be presented directly. We first need to resolve them to a regular image. This requirement does not apply to the depth buffer, since it won't be presented at any point. Therefore we will have to add only one new attachment for color which is a so-called resolve attachment:</p>
<pre class="hljs"><code><div>    ...
    VkAttachmentDescription colorAttachmentResolve{};
    colorAttachmentResolve.format = swapChainImageFormat;
    colorAttachmentResolve.samples = VK_SAMPLE_COUNT_1_BIT;
    colorAttachmentResolve.loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachmentResolve.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    colorAttachmentResolve.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachmentResolve.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    colorAttachmentResolve.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    colorAttachmentResolve.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
    ...
</div></code></pre>
<p>The render pass now has to be instructed to resolve multisampled color image into regular attachment. Create a new attachment reference that will point to the color buffer which will serve as the resolve target:</p>
<pre class="hljs"><code><div>    ...
    VkAttachmentReference colorAttachmentResolveRef{};
    colorAttachmentResolveRef.attachment = <span class="hljs-number">2</span>;
    colorAttachmentResolveRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    ...
</div></code></pre>
<p>Set the <code>pResolveAttachments</code> subpass struct member to point to the newly created attachment reference. This is enough to let the render pass define a multisample resolve operation which will let us render the image to screen:</p>
<pre class="hljs"><code><div>    ...
    subpass.pResolveAttachments = &amp;colorAttachmentResolveRef;
    ...
</div></code></pre>
<p>Now update render pass info struct with the new color attachment:</p>
<pre class="hljs"><code><div>    ...
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkAttachmentDescription, 3&gt; attachments = {colorAttachment, depthAttachment, colorAttachmentResolve};
    ...
</div></code></pre>
<p>With the render pass in place, modify <code>createFramebuffers</code> and add the new image view to the list:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createFramebuffers</span><span class="hljs-params">()</span> </span>{
        ...
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;VkImageView, 3&gt; attachments = {
            colorImageView,
            depthImageView,
            swapChainImageViews[i]
        };
        ...
}
</div></code></pre>
<p>Finally, tell the newly created pipeline to use more than one sample by modifying <code>createGraphicsPipeline</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>{
    ...
    multisampling.rasterizationSamples = msaaSamples;
    ...
}
</div></code></pre>
<p>Now run your program and you should see the following:</p>
<p><img src="images/multisampling.png" alt=""></p>
<p>Just like with mipmapping, the difference may not be apparent straight away. On a closer look you'll notice that the edges are not as jagged anymore and the whole image seems a bit smoother compared to the original.</p>
<p><img src="images/multisampling_comparison.png" alt=""></p>
<p>The difference is more noticable when looking up close at one of the edges:</p>
<p><img src="images/multisampling_comparison2.png" alt=""></p>
<h2 id="quality-improvements">Quality improvements</h2>
<p>There are certain limitations of our current MSAA implementation which may impact the quality of the output image in more detailed scenes. For example, we're currently not solving potential problems caused by shader aliasing, i.e. MSAA only smoothens out the edges of geometry but not the interior filling. This may lead to a situation when you get a smooth polygon rendered on screen but the applied texture will still look aliased if it contains high contrasting colors. One way to approach this problem is to enable <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap27.html#primsrast-sampleshading">Sample Shading</a> which will improve the image quality even further, though at an additional performance cost:</p>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createLogicalDevice</span><span class="hljs-params">()</span> </span>{
    ...
    deviceFeatures.sampleRateShading = VK_TRUE; <span class="hljs-comment">// enable sample shading feature for the device</span>
    ...
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>{
    ...
    multisampling.sampleShadingEnable = VK_TRUE; <span class="hljs-comment">// enable sample shading in the pipeline</span>
    multisampling.minSampleShading = <span class="hljs-number">.2</span>f; <span class="hljs-comment">// min fraction for sample shading; closer to one is smoother</span>
    ...
}
</div></code></pre>
<p>In this example we'll leave sample shading disabled but in certain scenarios the quality improvement may be noticeable:</p>
<p><img src="images/sample_shading.png" alt=""></p>
<h2 id="conclusion">Conclusion</h2>
<p>It has taken a lot of work to get to this point, but now you finally have a good
base for a Vulkan program. The knowledge of the basic principles of Vulkan that
you now possess should be sufficient to start exploring more of the features,
like:</p>
<ul>
<li>Push constants</li>
<li>Instanced rendering</li>
<li>Dynamic uniforms</li>
<li>Separate images and sampler descriptors</li>
<li>Pipeline cache</li>
<li>Multi-threaded command buffer generation</li>
<li>Multiple subpasses</li>
<li>Compute shaders</li>
</ul>
<p>The current program can be extended in many ways, like adding Blinn-Phong
lighting, post-processing effects and shadow mapping. You should be able to
learn how these effects work from tutorials for other APIs, because despite
Vulkan's explicitness, many concepts still work the same.</p>
<p><a href="/code/30_multisampling.cpp">C++ code</a> /
<a href="/code/27_shader_depth.vert">Vertex shader</a> /
<a href="/code/27_shader_depth.frag">Fragment shader</a></p>
<h1 id="faq">FAQ</h1>
<p>This page lists solutions to common problems that you may encounter while
developing Vulkan applications.</p>
<ul>
<li>
<p><strong>I get an access violation error in the core validation layer</strong>: Make sure
that MSI Afterburner / RivaTuner Statistics Server is not running, because it
has some compatibility problems with Vulkan.</p>
</li>
<li>
<p><strong>I don't see any messages from the validation layers / Validation layers are not available</strong>: First make sure that
the validation layers get a chance to print errors by keeping the terminal open
after your program exits. You can do this from Visual Studio by running your
program with Ctrl-F5 instead of F5, and on Linux by executing your program from
a terminal window. If there are still no messages and you are sure that
validation layers are turned on, then you should ensure that your Vulkan SDK is
correctly installed by following the &quot;Verify the Installation&quot; instructions <a href="https://vulkan.lunarg.com/doc/view/1.2.135.0/windows/getting_started.html">on this page</a>. Also ensure that your SDK version is at least 1.1.106.0 to support the <code>VK_LAYER_KHRONOS_validation</code> layer.</p>
</li>
<li>
<p><strong>vkCreateSwapchainKHR triggers an error in SteamOverlayVulkanLayer64.dll</strong>:
This appears to be a compatibility problem in the Steam client beta. There are a
few possible workarounds:</p>
<ul>
<li>Opt out of the Steam beta program.</li>
<li>Set the <code>DISABLE_VK_LAYER_VALVE_steam_overlay_1</code> environment variable to <code>1</code></li>
<li>Delete the Steam overlay Vulkan layer entry in the registry under <code>HKEY_LOCAL_MACHINE\SOFTWARE\Khronos\Vulkan\ImplicitLayers</code></li>
</ul>
</li>
</ul>
<p>Example:</p>
<p><img src="images/steam_layers_env.png" alt=""></p>
<h1 id="privacy-policy">Privacy policy</h1>
<h2 id="general">General</h2>
<p>This privacy policy applies to the information that is collected when you use vulkan-tutorial.com or any of its subdomains. It describes how the owner of this website, Alexander Overvoorde, collects, uses and shares information about you.</p>
<h2 id="analytics">Analytics</h2>
<p>This website collects analytics about visitors using a self-hosted instance of Matomo (<a href="https://matomo.org/">https://matomo.org/</a>), formerly known as Piwik. It records which pages you visit, what type of device and browser you use, how long you view a given page and where you came from. This information is anonymized by only recording the first two bytes of your IP address (e.g. <code>123.123.xxx.xxx</code>). These anonymized logs are stored for an indefinite amount of time.</p>
<p>These analytics are used for the purpose of tracking how content on the website is consumed, how many people visit the website in general, and which other websites link here. This makes it easier to engage with the community and determine which areas of the website should be improved, for example if extra time should be spent on facilitating mobile reading.</p>
<p>This data is not shared with third parties.</p>
<h2 id="advertisement">Advertisement</h2>
<p>This website uses a third-party advertisement server that may use cookies to track activities on the website to measure engagement with advertisements.</p>
<h2 id="comments">Comments</h2>
<p>Each chapter includes a comment section at the end that is provided by the third-party Disqus service. This service collects identity data to facilitate the reading and submission of comments, and aggregate usage information to improve their service.</p>
<p>The full privacy policy of this third-party service can be found at <a href="https://help.disqus.com/terms-and-policies/disqus-privacy-policy">https://help.disqus.com/terms-and-policies/disqus-privacy-policy</a>.</p>

</body>
</html>
